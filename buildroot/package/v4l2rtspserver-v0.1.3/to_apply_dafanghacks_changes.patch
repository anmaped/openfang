diff -Nura v4l2rtspserver_imp_tools/.circleci/config.yml v4l2rtspserver-master/.circleci/config.yml
--- v4l2rtspserver_imp_tools/.circleci/config.yml	2019-02-01 20:08:29.538626000 +0100
+++ v4l2rtspserver-master/.circleci/config.yml	1970-01-01 01:00:00.000000000 +0100
@@ -1,176 +0,0 @@
-defaults: &defaults
-  working_directory: /v4l2rtspserver
-  docker:
-    - image: heroku/heroku:18
-
-version: 2
-jobs:
-  build_x86_64:
-    <<: *defaults
-
-    steps:
-      - checkout
-      - run: apt-get update; apt-get install -y --no-install-recommends cmake autoconf automake libtool git make g++ liblog4cpp5-dev libasound2-dev pkg-config
-      - run: cmake . && make
-      - run: cpack .
-      - run: mkdir -p /distrib && cp *.deb /distrib 
-      - persist_to_workspace:
-          root: /
-          paths:
-            - distrib 
-
-  build_rpi:
-    <<: *defaults
-
-    steps:
-      - checkout
-      - run: apt-get update; apt-get install -y --no-install-recommends cmake autoconf automake libtool git make pkg-config
-      - run: git clone --depth 1 https://github.com/raspberrypi/tools.git rpi_tools 
-      - run: echo 'export PATH=${CIRCLE_WORKING_DIRECTORY}/rpi_tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin:$PATH' >> $BASH_ENV
-      - run: cmake -DCMAKE_TOOLCHAIN_FILE=${CIRCLE_WORKING_DIRECTORY}/raspberry.toolchain . && make
-      - run: cpack .
-      - run: mkdir -p /distrib && cp *.deb /distrib 
-      - persist_to_workspace:
-          root: /
-          paths:
-            - distrib 
-
-  build_mips:
-    <<: *defaults
-
-    steps:
-      - checkout
-      - run: apt-get update; apt-get install -y --no-install-recommends cmake autoconf automake libtool git make g++-mips-linux-gnu pkg-config
-      - run: cmake -DCMAKE_TOOLCHAIN_FILE=${CIRCLE_WORKING_DIRECTORY}/mips.toolchain . && make
-      - run: cpack .
-      - run: mkdir -p /distrib && cp *.deb /distrib 
-      - persist_to_workspace:
-          root: /
-          paths:
-            - distrib 
-
-  store_artifact:
-    <<: *defaults
-
-    steps:
-      - attach_workspace:
-          at: /
-      - store_artifacts:
-          path: /distrib
-          
-  github_release:
-    <<: *defaults
-
-    steps:
-      - attach_workspace:
-          at: /
-      - run: curl https://storage.googleapis.com/golang/go1.8.linux-amd64.tar.gz | tar -C /usr/local -xzf -
-      - run: echo 'export PATH=/usr/local/go/bin:/root/go/bin:$PATH' >> $BASH_ENV      
-      - run: go get github.com/tcnksm/ghr
-      - deploy:
-          name: "Deploy to Github"
-          command: ghr -t $GITHUB_TOKEN -u $CIRCLE_PROJECT_USERNAME -r $CIRCLE_PROJECT_REPONAME $CIRCLE_TAG /distrib
-
-  # -------------------------------------
-  # publish docker amd64
-  # -------------------------------------
-  publish_docker_linuxamd64:
-    machine:
-      docker_layer_caching: true
-    steps:
-      - checkout
-      - run: git submodule update --init
-      - run:
-          command: |
-            export TAG=${CIRCLE_TAG:-lastest}
-            docker login --username=$DOCKERHUB_USER --password=$DOCKERHUB_PASS
-            docker build --pull -t $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-amd64 -f Dockerfile .
-            docker push $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-amd64
-
-  # -------------------------------------
-  # publish docker arm
-  # -------------------------------------
-  publish_docker_linuxarm32v7:
-    machine:
-      docker_layer_caching: true
-    steps:
-      - checkout
-      - run: git submodule update --init
-      - run:
-          command: |
-            export TAG=${CIRCLE_TAG:-lastest}
-            docker login --username=$DOCKERHUB_USER --password=$DOCKERHUB_PASS
-            docker build --pull -t $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-arm32v7 -f Dockerfile.rpi .
-            docker push $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-arm32v7
-  # -------------------------------------
-  # publish docker manifest
-  # -------------------------------------
-  publish_docker_multiarch:
-    machine:
-      image: circleci/classic:201808-01
-    steps:
-      - run:
-          command: |
-            mkdir $HOME/.docker
-            sh -c 'echo "{ \"experimental\": \"enabled\" }" >> $HOME/.docker/config.json'
-            #
-            docker login --username=$DOCKERHUB_USER --password=$DOCKERHUB_PASS
-            export TAG=${CIRCLE_TAG:-lastest}
-            docker manifest create --amend $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG} $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-amd64 $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-arm32v7
-            docker manifest annotate $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG} $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-amd64 --os linux --arch amd64
-            docker manifest annotate $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG} $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG}-arm32v7 --os linux --arch arm --variant v7
-            docker manifest push $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME:${TAG} -p
-
-
-workflows:
-  version: 2
-  build:
-    jobs:
-      - build_x86_64:
-          filters:
-            tags:
-              only: /.*/      
-      - build_rpi:
-          filters:
-            tags:
-              only: /.*/      
-      - build_mips:
-          filters:
-            tags:
-              only: /.*/      
-      - store_artifact:
-          requires:
-            - build_x86_64
-            - build_rpi
-            - build_mips
-          filters:
-            tags:
-              only: /.*/      
-      - github_release:
-          requires:
-            - build_x86_64
-            - build_rpi
-            - build_mips
-          filters:
-            branches:
-              ignore: /.*/
-            tags:
-              only: /.*/
-
-  docker:
-    jobs:
-      - publish_docker_linuxamd64:
-          filters:
-            tags:
-              only: /.*/            
-      - publish_docker_linuxarm32v7:
-          filters:
-            tags:
-              only: /.*/            
-      - publish_docker_multiarch:
-          requires:
-            - publish_docker_linuxamd64
-            - publish_docker_linuxarm32v7
-          filters:
-            tags:
-              only: /.*/        
diff -Nura v4l2rtspserver_imp_tools/compile.sh v4l2rtspserver-master/compile.sh
--- v4l2rtspserver_imp_tools/compile.sh	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/compile.sh	2019-02-03 20:24:23.640172000 +0100
@@ -0,0 +1,30 @@
+#!/usr/bin/env bash
+HOST=192.168.0.99
+if [ "$#" -ge 1 ]; then
+   HOST=$1
+fi
+
+TOOLCHAIN=$(pwd)/../toolchain/bin
+CROSS_COMPILE=$TOOLCHAIN/mips-linux-gnu-
+export CROSS_COMPILE=${CROSS_COMPILE}
+export CC=${CROSS_COMPILE}gcc
+export LD=${CROSS_COMPILE}g++
+export PKG_CONFIG_PATH="$../_install/lib/pkgconfig"
+export LIBRARY_PATH=../_install/lib
+export CFLAGS="-muclibc -O3 -lrt -I../v4l2rtspserver-tools -I../_install/include/freetype2"
+export CPPFLAGS="-muclibc -O3 -lrt -I../v4l2rtspserver-tools -I../_install/include/freetype2 -std=c++11"
+export LDFLAGS="-muclibc -O3 -lrt -lstdc++ -lpthread -ldl"
+rm CMakeCache.txt
+rm -r CMakeFiles
+cmake -DCMAKE_TOOLCHAIN_FILE="./dafang.toolchain"  -DCMAKE_INSTALL_PREFIX=./_install && make VERBOSE=1 -j4 install
+
+if [ $? == 0 ]; then
+  echo Copying to ${HOST} v4l2rtspserver 
+  ftp-upload -h ${HOST} -u root --password ismart12 -d /system/sdcard/bin/ _install/bin/*
+  for i in _install/libs/*
+  do
+      file=$(realpath $i)
+      echo Copying to ${HOST} ${file}
+      ftp-upload -h ${HOST} -u root --password ismart12 -d /system/sdcard/lib/ $file
+  done
+fi
diff -Nura v4l2rtspserver_imp_tools/dafang.toolchain v4l2rtspserver-master/dafang.toolchain
--- v4l2rtspserver_imp_tools/dafang.toolchain	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/dafang.toolchain	2019-02-03 20:24:23.640172000 +0100
@@ -0,0 +1,15 @@
+SET(CMAKE_SYSTEM_NAME Linux)
+SET(CMAKE_SYSTEM_PROCESSOR mips)
+
+
+SET(CMAKE_BUILD_TYPE Debug)
+
+SET(CMAKE_CXX_COMPILER ${CMAKE_CURRENT_SOURCE_DIR}/../toolchain/bin/mips-linux-gnu-g++)
+SET(CMAKE_LINKER ${CMAKE_CURRENT_SOURCE_DIR}/../toolchain/bin/mips-linux-gnu-ld)
+
+
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+
+
diff -Nura v4l2rtspserver_imp_tools/Dockerfile v4l2rtspserver-master/Dockerfile
--- v4l2rtspserver_imp_tools/Dockerfile	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/Dockerfile	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-FROM debian as builder
-LABEL maintainer michel.promonet@free.fr
-WORKDIR /v4l2rtspserver
-COPY . /v4l2rtspserver
-
-RUN apt-get update \
-    && apt-get install -y --no-install-recommends g++ autoconf automake libtool xz-utils cmake make liblog4cpp5-dev pkg-config git wget \
-    && cmake . && make install && apt-get clean && rm -rf /var/lib/apt/lists/
-
-FROM ubuntu:18.04
-WORKDIR /usr/local/share/v4l2rtspserver
-COPY --from=builder /usr/local/bin/ /usr/local/bin/
-COPY --from=builder /usr/local/share/v4l2rtspserver/ /usr/local/share/v4l2rtspserver/
-
-EXPOSE 8554
-ENTRYPOINT [ "/usr/local/bin/v4l2rtspserver" ]
-CMD [ "-S" ]
diff -Nura v4l2rtspserver_imp_tools/Dockerfile.rpi v4l2rtspserver-master/Dockerfile.rpi
--- v4l2rtspserver_imp_tools/Dockerfile.rpi	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/Dockerfile.rpi	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-FROM debian as builder
-LABEL maintainer michel.promonet@free.fr
-WORKDIR /v4l2rtspserver
-COPY . /v4l2rtspserver
-
-RUN apt-get update \
-        && apt-get install -y --no-install-recommends ca-certificates g++ autoconf automake libtool xz-utils cmake make liblog4cpp5-dev pkg-config git wget \
-        && wget -qO- https://releases.linaro.org/components/toolchain/binaries/6.4-2018.05/arm-linux-gnueabihf/gcc-linaro-6.4.1-2018.05-x86_64_arm-linux-gnueabihf.tar.xz  | tar xJ \
-	&& export PATH=$(pwd)/gcc-linaro-6.4.1-2018.05-x86_64_arm-linux-gnueabihf/bin:$PATH \
-        && cmake -DCMAKE_TOOLCHAIN_FILE=raspberry.toolchain . && make install \
-	&& apt-get clean && rm -rf /var/lib/apt/lists/
-
-
-FROM balenalib/rpi-raspbian
-WORKDIR /usr/local/share/v4l2rtspserver
-COPY --from=builder /usr/local/bin/ /usr/local/bin/
-COPY --from=builder /usr/local/share/v4l2rtspserver/ /usr/local/share/v4l2rtspserver/
-
-EXPOSE 8554
-ENTRYPOINT [ "/usr/local/bin/v4l2rtspserver" ]
-CMD [ "-S" ]
diff -Nura v4l2rtspserver_imp_tools/filter/g711super.c v4l2rtspserver-master/filter/g711super.c
--- v4l2rtspserver_imp_tools/filter/g711super.c	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/g711super.c	2019-02-03 20:24:23.640172000 +0100
@@ -0,0 +1,207 @@
+/******************************************************************************/
+/* SUPER-FAST G.711 UTILITES (PCMU,PCMA)                                      */
+/*                                                                            */
+/* (c) TODO: find authors                                                     */
+/******************************************************************************/
+
+#include "g711super.h"
+
+//======== DECOMPRESS FUNCTIONS ===============================
+
+short MuLawDecompressTable[256] =
+{
+     -32124,-31100,-30076,-29052,-28028,-27004,-25980,-24956,
+     -23932,-22908,-21884,-20860,-19836,-18812,-17788,-16764,
+     -15996,-15484,-14972,-14460,-13948,-13436,-12924,-12412,
+     -11900,-11388,-10876,-10364, -9852, -9340, -8828, -8316,
+      -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
+      -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
+      -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
+      -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
+      -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
+      -1372, -1308, -1244, -1180, -1116, -1052,  -988,  -924,
+       -876,  -844,  -812,  -780,  -748,  -716,  -684,  -652,
+       -620,  -588,  -556,  -524,  -492,  -460,  -428,  -396,
+       -372,  -356,  -340,  -324,  -308,  -292,  -276,  -260,
+       -244,  -228,  -212,  -196,  -180,  -164,  -148,  -132,
+       -120,  -112,  -104,   -96,   -88,   -80,   -72,   -64,
+        -56,   -48,   -40,   -32,   -24,   -16,    -8,     0,
+      32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
+      23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
+      15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
+      11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316,
+       7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140,
+       5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092,
+       3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004,
+       2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980,
+       1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436,
+       1372,  1308,  1244,  1180,  1116,  1052,   988,   924,
+        876,   844,   812,   780,   748,   716,   684,   652,
+        620,   588,   556,   524,   492,   460,   428,   396,
+        372,   356,   340,   324,   308,   292,   276,   260,
+        244,   228,   212,   196,   180,   164,   148,   132,
+        120,   112,   104,    96,    88,    80,    72,    64,
+         56,    48,    40,    32,    24,    16,     8,     0
+};
+
+short ALawDecompressTable[256] =
+{
+     -5504, -5248, -6016, -5760, -4480, -4224, -4992, -4736,
+     -7552, -7296, -8064, -7808, -6528, -6272, -7040, -6784,
+     -2752, -2624, -3008, -2880, -2240, -2112, -2496, -2368,
+     -3776, -3648, -4032, -3904, -3264, -3136, -3520, -3392,
+     -22016,-20992,-24064,-23040,-17920,-16896,-19968,-18944,
+     -30208,-29184,-32256,-31232,-26112,-25088,-28160,-27136,
+     -11008,-10496,-12032,-11520,-8960, -8448, -9984, -9472,
+     -15104,-14592,-16128,-15616,-13056,-12544,-14080,-13568,
+     -344,  -328,  -376,  -360,  -280,  -264,  -312,  -296,
+     -472,  -456,  -504,  -488,  -408,  -392,  -440,  -424,
+     -88,   -72,   -120,  -104,  -24,   -8,    -56,   -40,
+     -216,  -200,  -248,  -232,  -152,  -136,  -184,  -168,
+     -1376, -1312, -1504, -1440, -1120, -1056, -1248, -1184,
+     -1888, -1824, -2016, -1952, -1632, -1568, -1760, -1696,
+     -688,  -656,  -752,  -720,  -560,  -528,  -624,  -592,
+     -944,  -912,  -1008, -976,  -816,  -784,  -880,  -848,
+      5504,  5248,  6016,  5760,  4480,  4224,  4992,  4736,
+      7552,  7296,  8064,  7808,  6528,  6272,  7040,  6784,
+      2752,  2624,  3008,  2880,  2240,  2112,  2496,  2368,
+      3776,  3648,  4032,  3904,  3264,  3136,  3520,  3392,
+      22016, 20992, 24064, 23040, 17920, 16896, 19968, 18944,
+      30208, 29184, 32256, 31232, 26112, 25088, 28160, 27136,
+      11008, 10496, 12032, 11520, 8960,  8448,  9984,  9472,
+      15104, 14592, 16128, 15616, 13056, 12544, 14080, 13568,
+      344,   328,   376,   360,   280,   264,   312,   296,
+      472,   456,   504,   488,   408,   392,   440,   424,
+      88,    72,   120,   104,    24,     8,    56,    40,
+      216,   200,   248,   232,   152,   136,   184,   168,
+      1376,  1312,  1504,  1440,  1120,  1056,  1248,  1184,
+      1888,  1824,  2016,  1952,  1632,  1568,  1760,  1696,
+      688,   656,   752,   720,   560,   528,   624,   592,
+      944,   912,  1008,   976,   816,   784,   880,   848
+};
+
+//======== COMPRESS FUNCTIONS =================================
+
+const int cBias = 0x84;
+const int cClip = 32635;
+
+char MuLawCompressTable2[256] =
+{
+     0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
+     4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+     5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+     5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+     6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+};
+
+char ALawCompressTable2[128] =
+{
+     1,1,2,2,3,3,3,3,
+     4,4,4,4,4,4,4,4,
+     5,5,5,5,5,5,5,5,
+     5,5,5,5,5,5,5,5,
+     6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,
+     6,6,6,6,6,6,6,6,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7,
+     7,7,7,7,7,7,7,7
+};
+
+
+unsigned char MuLawCompressTable[16384];
+unsigned char ALawCompressTable[16384];
+
+
+//------------------------------------------------------------
+unsigned char MuLawALawRecompressTable[256];
+unsigned char ALawMuLawRecompressTable[256];
+
+
+//------------------------------------------------------------
+inline uint8_t  linear2mulaw2(int16_t sample)
+{
+     int sign = (sample >> 8) & 0x80;
+     if (sign)
+          sample = (short)-sample;
+     if (sample > cClip)
+          sample = cClip;
+     sample = (short)(sample + cBias);
+     int exponent = (int)MuLawCompressTable2[(sample>>7) & 0xFF];
+     int mantissa = (sample >> (exponent+3)) & 0x0F;
+     int compressedByte = ~ (sign | (exponent << 4) | mantissa);
+
+     return (unsigned char)compressedByte;
+}
+
+
+//------------------------------------------------------------
+inline uint8_t  linear2alaw2(int16_t sample)
+{
+     int sign;
+     int exponent;
+     int mantissa;
+     unsigned char compressedByte;
+
+     sign = ((~sample) >> 8) & 0x80;
+     if (!sign)
+          sample = (short)-sample;
+     if (sample > cClip)
+          sample = cClip;
+     if (sample >= 256)
+     {
+          exponent = (int)ALawCompressTable2[(sample >> 8) & 0x7F];
+          mantissa = (sample >> (exponent + 3) ) & 0x0F;
+          compressedByte = ((exponent << 4) | mantissa);
+     }
+     else
+     {
+          compressedByte = (unsigned char)(sample >> 4);
+     }
+     compressedByte ^= (sign ^ 0x55);
+     return compressedByte;
+} 
+
+
+
+char needinitg711 = 1;
+//------------------------------------------------------------
+inline void init_g711(void)
+{
+    int           i;
+    
+    if(needinitg711)
+    {
+        needinitg711 = 0;
+        
+        // set up the reverse (mu-law,a-law) conversion table
+        for(i = -32768; i < 32768; i += 4) {
+            MuLawCompressTable[((unsigned short)(short)i) >> 2] = linear2mulaw2(i);
+            ALawCompressTable [((unsigned short)(short)i) >> 2] = linear2alaw2 (i);
+        }
+
+        // set up recomression tables
+        for(i=0; i<256; i++) {
+            MuLawALawRecompressTable[i] = linear2alaw ( mulaw2linear(i) );
+            ALawMuLawRecompressTable[i] = linear2mulaw(  alaw2linear(i) );
+        }
+    }
+}
+
diff -Nura v4l2rtspserver_imp_tools/filter/g711super.h v4l2rtspserver-master/filter/g711super.h
--- v4l2rtspserver_imp_tools/filter/g711super.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/g711super.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,35 @@
+/******************************************************************************/
+/* SUPER-FAST G.711 UTILITES (PCMU,PCMA)                                      */
+/*                                                                            */
+/* (c) TODO: find authors                                                     */
+/******************************************************************************/
+
+#ifndef G711SUPER_H
+#define G711SUPER_H
+
+#include "types.h"
+
+//------------------------------------------------------------
+inline void  init_g711(void);
+
+//------------------------------------------------------------
+extern short MuLawDecompressTable[256];
+extern short ALawDecompressTable[256];
+#define mulaw2linear(a) (MuLawDecompressTable[a])
+#define alaw2linear(a)  (ALawDecompressTable[a])
+
+//------------------------------------------------------------
+extern unsigned char MuLawCompressTable[16384];
+extern unsigned char ALawCompressTable[16384];
+#define linear2mulaw(a) (MuLawCompressTable[((unsigned short)(a)) >> 2])
+#define linear2alaw(a)  (ALawCompressTable[((unsigned short)(a)) >> 2])
+
+//------------------------------------------------------------
+extern unsigned char MuLawALawRecompressTable[256];
+extern unsigned char ALawMuLawRecompressTable[256];
+#define mulaw2alaw(a) (MuLawALawRecompressTable[a])
+#define alaw2mulaw(a) (ALawMuLawRecompressTable[a])
+
+
+#endif //G711SUPER_H
+
diff -Nura v4l2rtspserver_imp_tools/filter/git v4l2rtspserver-master/filter/git
--- v4l2rtspserver_imp_tools/filter/git	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/git	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1 @@
+https://github.com/SergMa/free-nross.git
diff -Nura v4l2rtspserver_imp_tools/filter/gsm.h v4l2rtspserver-master/filter/gsm.h
--- v4l2rtspserver_imp_tools/filter/gsm.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/gsm.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,73 @@
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	GSM_H
+#define	GSM_H
+
+#ifdef __cplusplus
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#if __STDC__
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#ifdef _NO_PROTO
+#	undef	NeedFunctionPrototypes
+#endif
+
+#ifdef NeedFunctionPrototypes
+#   include	<stdio.h>		/* for FILE * 	*/
+#endif
+
+#undef GSM_P
+#if NeedFunctionPrototypes
+#	define	GSM_P( protos )	protos
+#else
+#	define  GSM_P( protos )	( /* protos */ )
+#endif
+
+/*
+ *	Interface
+ */
+
+typedef struct gsm_state * 	gsm;
+typedef short		   	gsm_signal;		/* signed 16 bit */
+typedef unsigned char		gsm_byte;
+typedef gsm_byte 		gsm_frame[33];		/* 33 * 8 bits	 */
+
+#define	GSM_MAGIC		0xD		  	/* 13 kbit/s RPE-LTP */
+
+#define	GSM_PATCHLEVEL		10
+#define	GSM_MINOR		0
+#define	GSM_MAJOR		1
+
+#define	GSM_OPT_VERBOSE		1
+#define	GSM_OPT_FAST		2
+#define	GSM_OPT_LTP_CUT		3
+#define	GSM_OPT_WAV49		4
+#define	GSM_OPT_FRAME_INDEX	5
+#define	GSM_OPT_FRAME_CHAIN	6
+
+extern gsm  gsm_create 	GSM_P((void));
+extern void gsm_destroy GSM_P((gsm));	
+
+extern void gsm_init 	GSM_P((gsm)); //Added by Serg Ma 11.04.2008
+
+extern int  gsm_print   GSM_P((FILE *, gsm, gsm_byte  *));
+extern int  gsm_option  GSM_P((gsm, int, int *));
+
+extern void gsm_encode  GSM_P((gsm, gsm_signal *, gsm_byte  *));
+extern int  gsm_decode  GSM_P((gsm, gsm_byte   *, gsm_signal *));
+
+extern int  gsm_explode GSM_P((gsm, gsm_byte   *, gsm_signal *));
+extern void gsm_implode GSM_P((gsm, gsm_signal *, gsm_byte   *));
+
+#undef	GSM_P
+
+#endif	/* GSM_H */
diff -Nura v4l2rtspserver_imp_tools/filter/my_fract.h v4l2rtspserver-master/filter/my_fract.h
--- v4l2rtspserver_imp_tools/filter/my_fract.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/my_fract.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,238 @@
+/******************************************************************************/
+/* FRACTIONAL ARITHMETICS UTILITES                                            */
+/* my_fract.h                                                                 */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#ifndef MY_FRACT_H
+#define MY_FRACT_H
+
+/******************************************************************************/
+/* Type definitions                                                           */
+/******************************************************************************/
+
+typedef   unsigned char         u8;
+typedef   unsigned short        u16;
+typedef   unsigned int          u32;
+typedef   unsigned long long    u64;
+typedef   signed char           s8;
+typedef   signed short          s16;
+typedef   signed int            s32;
+typedef   signed long long      s64;
+
+typedef   short                 fract16;
+typedef   long                  fract32;
+
+/******************************************************************************/
+/* FRACT 16 UTILITES                                                          */
+/******************************************************************************/
+
+#define  FRACT16_TO_FLOAT(a)  ((float)((fract16)(a))/(32768.0))
+#define  FLOAT_TO_FRACT16(a)  ((fract16)((a)*32768))
+
+#ifdef _bfin_
+
+#define  MULT16(a,b)    __builtin_bfin_multr_fr1x16(a,b)
+#define  ADD16(a,b)     __builtin_bfin_add_fr1x16(a,b)
+#define  SUB16(a,b)     __builtin_bfin_sub_fr1x16(a,b)
+#define  ABS16(a)       __builtin_bfin_abs_fr1x16(a)
+#define  NEG16(a)       __builtin_bfin_negate_fr1x16(a)
+#define  ASHL16(a,b)    __builtin_bfin_shl_fr1x16(a,b)  //b>=0, arithmetical left shift
+#define  ASHR16(a,b)    __builtin_bfin_shl_fr1x16(a,-b) //b>=0  arithmetical right shift
+#define  ASHIFT16(a,b)  __builtin_bfin_shl_fr1x16(a,b)  //arithmetical shift
+#define  MIN16(a,b)     __builtin_bfin_min_fr1x16(a,b)
+#define  MAX16(a,b)     __builtin_bfin_max_fr1x16(a,b)
+#define  DIV16(a,b)     BF_DIV16(a,b)
+
+#else
+
+#define  MULT16(a,b)    (fract16)((((s32)a)*((s32)b))>>15)  //(1.15)*(1.15)=(2.30) -> convert into (1.15)
+#define  ADD16(a,b)     (a+b)                               //no saturation
+#define  SUB16(a,b)     (a-b)                               //no saturation
+#define  ABS16(a)       ((a>=0)?(a):(-a))                   //no saturation
+#define  NEG16(a)       (-(a))                              //no saturation
+#define  ASHL16(a,b)    (a<<b)  //b>=0  arithmetical left shift,  no saturation
+#define  ASHR16(a,b)    (a>>b)  //b>=0  arithmetical right shift, no saturation
+#define  ASHIFT16(a,b)  ((b>0)?(a<<b):(a>>(-b)))  //arithmetical shift, no saturation
+#define  MIN16(a,b)     ((a<b)?(a):(b))
+#define  MAX16(a,b)     ((a>b)?(a):(b))
+#define  DIV16(a,b)     ((((s32)a)<<15)/((s32)b))           //(1.15)/(1.15)=(2.30)/(1.15)=(1.15)
+
+#endif
+
+/******************************************************************************/
+/* FRACT 32 UTILITES                                                          */
+/******************************************************************************/
+
+#define  FRACT32_TO_FLOAT(a)  ((float)((fract32)(a))/(32768.0*65536.0))
+#define  FLOAT_TO_FRACT32(a)  ((fract32)((a)*32768*65536))
+
+#ifdef _bfin_
+
+#define  MULT32(a,b)   BF_MULT32(a,b)
+#define  ADD32(a,b)    BF_ADD32(a,b)
+#define  SUB32(a,b)    BF_SUB32(a,b)
+#define  ABS32(a)      BF_ABS32(a)
+#define  NEG32(a)      BF_NEG32(a)
+#define  ASHL32(a,b)   BF_ASHIFT32(a,b)
+#define  ASHR32(a,b)   BF_ASHIFT32(a,-(b))
+#define  ASHIFT32(a,b) BF_ASHIFT32(a,b)
+#define  MIN32(a,b)    BF_MIN32(a,b)
+#define  MAX32(a,b)    BF_MAX32(a,b)
+#define  DIV3216(a,b)  DIV32_16(a,b)
+
+#else /* #ifdef _bfin_ */
+
+#define  MULT32(a,b)   (fract32)((((s64)a)*((s64)b))>>31) //(1.31)*(1.31)=(2.62) -> convert into (1.31)
+#define  ADD32(a,b)    (a+b)                              //no saturation
+#define  SUB32(a,b)    (a-b)                              //no saturation
+#define  ABS32(a)      ((a>=0)?(a):(-a))                  //no saturation
+#define  NEG32(a)      (-(a))                             //no saturation
+#define  ASHL32(a,b)   (a<<b)  //b>=0  arithmetical left shift,  no saturation
+#define  ASHR32(a,b)   (a>>b)  //b>=0  arithmetical right shift, no saturation
+#define  ASHIFT32(a,b) ((b>0)?(a<<b):(a>>(-b)))  //arithmetical shift, no saturation
+#define  MIN32(a,b)    ((a<b)?(a):(b))
+#define  MAX32(a,b)    ((a>b)?(a):(b))
+#define  DIV3216(a,b)  ((s16)((((s32)a)>>1)/((s32)b)))    //(1.31)/(1.15) = (2.30)/(1.15) = (1.15)
+
+#endif /* #ifdef _bfin_ */
+
+/******************************************************************************/
+/* FRACT 16/32 UTILITES                                                       */
+/******************************************************************************/
+
+volatile static union {
+        struct {
+                fract16 lo;
+                fract16 hi;
+        } two16;
+        fract32 one32;
+} convert;
+
+#define  F32    convert.one32   /* Usage: F32=x_fract32; x_fract16=F16HI; y_fract16=F16LO; */
+#define  F16LO  convert.two16.lo
+#define  F16HI  convert.two16.hi
+
+/******************************************************************************/
+/* UTILITES IMPLEMENTATIONS                                                   */
+/******************************************************************************/
+
+#ifdef _bfin_
+
+static inline fract16 DIV32_16(fract32 a, fract16 b)
+{
+        fract32 res, bb;
+        bb = b;
+        __asm__("R0 = %1;"
+                "R1 = %2;"
+        /*      "R0 <<= 1;" */
+                "DIVS(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "DIVQ(R0,R1);"
+                "R0 = R0.L;"
+                "%0 = R0;":"=m"(res)
+                :"m"(a), "m"(bb)
+                :"R0", "R1", "cc");
+        return res;
+}
+
+static inline fract16 BF_DIV16(fract16 a, fract16 b)
+{
+        fract32 a32;
+        F16HI = a;
+        a32 = F32;
+        return DIV32_16(a32, b);
+}
+
+static inline fract32 BF_MAX32(fract32 a, fract32 b)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = MAX(%1,%2);":"=d"(res)
+                             :"d"(a), "d"(b)
+            );
+        return res;
+}
+
+static inline fract32 BF_MIN32(fract32 a, fract32 b)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = MIN(%1,%2);":"=d"(res)
+                             :"d"(a), "d"(b)
+            );
+        return res;
+}
+
+static inline fract32 BF_ADD32(fract32 a, fract32 b)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = %1 + %2 (S);":"=d"(res)
+                             :"d"(a), "d"(b)
+            );
+        return res;
+}
+
+static inline fract32 BF_SUB32(fract32 a, fract32 b)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = %1 - %2 (S);":"=d"(res)
+                             :"d"(a), "d"(b)
+            );
+        return res;
+}
+
+static inline fract32 BF_ABS32(fract32 a)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = ABS %1;":"=d"(res)
+                             :"d"(a)
+            );
+        return res;
+}
+
+static inline fract32 BF_NEG32(fract32 a)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = - %1 (S);":"=d"(res)
+                             :"d"(a)
+            );
+        return res;
+}
+
+static inline fract32 BF_MULT32(fract32 a, fract32 b)
+{
+        fract32 res;
+        __asm__ __volatile__("A1 = A0 = 0;"
+                             "R2 = ( A0 += %1.H * %2.H ),"
+                             "A1 += %1.H * %2.L (M);"
+                             "%0 = ( A1 += %2.H * %1.L ) (M);"
+                             "%0 = %0 >>> 15;" "%0 = R2 + %0 (S);":"=W"(res)
+                             :"d"(a), "d"(b)
+                             :"A0", "A1", "R2");
+        return res;
+}
+
+static inline fract32 BF_ASHIFT32(fract32 a, signed short b)
+{
+        fract32 res;
+        __asm__ __volatile__("%0 = ASHIFT %1 BY %2.L (S);":"=d"(res)
+                             :"d"(a), "d"(b)
+            );
+        return res;
+}
+
+#endif /* #ifdef _bfin_ */
+
+#endif /* MY_FRACT_H */
diff -Nura v4l2rtspserver_imp_tools/filter/mylog.c v4l2rtspserver-master/filter/mylog.c
--- v4l2rtspserver_imp_tools/filter/mylog.c	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/mylog.c	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,6 @@
+/******************************************************************************/
+/* LOG-OUT UTILITES                                                           */
+/* mylog.c                                                                    */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
diff -Nura v4l2rtspserver_imp_tools/filter/mylog.h v4l2rtspserver-master/filter/mylog.h
--- v4l2rtspserver_imp_tools/filter/mylog.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/mylog.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,132 @@
+/******************************************************************************/
+/* LOG-OUT UTILITES                                                           */
+/* mylog.h                                                                    */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#ifndef MYLOG_H
+#define MYLOG_H
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <sys/types.h>
+
+//---- FUNCTIONS ---------------------------------------------
+
+#define MYLOGDEVICE_NOLOGS     0
+#define MYLOGDEVICE_STDOUT     1  //printf()
+
+#ifndef MYLOGDEVICE
+#define MYLOGDEVICE MYLOGDEVICE_NOLOGS
+#endif
+
+    //////////////////////////////////////////////////////////////
+#if MYLOGDEVICE == MYLOGDEVICE_NOLOGS
+    //////////////////////////////////////////////////////////////
+
+    #define MYLOG_SCREEN(mess...) \
+        do{                       \
+            printf(mess);         \
+            printf("\n");         \
+        }while(0)
+
+    #define MYLOG_USER(mess...)
+    #define MYLOG_ERROR(mess...)
+    #define MYLOG_WARNING(mess...)
+    #define MYLOG_EVENT(mess...)
+    #define MYLOG_MESSAGE(mess...)
+    #define MYLOG_STATE(mess...)
+    #define MYLOG_DEBUG(mess...)
+    #define MYLOG_TRACE(mess...)
+    #define MYLOG_GOD(mess...)
+    #define MYLOG_REALTIME(mess...)
+
+    //////////////////////////////////////////////////////////////
+#elif (MYLOGDEVICE == MYLOGDEVICE_STDOUT)
+    //////////////////////////////////////////////////////////////
+
+    #define MYLOG_SCREEN(mess...)                                 \
+        do{                                                       \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_USER(mess...)                                   \
+        do{                                                       \
+            printf("USE %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_ERROR(mess...)                                  \
+        do{                                                       \
+            printf("ERR %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_WARNING(mess...)                                \
+        do{                                                       \
+            printf("WAR %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_EVENT(mess...)                                  \
+        do{                                                       \
+            printf("EVE %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_MESSAGE(mess...)                                \
+        do{                                                       \
+            printf("MES %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_STATE(mess...)                                  \
+        do{                                                       \
+            printf("STA %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_DEBUG(mess...)                                  \
+        do{                                                       \
+            printf("USE %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_TRACE(mess...)                                  \
+        do{                                                       \
+            printf("TRA %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_GOD(mess...)                                    \
+        do{                                                       \
+            printf("GOD %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    #define MYLOG_REALTIME(mess...)                               \
+        do{                                                       \
+            printf("REA %d:%s: ",__LINE__,__FUNCTION__);          \
+            printf(mess);                                         \
+            printf("\n");                                         \
+        }while(0)
+
+    //////////////////////////////////////////////////////////////
+#endif // MYLOGDEVICE
+    //////////////////////////////////////////////////////////////
+
+
+#endif //MYLOG_H
+
+
diff -Nura v4l2rtspserver_imp_tools/filter/noise_remover.c v4l2rtspserver-master/filter/noise_remover.c
--- v4l2rtspserver_imp_tools/filter/noise_remover.c	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/noise_remover.c	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,402 @@
+/******************************************************************************/
+/* NOISE REMOVER                                                              */
+/* noise_remover.c                                                            */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#include  "noise_remover.h"
+
+/*****************************************************************************/
+/* DEFINITIONS                                                               */
+/*****************************************************************************/
+
+#define TR          0x66660000  // 0.8
+#define TF          0x7F5C0000  // 0.995
+#define INCRTIME1   16000
+#define INCRTIME2   32000
+#define INCR1       0x000000D6  // 0.0000001
+#define INCR2       0x00000431  // 0.0000005
+#define INCR3       0x000014F8  // 0.0000025
+
+#define SENS        0x00000000  // 1.5 = 1.0 + 0.5  //sensitivity [0..2],
+                                // 0=do not remove noise,
+                                // 1..2=remove noise totally
+#define SENS1       0x7FFFFFFF  // 1.0 part of SENS
+#define SENS2       0x40000000  // 0.5 part of SENS
+
+#define ATR         0x7333      // 0.9
+#define ATF         0x7FDF      // 0.999
+#define EMIN        0x00010000  // 0.0000305..
+#define MINALPHA    0x0CCC      // 0.1
+#define MAXALPHA    0x7FFF      // 1.0
+
+/******************************************************************************/
+/* CONSTANTS                                                                  */
+/******************************************************************************/
+
+/* filters coefficients in (1.15) format */
+static const fract16 LF300_COEFF [FILTER_LEN] = {
+     253,    471,    707,    955,   1207,   1455,   1691,   1907,   2095,
+    2249,   2364,   2434,   2458,   2434,   2364,   2249,   2095,   1907,
+    1691,   1455,   1207,    955,    707,    471,    253
+    };
+
+static const fract16 BF600_COEFF [FILTER_LEN] = {
+    -733,  -1273,  -1706,  -1952,  -1953,  -1683,  -1162,   -447,    368,
+    1172,   1848,   2299,   2458,   2299,   1848,   1172,    368,   -447,
+   -1162,  -1683,  -1953,  -1952,  -1706,  -1273,   -733
+    };
+
+static const fract16 BF900_COEFF [FILTER_LEN] = {
+     1142,   1700,   1706,   1086,      0,  -1191,  -2055,  -2250,  -1663,
+     -468,    930,   2038,   2458,   2038,    930,   -468,  -1663,  -2250,
+    -2055,  -1191,      0,   1086,   1706,   1700,   1142
+    };
+
+static const fract16 BF1200_COEFF [FILTER_LEN] = {
+    -1439,  -1626,   -707,    818,   1953,   1870,    519,  -1274,  -2323,
+    -1883,   -191,   1664,   2458,   1664,   -191,  -1883,  -2323,  -1274,
+      519,   1870,   1953,    818,   -707,  -1626,  -1439
+    };
+
+static const fract16 BF1500_COEFF [FILTER_LEN] = {
+     1595,   1073,   -707,  -1940,  -1207,    897,   2217,   1274,  -1068,
+    -2396,  -1270,   1198,   2458,   1198,  -1270,  -2396,  -1068,   1274,
+     2217,    897,  -1207,  -1940,   -707,   1073,   1595
+    };
+
+static const fract16 BF1800_COEFF [FILTER_LEN] = {
+    -1595,   -204,   1706,   1210,  -1207,  -2011,    174,   2250,   1068,
+    -1761,  -2073,    665,   2458,    665,  -2073,  -1761,   1068,   2250,
+      174,  -2011,  -1207,   1210,   1706,   -204,  -1595
+    };
+
+static const fract16 BF2100_COEFF [FILTER_LEN] = {
+     1439,   -726,  -1706,    676,   1953,   -582,  -2162,    447,   2323,
+     -282,  -2423,     96,   2458,     96,  -2423,   -282,   2323,    447,
+    -2162,   -582,   1953,    676,  -1706,   -726,   1439
+    };
+
+static const fract16 BF2500_COEFF [FILTER_LEN] = {
+    -1479,    929,   1414,  -1886,   -746,   2593,   -433,  -2697,   1790,
+     2042,  -2867,   -761,   3277,   -761,  -2867,   2042,   1790,  -2697,
+     -433,   2593,   -746,  -1886,   1414,    929,  -1479
+    };
+
+static const fract16 BF3000_COEFF [FILTER_LEN] = {
+     817,    292,  -1706,   1826,      0,  -2380,   2923,   -670,  -2590,
+    3775,  -1525,  -2260,   4096,  -2260,  -1525,   3775,  -2590,   -670,
+    2923,  -2380,      0,   1826,  -1706,    292,    817
+    };
+
+static const fract16 BF3500_COEFF [FILTER_LEN] = {
+      817,  -1469,   1706,  -1220,      0,   1591,  -2923,   3367,  -2590,
+      751,   1525,  -3382,   4096,  -3382,   1525,    751,  -2590,   3367,
+    -2923,   1591,      0,  -1220,   1706,  -1469,    817
+    };
+
+static const fract16 HF4000_COEFF [FILTER_LEN] = {
+     -817,    832,   -707,    429,      0,   -559,   1211,  -1907,   2590,
+    -3200,   3681,  -3990,   4096,  -3990,   3681,  -3200,   2590,  -1907,
+     1211,   -559,      0,    429,   -707,    832,   -817
+    };
+
+/******************************************************************************/
+/* FUNCTIONS                                                                  */
+/******************************************************************************/
+
+//------------------------------------------------------------------------------
+static inline void filter_init( struct fir_s * filter, const fract16 * coeff )
+{
+    int i;
+    filter->coeff = coeff;
+    filter->pos = 0;
+    for(i=0; i<2*FILTER_LEN; i++)
+        filter->delay[i] = 0;
+    return;
+}
+
+//------------------------------------------------------------------------------
+//Double filter delay size optimization is based on OSLEC source code
+static inline fract16 filter( struct fir_s * filter, fract16 x )
+{
+    int       i;
+    fract16   y;
+    fract16 * xptr;
+    const fract16 * cptr;
+
+    filter->delay[filter->pos             ] = x;
+    filter->delay[filter->pos + FILTER_LEN] = x;
+
+    filter->pos++;
+    if(filter->pos >= FILTER_LEN)
+        filter->pos = 0;
+
+    cptr = filter->coeff;
+    xptr = filter->delay + filter->pos;
+    y = 0x0000;
+    for(i=0; i<FILTER_LEN; i++) {
+        y = ADD16( y, MULT16( *(cptr++), *(xptr++) ) );
+    }
+    return y;
+}
+
+#if 0
+//------------------------------------------------------------------------------
+static inline fract16 filter_hf100( struct noise_remover_s * nrm, fract16 x )
+{
+    fract32 x32;
+
+    if(!nrm)
+            return 0;
+
+    /*******************************************/
+    /* high pass filter                        */
+    /* IIR-filter, Fs=8000 Hz, Fc=100 Hz       */
+    /*                                         */
+    /* y = k * (b1*x + b2*xdelay - a2*ydelay); */
+    /* xdelay = x;                             */
+    /* ydelay = y;                             */
+    /*                                         */
+    /* The same:                               */
+    /*                                         */
+    /* y = k * (x - xdelay - a2*ydelay);       */
+    /* xdelay = x;                             */
+    /* ydelay = y;                             */
+    /*                                         */
+    /*******************************************/
+
+    #define  HF100_B1  (0x7FFFFFFF)  //b1 =  1.00000000 //100 Hz
+    #define  HF100_B2  (0x80000000)  //b2 = -1.00000000
+    #define  HF100_A2  (0x89AE0000)  //a2 = -0.9243905;
+    #define  HF100_K   (0x7B290000)  //k  =  0.9621952
+
+    F16LO = 0;
+    F16HI = x;
+    x32 = F32;
+
+    F32 = MULT32( HF100_A2 , nrm->hf100_ydelay );
+    F32 = SUB32 ( x32      , F32               );
+    F32 = SUB32 ( F32      , nrm->hf100_xdelay );
+    F32 = MULT32( HF100_K  , F32               );
+    nrm->hf100_xdelay = x32;
+    nrm->hf100_ydelay = F32;
+
+    return F16HI;
+}
+#endif
+
+//------------------------------------------------------------------------------
+int noise_remover_init (struct noise_remover_s * nrm)
+{
+    int k;
+
+    if(!nrm)
+        return -1;
+
+    /* init filters */
+    nrm->hf100_xdelay = 0;
+    nrm->hf100_ydelay = 0;
+
+    filter_init ( &(nrm->filter[ 0]), LF300_COEFF  );
+    filter_init ( &(nrm->filter[ 1]), BF600_COEFF  );
+    filter_init ( &(nrm->filter[ 2]), BF900_COEFF  );
+    filter_init ( &(nrm->filter[ 3]), BF1200_COEFF );
+    filter_init ( &(nrm->filter[ 4]), BF1500_COEFF );
+    filter_init ( &(nrm->filter[ 5]), BF1800_COEFF );
+    filter_init ( &(nrm->filter[ 6]), BF2100_COEFF );
+    filter_init ( &(nrm->filter[ 7]), BF2500_COEFF );
+    filter_init ( &(nrm->filter[ 8]), BF3000_COEFF );
+    filter_init ( &(nrm->filter[ 9]), BF3500_COEFF );
+    filter_init ( &(nrm->filter[10]), HF4000_COEFF );
+
+    /* init signal envelope estimator */
+    for(k=0; k<SUBBANDS; k++)
+        nrm->signal_e[k] = 0;
+
+    /* init noise estimator */
+    for(k=0; k<SUBBANDS; k++) {
+        nrm->noise_e  [k] = 0;
+        nrm->incrtime [k] = 0;
+    }
+
+    /* init filter bank coefficients */
+    for(k=0; k<SUBBANDS; k++)
+        nrm->alpha[k] = 0x7FFF; /* 1.0 */
+
+    return 0;
+}
+
+//------------------------------------------------------------------------------
+fract16 noise_remover (struct noise_remover_s * nrm, fract16 x, int training)
+{
+    int     k;
+    fract16 x100;
+    fract16 vy[SUBBANDS];
+    fract16 ey[SUBBANDS];
+    fract32 a;
+    fract16 a16;
+    fract32 y;
+
+    if(!nrm)
+        return 0;
+
+    if(!training)
+        return x;
+
+    /* Remove DC (High pass filter 100 Hz) */
+    #if 0
+    x100 = filter_hf100( nrm, x );
+    #else
+    x100 = x;
+    #endif
+
+    /* filter bank */
+    for(k=0; k<SUBBANDS; k++)
+        vy[k] = filter( &(nrm->filter[k]), x100 );
+
+    /* energies */
+    for(k=0; k<SUBBANDS; k++)
+        ey[k] = ABS16( vy[k] );
+
+    /* estimate signal envelope */
+    for(k=0; k<SUBBANDS; k++) {
+        //MATLAB code:
+        // TR = 0.8;    //Raise up factor
+        // TF = 0.995;  //Fall down factor
+        // for k=1:SUBBANDS
+        //     if ey(k) > signal_e(k)
+        //         signal_e(k) = ey(k) - (ey(k) - signal_e(k)) * TR;
+        //     else
+        //         signal_e(k) = signal_e(k) * TF;
+        //     end
+        // end
+        F16LO = 0x0000;
+        F16HI = ey[k];
+        if(F32 > nrm->signal_e[k]) {
+            nrm->signal_e[k] = SUB32 ( F32 , nrm->signal_e[k] );
+            nrm->signal_e[k] = MULT32( TR  , nrm->signal_e[k] );
+            nrm->signal_e[k] = SUB32 ( F32 , nrm->signal_e[k] );
+        }
+        else {
+            nrm->signal_e[k] = MULT32( TF  , nrm->signal_e[k] );
+        }
+    }
+
+    /* estimate noise energy */
+    for(k=0; k<SUBBANDS; k++) {
+        //MATLAB code:
+        // INCRTIME1 = 16000;
+        // INCRTIME2 = 32000;
+        // INCR1 = 0.0000001;
+        // INCR2 = 0.0000005;
+        // INCR3 = 0.0000025;
+        // for k=1:SUBBANDS
+        //     if signal_e(k) < noise_e(k)
+        //         incrtime(k) = 0;
+        //         noise_e(k) = signal_e(k);
+        //     else
+        //         if incrtime(k) < INCRTIME1
+        //             incrtime(k) = incrtime(k) + 1;
+        //             noise_e(k) = noise_e(k) + INCR1;
+        //         elseif incrtime(k) < INCRTIME2
+        //             incrtime(k) = incrtime(k) + 1;
+        //             noise_e(k) = noise_e(k) + INCR2;
+        //         else
+        //             noise_e(k) = noise_e(k) + INCR3;
+        //         end
+        //     end
+        // end
+        if(nrm->signal_e[k] < nrm->noise_e[k]) {
+            nrm->incrtime[k] = 0;
+            nrm->noise_e[k] = nrm->signal_e[k];
+        }
+        else {
+            if(nrm->incrtime[k] < INCRTIME1) {
+                nrm->incrtime[k] ++;
+                nrm->noise_e[k] = ADD32( nrm->noise_e[k] , INCR1 );
+            }
+            else if(nrm->incrtime[k] < INCRTIME2) {
+                nrm->incrtime[k] ++;
+                nrm->noise_e[k] = ADD32( nrm->noise_e[k] , INCR2 );
+            }
+            else {
+                nrm->noise_e[k] = ADD32( nrm->noise_e[k] , INCR3 );
+            }
+        }
+    }
+
+    /* calculate alpha-s */
+
+    //MATLAB code:
+    // SENS = 1.5;
+    // EMIN = 0.00001*ATT;
+    // MINALPHA = 0.1;
+    // MAXALPHA = 1.0;
+    // a = max(0,signal_e - SENS*noise_e) ./ (signal_e + EMIN);
+    //
+    // ATR = 0.9;
+    // ATF = 0.999;
+    // for k=1:SUBBANDS
+    //     if a(k) > alpha(k)
+    //         alpha(k) = a(k) - (a(k) - alpha(k)) * ATR;
+    //     else
+    //         alpha(k) = alpha(k) * ATF;
+    //     end
+    // end
+    // alpha = max(alpha,0.1);
+    // alpha = min(alpha,1.00);
+
+    for(k=0; k<SUBBANDS; k++) {
+
+        //for SENS <= 1.0 :
+        // a = MULT32 ( nrm->noise_e[k]  , SENS );
+        // a = SUB32  ( nrm->signal_e[k] , a    );
+        // a = MAX32  ( 0                , a    );
+
+        //for 2.0 >= SENS > 1.0 :
+        // max(0,signal_e - SENS*noise_e) --->
+        // max(0,signal_e - SENS1*noise_e - SENS2*noise_e), where SENS1+SENS2=SENS
+        a   = MULT32 ( nrm->noise_e[k]  , SENS1 );
+        a   = SUB32  ( nrm->signal_e[k] , a     );
+        F32 = MAX32  ( 0                , a     );
+
+        a   = MULT32 ( nrm->noise_e[k]  , SENS2 );
+        a   = SUB32  ( F32              , a     );
+        a   = MAX32  ( 0                , a     );
+
+        F32 = ADD32  ( nrm->signal_e[k] , EMIN );
+        a16 = DIV3216( a , F16HI );
+
+        if(a16 > nrm->alpha[k]) {
+            nrm->alpha[k] = SUB16 ( a16 , nrm->alpha[k] );
+            nrm->alpha[k] = MULT16( ATR , nrm->alpha[k] );
+            nrm->alpha[k] = SUB16 ( a16 , nrm->alpha[k] );
+        }
+        else {
+            nrm->alpha[k] = MULT16( ATF , nrm->alpha[k] );
+        }
+
+        if(nrm->alpha[k] < MINALPHA)
+            nrm->alpha[k] = MINALPHA;
+
+        if(nrm->alpha[k] > MAXALPHA)
+            nrm->alpha[k] = MAXALPHA;
+
+        //test: alpha[k] = 1.0
+        //nrm->alpha[k] = 0x7FFF;
+    }
+
+    /* calculate de-noised signal */
+    y = 0;
+    for(k=0; k<SUBBANDS; k++) {
+        y = y + (fract32)( MULT16( nrm->alpha[k], vy[k] ) );
+    }
+
+    if(y > 32767)
+        return  32767;
+    if(y <-32767)
+        return -32767;
+    return (fract16)(y);
+}
+
diff -Nura v4l2rtspserver_imp_tools/filter/noise_remover.h v4l2rtspserver-master/filter/noise_remover.h
--- v4l2rtspserver_imp_tools/filter/noise_remover.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/noise_remover.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,49 @@
+/******************************************************************************/
+/* NOISE REMOVER                                                              */
+/* noise_remover.h                                                            */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#ifndef NOISE_REMOVER_H
+#define NOISE_REMOVER_H
+
+#include  "my_fract.h"
+
+/******************************************************************************/
+/* DEFINITIONS                                                                */
+/******************************************************************************/
+
+#define SUBBANDS    11
+#define FILTER_LEN  25
+
+struct fir_s {
+    const fract16 * coeff;
+    fract16   delay[2*FILTER_LEN]; /* see OSLEC optimization of FIR filters */
+    int       pos;
+};
+
+struct energy_s {
+    int     counter;
+    fract32 sum;
+    fract16 out;
+};
+
+struct noise_remover_s {
+    fract32          hf100_xdelay;
+    fract32          hf100_ydelay;
+    struct fir_s     filter   [SUBBANDS];
+    struct energy_s  energy   [SUBBANDS];
+    fract32          signal_e [SUBBANDS];
+    fract32          noise_e  [SUBBANDS];
+    int              incrtime [SUBBANDS];
+    fract16          alpha    [SUBBANDS];
+};
+
+/******************************************************************************/
+/* FUNCTIONS                                                                  */
+/******************************************************************************/
+
+int      noise_remover_init ( struct noise_remover_s * nrm );
+fract16  noise_remover      ( struct noise_remover_s * nrm, fract16 x, int training );
+
+#endif /* NOISE_REMOVER_H */
diff -Nura v4l2rtspserver_imp_tools/filter/README.md v4l2rtspserver-master/filter/README.md
--- v4l2rtspserver_imp_tools/filter/README.md	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/README.md	2019-02-03 20:24:23.640172000 +0100
@@ -0,0 +1,15 @@
+# free-nross
+Free noise reduction of speech signals
+
+This library provides ability of noise reduction of speech signals.
+It has been implemented to suppress noise in one way speech signal
+system (i.e. system without reference source of noise signal). It 
+may be usefull for telephony terminals, that work in noisy
+environment and have single microphone.
+
+Note: this noise suppressor has been created to work well only for
+speech signals.
+
+free-nross includes C and MATLAB/Octave/FreeMat code sources.
+
+(c) Sergei Mashkin, 2015
diff -Nura v4l2rtspserver_imp_tools/filter/types.h v4l2rtspserver-master/filter/types.h
--- v4l2rtspserver_imp_tools/filter/types.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/types.h	2019-02-03 20:24:23.641172000 +0100
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *   STANDARD TYPES DEFINITIONS                                            *
+ *                                                                         *
+ *   (c) 2015, Mashkin Sergey                                              *
+ ***************************************************************************/
+
+#ifndef TYPES_H
+#define TYPES_H
+
+
+#ifndef uint64_t
+typedef unsigned long long int  uint64_t;
+#endif
+ 
+#ifndef uint32_t
+typedef unsigned int            uint32_t;
+#endif
+
+#ifndef uint16_t
+typedef unsigned short          uint16_t;
+#endif
+
+#ifndef uint8_t
+typedef unsigned char           uint8_t;
+#endif
+
+#ifndef int64_t
+typedef signed long long int    int64_t;
+#endif
+ 
+#ifndef int32_t
+typedef signed int              int32_t;
+#endif
+
+#ifndef int16_t
+typedef signed short            int16_t;
+#endif
+
+#ifndef int8_t
+typedef signed char             int8_t;
+#endif
+
+
+#endif //TYPES_H
diff -Nura v4l2rtspserver_imp_tools/filter/wave.c v4l2rtspserver-master/filter/wave.c
--- v4l2rtspserver_imp_tools/filter/wave.c	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/wave.c	2019-02-03 20:24:23.642172000 +0100
@@ -0,0 +1,1454 @@
+/******************************************************************************/
+/* WAVE-FILES UTILITES                                                        */
+/* wave.c                                                                     */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#include "wave.h"
+
+#define MYLOGDEVICE 0 //0=MYLOGDEVICE_NOLOGS
+#include "mylog.h"
+
+#include <string.h>
+#include "g711super.h"
+#include "gsm.h"      //GSM0610    (13 kbit/s)
+
+//types of audio coding type (look for standards)
+#define  WAV_PCM      0x0001  //PCM uncompressed
+#define  WAV_PCMU     0x0007  //ITU G.711 u-law
+#define  WAV_PCMA     0x0006  //ITU G.711 a-law
+#define  WAV_GSM610   0x0031  //GSM 6.10
+#define  WAV_ADPCM    0x0002  //Microsoft ADPCM
+
+/*************************************************************/
+/* WAVE-HEADER FUNCTIONS                                     */
+/*************************************************************/
+
+//------------------------------------------------------------
+//Create waveheader structure
+waveheader_t * waveheader_create ( void )
+{
+        MYLOG_TRACE("@ ()");
+        waveheader_t * header;
+        header = (waveheader_t *) malloc( sizeof(waveheader_t) );
+        if(header == NULL) {
+                MYLOG_ERROR("Could not allocate memory for waveheader_t");
+                return NULL;
+        }
+        //set default values
+        (void) waveheader_set_default( header, WAVETYPE_DEFAULT );
+        return(header);
+}
+
+//------------------------------------------------------------
+//Destroy waveheader structure
+void waveheader_destroy ( waveheader_t * header )
+{
+        if(header) {
+                free( header );
+        }
+        return;
+}
+
+//------------------------------------------------------------
+//Set default values to waveheader
+//inputs:  header   = pointer to wav-header structure
+//         wavetype = type of wave-file: WAVTYPE_MONO_8000HZ_PCM16 etc...
+//returns:  0 = ok
+//         -1 = error
+int waveheader_set_default( waveheader_t * header, uint8_t wavetype )
+{
+        int i;
+
+        MYLOG_TRACE("@ (header=%p,wavetype=%u)",header,wavetype);
+
+        if(header==NULL) {
+                MYLOG_ERROR("Invalid input parameter: header=NULL");
+                return(-1);
+        }
+
+        header->riff[0] = 'R';
+        header->riff[1] = 'I';
+        header->riff[2] = 'F';
+        header->riff[3] = 'F';
+        header->wave[0] = 'W';
+        header->wave[1] = 'A';
+        header->wave[2] = 'V';
+        header->wave[3] = 'E';
+        header->fmt[0]  = 'f';
+        header->fmt[1]  = 'm';
+        header->fmt[2]  = 't';
+        header->fmt[3]  = ' ';
+        for(i=0; i<sizeof(header->extra_format_data); i++) { header->extra_format_data[i] = 0; }
+        header->fact[0] = 'f';
+        header->fact[1] = 'a';
+        header->fact[2] = 'c';
+        header->fact[3] = 't';
+        for(i=0; i<sizeof(header->fact_data); i++) { header->fact_data[i] = 0; }
+        header->data[0] = 'd';
+        header->data[1] = 'a';
+        header->data[2] = 't';
+        header->data[3] = 'a';
+
+        switch(wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+                header->file_length        = 0;        //! (file_length-8) - must be calculated when close file
+                header->fmt_length         = 16;
+                header->type               = WAV_PCM;
+                header->channels           = 1;
+                header->samples_per_second = 8000;
+                header->bytes_per_second   = 16000;
+                header->block_align        = 2;
+                header->bits_per_sample    = 16;
+                header->extra_format_bytes = 0;
+                header->fact_length        = 0;        //! do not use 'fact' chunk for uncompressed data
+                header->fact_data[0]       = 0;        //! samples - must be calculated when close file
+                header->fact_data[1]       = 0;        //!
+                header->fact_data[2]       = 0;        //!
+                header->fact_data[3]       = 0;        //!
+                header->data_length        = 0;        //! (length of data) - must be calculated when close file
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMA:
+                header->file_length        = 0;        //! (file_length-8) - must be calculated when close file
+                header->fmt_length         = 18;
+                header->type               = WAV_PCMA;
+                header->channels           = 1;
+                header->samples_per_second = 8000;
+                header->bytes_per_second   = 8000;
+                header->block_align        = 1;
+                header->bits_per_sample    = 8;
+                header->extra_format_bytes = 0;
+                header->fact_length        = 4;
+                header->fact_data[0]       = 0;        //! samples - must be calculated when close file
+                header->fact_data[1]       = 0;        //!
+                header->fact_data[2]       = 0;        //!
+                header->fact_data[3]       = 0;        //!
+                header->data_length        = 0;        //! (length of data) - must be calculated when close file
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                header->file_length        = 0;        //! (file_length-8) - must be calculated when close file
+                header->fmt_length         = 18;
+                header->type               = WAV_PCMU;
+                header->channels           = 1;
+                header->samples_per_second = 8000;
+                header->bytes_per_second   = 8000;
+                header->block_align        = 1;
+                header->bits_per_sample    = 8;
+                header->extra_format_bytes = 0;
+                header->fact_length        = 4;
+                header->fact_data[0]       = 0;        //! samples - must be calculated when close file
+                header->fact_data[1]       = 0;        //!
+                header->fact_data[2]       = 0;        //!
+                header->fact_data[3]       = 0;        //!
+                header->data_length        = 0;        //! (length of data) - must be calculated when close file
+                return(0);
+
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                header->file_length        = 0;        //! (file_length-8) - must be calculated when close file
+                header->fmt_length         = 20;
+                header->type               = WAV_GSM610;
+                header->channels           = 1;
+                header->samples_per_second = 8000;
+                header->bytes_per_second   = 1625;
+                header->block_align        = 65;
+                header->bits_per_sample    = 0;
+                header->extra_format_bytes = 2;
+                header->extra_format_data[0] = 320        & 0xFF; //320 samples per block
+                header->extra_format_data[1] = (320 >> 8) & 0xFF;
+                header->fact_length        = 4;
+                header->fact_data[0]       = 0;        //! samples - must be calculated when close file
+                header->fact_data[1]       = 0;        //!
+                header->fact_data[2]       = 0;        //!
+                header->fact_data[3]       = 0;        //!
+                header->data_length        = 0;        //! (length of data) - must be calculated when close file
+                return(0);
+#endif // SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Invalid input parameter: wavtype=%d", wavetype);
+                return(-1);
+        }
+        return(0);
+}
+
+//------------------------------------------------------------
+//Write header to opened wav-file
+//inputs:  fid    = file id
+//         header = pointer to wav-header structure
+//returns:  0 = ok
+//         -1 = error
+int waveheader_write( FILE * fp, waveheader_t * header )
+{
+        int err;
+
+        MYLOG_TRACE("@ (fp=%p,header=%p)",fp,header);
+
+        //check input parameters
+        if(fp==NULL) {
+                MYLOG_ERROR("File is not opened!");
+                return(-1);
+        }
+        if(header==NULL) {
+                MYLOG_ERROR("Invalid input parameter: header=NULL");
+                return(-1);
+        }
+        //Go to the begining of file
+        err = fseek(fp,0L,SEEK_SET);
+        if(err) {
+                MYLOG_ERROR("Could not go to the begining of file!");
+                return(-1);
+        }
+        //write header to file element by element:
+        if( 1 != fwrite( &(header->riff[0]), sizeof(header->riff), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->file_length), sizeof(header->file_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->wave[0]), sizeof(header->wave), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->fmt[0]), sizeof(header->fmt), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->fmt_length), sizeof(header->fmt_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->type), sizeof(header->type), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->channels), sizeof(header->channels), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->samples_per_second), sizeof(header->samples_per_second), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->bytes_per_second), sizeof(header->bytes_per_second), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->block_align), sizeof(header->block_align), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->bits_per_sample), sizeof(header->bits_per_sample), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( header->extra_format_bytes > 0 ) {
+                if( 1 != fwrite( &(header->extra_format_bytes), sizeof(header->extra_format_bytes), 1, fp ) ) {
+                        MYLOG_ERROR("Could not write data to file");
+                        return(-1);
+                }
+                if( 1 != fwrite( &(header->extra_format_data[0]), header->extra_format_bytes, 1, fp ) ) {
+                        MYLOG_ERROR("Could not write data to file");
+                        return(-1);
+                }
+        }
+        if( header->fact_length > 0 ) {
+                if( 1 != fwrite( &(header->fact[0]), sizeof(header->fact), 1, fp ) ) {
+                        MYLOG_ERROR("Could not write data to file");
+                        return(-1);
+                }
+                if( 1 != fwrite( &(header->fact_length), sizeof(header->fact_length), 1, fp ) ) {
+                        MYLOG_ERROR("Could not write data to file");
+                        return(-1);
+                }
+                if( header->fact_length > 0 ) {
+                        if( 1 != fwrite( &(header->fact_data[0]), header->fact_length, 1, fp ) ) {
+                                MYLOG_ERROR("Could not write data to file");
+                                return(-1);
+                        }
+                }
+        }
+        if( 1 != fwrite( &(header->data[0]), sizeof(header->data), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        if( 1 != fwrite( &(header->data_length), sizeof(header->data_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not write data to file");
+                return(-1);
+        }
+        return(0);
+}
+
+//------------------------------------------------------------
+//Read header of opened wav-file
+//inputs:  fp    = file id
+//         header = pointer to wav-header structure
+//returns:  0 = ok
+//         -1 = error
+int waveheader_read( FILE * fp, waveheader_t * header )
+{
+        int err;
+        int i;
+
+        MYLOG_TRACE("@ (fp=%p,header=%p)",fp,header);
+
+        //check input parameters
+        if(fp==NULL) {
+                MYLOG_ERROR("File is not opened!");
+                return(-1);
+        }
+        if(header==NULL) {
+                MYLOG_ERROR("Invalid input parameter: header=NULL");
+                return(-1);
+        }
+        //Go to the begining of file
+        err = fseek(fp,0L,SEEK_SET);
+        if(err) {
+                MYLOG_ERROR("Could not go to the begining of file!");
+                return(-1);
+        }
+        //read header from file element by element:
+        //RIFF
+        if( 1 != fread( &(header->riff[0]), sizeof(header->riff), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( header->riff[0]!='R' ||
+            header->riff[1]!='I' ||
+            header->riff[2]!='F' ||
+            header->riff[3]!='F'   ) {
+                MYLOG_ERROR("Invalid format: no RIFF");
+                return(-1);
+        }
+        if( 1 != fread( &(header->file_length), sizeof(header->file_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        //WAVE
+        if( 1 != fread( &(header->wave[0]), sizeof(header->wave), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( header->wave[0]!='W' ||
+            header->wave[1]!='A' ||
+            header->wave[2]!='V' ||
+            header->wave[3]!='E'   ) {
+                MYLOG_ERROR("Invalid format: no WAVE");
+                return(-1);
+        }
+        //fmt
+        if( 1 != fread( &(header->fmt[0]), sizeof(header->fmt), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( header->fmt[0]!='f' ||
+            header->fmt[1]!='m' ||
+            header->fmt[2]!='t' ||
+            header->fmt[3]!=' '   ) {
+                MYLOG_ERROR("Invalid format: no fmt");
+                return(-1);
+        }
+        if( 1 != fread( &(header->fmt_length), sizeof(header->fmt_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( header->fmt_length < 16 ) {
+                MYLOG_ERROR("Invalid format: bad fmt_length=%d", header->fmt_length);
+                return(-1);
+        }
+        if( 1 != fread( &(header->type), sizeof(header->type), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( 1 != fread( &(header->channels), sizeof(header->channels), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( 1 != fread( &(header->samples_per_second), sizeof(header->samples_per_second), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( 1 != fread( &(header->bytes_per_second), sizeof(header->bytes_per_second), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( 1 != fread( &(header->block_align), sizeof(header->block_align), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( 1 != fread( &(header->bits_per_sample), sizeof(header->bits_per_sample), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( header->fmt_length >= 18 ) {
+                if( 1 != fread( &(header->extra_format_bytes), sizeof(header->extra_format_bytes), 1, fp ) ) {
+                        MYLOG_ERROR("Could not read data from file");
+                        return(-1);
+                }
+                if( header->extra_format_bytes > sizeof(header->extra_format_data) ) {
+                        MYLOG_ERROR("Invalid format: bad extra_format_bytes=%d", header->extra_format_bytes);
+                        return(-1);
+                }
+                if(header->extra_format_bytes > 0) {
+                        if( 1 != fread( &(header->extra_format_data[0]), header->extra_format_bytes, 1, fp ) ) {
+                                MYLOG_ERROR("Could not read data from file");
+                                return(-1);
+                        }
+                }
+        }
+        //fact
+        if( 1 != fread( &(header->fact[0]), sizeof(header->fact), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+        if( (header->fact[0]=='f') &&
+            (header->fact[1]=='a') &&
+            (header->fact[2]=='c') &&
+            (header->fact[3]=='t')   )
+        {
+                //if(header->type != WAV_PCM) {
+                //        MYLOG_ERROR("Invalid file format: for compressed data 'fact' must exist!");
+                //        return(-1);
+                //}
+                if( 1 != fread( &(header->fact_length), sizeof(header->fact_length), 1, fp ) ) {
+                        MYLOG_ERROR("Could not read data from file");
+                        return(-1);
+                }
+                if(header->fact_length!=4) {
+                        MYLOG_ERROR("Invalid format: fact_length=%d (must be 4)!", header->fact_length);
+                        return(-1);
+                }
+                if( 1 != fread( &(header->fact_data[0]), header->fact_length, 1, fp ) ) {
+                        MYLOG_ERROR("Could not read data from file");
+                        return(-1);
+                }
+                //data
+                if( 1 != fread( &(header->data[0]), sizeof(header->data), 1, fp ) ) {
+                        MYLOG_ERROR("Could not read data from file");
+                        return(-1);
+                }
+        }
+        else if( (header->fact[0]=='d') &&
+                 (header->fact[1]=='a') &&
+                 (header->fact[2]=='t') &&
+                 (header->fact[3]=='a')   )
+        {
+                //data
+                header->data[0]='d';
+                header->data[1]='a';
+                header->data[2]='t';
+                header->data[3]='a';
+                //fill 'fact' with default values
+                header->fact[0] = 'f';
+                header->fact[1] = 'a';
+                header->fact[2] = 'c';
+                header->fact[3] = 't';
+                header->fact_length = 0;
+                for(i=0; i<sizeof(header->fact_data); i++) { header->fact_data[i] = 0; }
+        }
+        //data
+        if( 1 != fread( &(header->data_length), sizeof(header->data_length), 1, fp ) ) {
+                MYLOG_ERROR("Could not read data from file");
+                return(-1);
+        }
+
+        //check type and parameters are supported
+        if( header->type==WAV_PCM ) {
+                if(header->fmt_length<16) {
+                        MYLOG_ERROR("Invalid format: invalid fmt_length=%d for PCM format", header->fmt_length);
+                        return(-1);
+                }
+        }
+        else if( header->type==WAV_PCMA ) {
+                if(header->fmt_length<16) {
+                        MYLOG_ERROR("Invalid format: invalid fmt_length=%d for PCMA format", header->fmt_length);
+                        return(-1);
+                }
+        }
+        else if( header->type==WAV_PCMU ) {
+                if(header->fmt_length<16) {
+                        MYLOG_ERROR("Invalid format: invalid fmt_length=%d for PCMU format", header->fmt_length);
+                        return(-1);
+                }
+        }
+#ifdef SUPP_GSM
+        else if( header->type==WAV_GSM610 ) {
+                if(header->fmt_length!=20) {
+                        MYLOG_ERROR("Invalid format: invalid fmt_length=%d for GSM610 format", header->fmt_length);
+                        return(-1);
+                }
+        }
+#endif // SUPP_GSM
+        else {
+                MYLOG_ERROR("Unsupported type of wave: %d", header->type);
+                return(-1);
+        }
+
+        MYLOG_TRACE(".header->fact_length = %u",header->fact_length);
+        MYLOG_TRACE(".header->fact_data   = %02X %02X %02X %02X",header->fact_data[0],header->fact_data[1],header->fact_data[2],header->fact_data[3]);
+
+        return(0);
+}
+
+//------------------------------------------------------------
+//Get default size of waveheader
+//inputs:   wavetype = type of wave-file: WAVTYPE_MONO_8000HZ_PCM16 etc...
+//returns:  bytes    = size of waveheader
+//         -1 = error
+int waveheader_get_default_size(uint8_t wavetype)
+{
+        switch(wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:   return(44);
+        case WAVETYPE_MONO_8000HZ_PCMA:    return(58);
+        case WAVETYPE_MONO_8000HZ_PCMU:    return(58);
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:  return(60);
+#endif //SUPP_GSM
+        default:                           return(-1);
+        }
+}
+
+/*************************************************************/
+/* WAVE-FILE FUNCTIONS                                       */
+/*************************************************************/
+
+//------------------------------------------------------------
+//Create wavefile_t structure
+//returns: wavefile = pointer to created wavefile
+//         NULL     = error
+wavefile_t * wavefile_create ( void )
+{
+        wavefile_t * wavefile;
+
+        MYLOG_TRACE("@ ()");
+
+        //allocate memory
+        wavefile = (wavefile_t *) malloc( sizeof(wavefile_t) );
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Could not allocate memory for wavefile");
+                return NULL;
+        }
+
+        //initialize variables
+        wavefile->wavetype        = WAVETYPE_NOTSET;
+        wavefile->filename[0]     = '\0';
+        wavefile->rwmode          = WAVEFILE_RWMODE_NOTSET;
+
+        wavefile->fp              = NULL;
+        wavefile->pos             = 0;
+        wavefile->end_samples     = 0;
+        wavefile->end_bytes       = 0;
+        wavefile->total_samples   = 0;
+        wavefile->total_bytes     = 0;
+
+        wavefile->header          = NULL;
+        wavefile->vocoder         = NULL;
+
+        wavefile->data8_bytes     = 0;
+        wavefile->voice16_samples = 0;
+
+        return wavefile;
+}
+
+//------------------------------------------------------------
+//Destroy wavefile structure
+void wavefile_destroy ( wavefile_t * wavefile )
+{
+        MYLOG_TRACE("@ (wavefile=%p)",wavefile);
+
+        if(wavefile == NULL) {
+                return; //nothing to destroy
+        }
+        //close wavefile
+        if(wavefile->fp) {
+                wavefile_close( wavefile );
+        }
+        //destroy wavefile
+        if(wavefile->header) {
+                free(wavefile->header);
+        }
+        free(wavefile);
+        return;
+}
+
+//------------------------------------------------------------
+int wavefile_close ( wavefile_t * wavefile )
+{
+        int fid;
+        int err;
+
+        MYLOG_TRACE("@ (wavefile=%p)",wavefile);
+
+        //Check input parameters
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        //Check if wavefile is already closed
+        if(wavefile->fp==NULL) {
+                MYLOG_WARNING("Wavefile is already closed");
+                return(0);
+        }
+
+        //1.Destroy vocoder
+        if(wavefile->vocoder) {
+#ifdef SUPP_GSM
+                if( wavefile->wavetype==WAVETYPE_MONO_8000HZ_GSM610 )
+                        gsm_destroy(wavefile->vocoder);
+                else
+#endif //SUPP_GSM
+                        free(wavefile->vocoder);
+                wavefile->vocoder = NULL;
+        }
+
+        //2.Close file
+        switch(wavefile->rwmode)
+        {
+        case WAVEFILE_RWMODE_READ:
+                //Close file
+                fclose(wavefile->fp);
+                wavefile->fp = NULL;
+                return(0);
+
+        case WAVEFILE_RWMODE_WRITE:
+                //Finalize file
+                if( wavefile->end_samples != 0 ) {
+                        //leave only end_samples in file (truncate silence samples)
+                        wavefile->total_samples = wavefile->end_samples;
+                        wavefile->total_bytes   = wavefile->end_bytes;
+                }
+
+                MYLOG_TRACE("!wavefile->end_samples   = %u",wavefile->end_samples  );
+                MYLOG_TRACE("!wavefile->end_bytes     = %u",wavefile->end_bytes    );
+                MYLOG_TRACE("!wavefile->total_samples = %u",wavefile->total_samples);
+                MYLOG_TRACE("!wavefile->total_bytes   = %u",wavefile->total_bytes  );
+
+                //Fill waveheader
+                wavefile->header->file_length = waveheader_get_default_size(wavefile->wavetype) + wavefile->total_bytes - 8;
+                if(wavefile->header->fact_length >= 4) {
+                        wavefile->header->fact_data[0] = (uint8_t)((wavefile->total_samples >> 0 ) & 0x000000FFL);
+                        wavefile->header->fact_data[1] = (uint8_t)((wavefile->total_samples >> 8 ) & 0x000000FFL);
+                        wavefile->header->fact_data[2] = (uint8_t)((wavefile->total_samples >> 16) & 0x000000FFL);
+                        wavefile->header->fact_data[3] = (uint8_t)((wavefile->total_samples >> 24) & 0x000000FFL);
+                }
+                wavefile->header->data_length = wavefile->total_bytes;
+
+                //(re)Write waveheader
+                waveheader_write( wavefile->fp, wavefile->header );
+
+                //Truncate wavefile
+                fid = fileno(wavefile->fp);
+                if(fid==-1) {
+                        fclose(wavefile->fp);
+                        wavefile->fp = NULL;
+                        MYLOG_ERROR("Could not get fid! Wavefile closed!");
+                        return(-1);
+                }
+                err = ftruncate(fid, wavefile->header->file_length + 8);
+                if(err) {
+                        MYLOG_WARNING("Could not trancate wavefile: %d: %s",errno,strerror(errno));
+                }
+                //Close file
+                fclose(wavefile->fp);
+                wavefile->fp = NULL;
+                return(0);
+
+        default:
+                MYLOG_ERROR("Unexpected rwmode: %d",wavefile->rwmode);
+                //close file
+                fclose(wavefile->fp);
+                wavefile->fp = NULL;
+                return(-1);
+        }
+}
+
+//------------------------------------------------------------
+int wavefile_write_open ( wavefile_t * wavefile, char * filename, uint8_t wavetype )
+{
+        int err;
+
+        MYLOG_TRACE("@ (wavefile=%p,filename=%s,wavetype=%u",wavefile,filename,wavetype);
+
+        //Check input arguments
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(filename == NULL) {
+                MYLOG_ERROR("Invalid value: filename=NULL");
+                return(-1);
+        }
+        //Check if wavefile is already in process
+        if(wavefile->fp) {
+                MYLOG_ERROR("wavefile is already used (filename=%s)! Close it before!",wavefile->filename);
+                return(-1);
+        }
+        //Set wave-file structure
+        snprintf( wavefile->filename, sizeof(wavefile->filename), filename );
+        wavefile->wavetype        = wavetype;
+        wavefile->end_samples     = 0;
+        wavefile->end_bytes       = 0;
+        wavefile->total_samples   = 0;
+        wavefile->total_bytes     = 0;
+        wavefile->rwmode          = WAVEFILE_RWMODE_WRITE;
+        wavefile->data8_bytes     = 0;
+        wavefile->voice16_samples = 0;
+
+        //Create/init vocoder if it is needed
+        init_g711();
+        switch(wavefile->wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+        case WAVETYPE_MONO_8000HZ_PCMA:
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                //do nothing
+                break;
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                //create vocoder
+                if(wavefile->vocoder==NULL) {
+                        wavefile->vocoder = gsm_create();
+                        if(wavefile->vocoder==NULL) {
+                                MYLOG_ERROR("Could not create GSM0610 vocoder!");
+                                fclose(wavefile->fp);
+                                wavefile->fp = NULL;
+                                return(-1);
+                        }
+                }
+                //init vocoder
+                gsm_init(wavefile->vocoder);
+                //set WAV49 option
+                {
+                        int one;
+                        one = 1;
+                        gsm_option(wavefile->vocoder, GSM_OPT_WAV49, &one);
+                }
+                break;
+#endif //SUPP_GSM
+        default:
+                MYLOG_ERROR("Invalid value: wavetype=%u",wavetype);
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        //Set header
+        wavefile->header = waveheader_create();
+        if(wavefile->header == NULL) {
+                MYLOG_ERROR("Could not allocate memory for wavefile->header");
+                wavefile_close(wavefile);
+                return(-1);
+        }
+        err = waveheader_set_default( wavefile->header, wavefile->wavetype );
+        if(err) {
+                MYLOG_ERROR("Function waveheader_set_default failed!");
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        //Try to open file
+        wavefile->fp = fopen(filename,"w");
+        if(wavefile->fp==NULL) {
+                MYLOG_ERROR("Could not open file (filename=%s) in write mode: %d: %s",filename,errno,strerror(errno));
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        //Write header
+        err = waveheader_write( wavefile->fp, wavefile->header );
+        if(err) {
+                MYLOG_ERROR("Could not write waveheader to file");
+                wavefile_close(wavefile);
+                return(-1);
+        }
+        MYLOG_TRACE("wavefile (filename=%s) was successfuly opened in write mode", wavefile->filename);
+        return(0);
+}
+
+//------------------------------------------------------------
+//Write encoded data to opened wavefile
+//inputs: wavefile = pointer to wavefile
+//        data     = pointer to data bytes
+//        bytes    = number of data bytes
+//        samples  = number of samples
+//        wavetype = type of encoded data
+//returns: 0 = ok
+//        -1 = error
+int wavefile_write_data ( wavefile_t * wavefile, uint8_t * data, int bytes, int samples, uint8_t wavetype )
+{
+        int n;
+
+        MYLOG_TRACE("@ (wavefile=%p,data=%p,bytes=%d,samples=%d,wavetype=%u)",wavefile,data,bytes,samples,wavetype);
+
+        //Check input parameters
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(wavefile->fp == NULL) {
+                MYLOG_ERROR("Wavefile is not opened!");
+                return(-1);
+        }
+        if(wavefile->rwmode != WAVEFILE_RWMODE_WRITE) {
+                MYLOG_ERROR("Wavefile is not opened in write mode!");
+                return(-1);
+        }
+        if(data==NULL) {
+                MYLOG_ERROR("Invalid value: data=NULL");
+                return(-1);
+        }
+        if(bytes<0) {
+                MYLOG_ERROR("Invalid value: bytes=%d",bytes);
+                return(-1);
+        }
+        if(samples<0) {
+                MYLOG_ERROR("Invalid value: samples=%d",samples);
+                return(-1);
+        }
+        if(wavetype != wavefile->wavetype) {
+                MYLOG_ERROR("Invalid wavetype of data to be written: wavefile->wavetype=%d, data->wavetype=%d",
+                            wavefile->wavetype, wavetype);
+                return(-1);
+        }
+        if(samples==0) {
+                //write nothing
+                return(0);
+        }
+
+        //Write data to file (without conversion)
+        switch(wavefile->wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+                if( samples<<1 != bytes ) {
+                        MYLOG_ERROR("Invalid value: PCM16 samples=%d,bytes=%d",samples,bytes);
+                        return(-1);
+                }
+                break;
+
+        case WAVETYPE_MONO_8000HZ_PCMA:
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                if( samples != bytes ) {
+                        MYLOG_ERROR("Invalid value: PCMU/PCMA samples=%d,bytes=%d",samples,bytes);
+                        return(-1);
+                }
+                break;
+
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                if( samples*65 != bytes*320 ) {
+                        MYLOG_ERROR("Invalid value: GSM610 samples=%d,bytes=%d",samples,bytes);
+                        return(-1);
+                }
+                break;
+#endif //SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Unsupported wavefile->wavetype=%d",wavefile->wavetype);
+                return(-1);
+        }
+
+        //Write data to file (without conversion)
+        n = fwrite( data, sizeof(uint8_t), bytes, wavefile->fp );
+        if(n != bytes) {
+                MYLOG_ERROR( "Could not write bytes! %d bytes of %d have been written: %d:%s",
+                             n,bytes,errno,strerror(errno) );
+                return(-1);
+        }
+        wavefile->total_samples += samples;
+        wavefile->total_bytes   += bytes;
+        return(0);
+}
+
+//------------------------------------------------------------
+//Write samples to opened wavefile
+//inputs: wavefile = pointer to wavefile
+//        voice    = pointer to buffer with samples
+//        samples  = number of samples
+//returns: 0 = ok
+//        -1 = error
+int wavefile_write_voice ( wavefile_t * wavefile, int16_t * voice, int samples )
+{
+        int       i;
+        int       n;
+
+        //Check input parameters
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(wavefile->fp == NULL) {
+                MYLOG_ERROR("Wavefile is not opened!");
+                return(-1);
+        }
+        if(wavefile->rwmode != WAVEFILE_RWMODE_WRITE) {
+                MYLOG_ERROR("Wavefile is not opened in write mode!");
+                return(-1);
+        }
+        if(voice==NULL) {
+                MYLOG_ERROR("Invalid value: voice=NULL");
+                return(-1);
+        }
+        if(samples<0) {
+                MYLOG_ERROR("Invalid value: samples=%d",samples);
+                return(-1);
+        }
+        if(samples==0) {
+                //write nothing
+                return(0);
+        }
+
+        //convert data and write to file
+        switch(wavefile->wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+                n = fwrite( voice, sizeof(int16_t), samples, wavefile->fp );
+                if(n != samples) {
+                        MYLOG_ERROR( "Could not write PCM16 samples! %d samples of %d have been written: %d:%s",
+                                     n,samples,errno,strerror(errno) );
+                        return(-1);
+                }
+                wavefile->total_samples += samples;
+                wavefile->total_bytes   += (samples << 1);
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMA:
+                for(i=0; i<samples; i++) {
+                        wavefile->data8[0] = linear2alaw( voice[i] );
+                        n = fwrite( wavefile->data8, sizeof(uint8_t), 1, wavefile->fp );
+                        if(n != 1) {
+                                MYLOG_ERROR( "Could not write PCMA sample: %d:%s",
+                                             errno,strerror(errno) );
+                                return(-1);
+                        }
+                }
+                wavefile->total_samples += samples;
+                wavefile->total_bytes   += samples;
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                for(i=0; i<samples; i++) {
+                        wavefile->data8[0] = linear2mulaw( voice[i] );
+                        n = fwrite( wavefile->data8, sizeof(uint8_t), 1, wavefile->fp );
+                        if(n != 1) {
+                                MYLOG_ERROR( "Could not write PCMA sample: %d:%s",
+                                             errno,strerror(errno) );
+                                return(-1);
+                        }
+                }
+                wavefile->total_samples += samples;
+                wavefile->total_bytes   += samples;
+                return(0);
+
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                if(wavefile->vocoder == NULL) {
+                        MYLOG_ERROR("wavefile->vocoder=NULL!");
+                        return(-1);
+                }
+                for(i=0; i<samples; i++) {
+                        if(wavefile->voice16_samples >= 320) {
+                                //convert block of 320 samples in voice[] to
+                                //65 compressed data bytes (MS GSM frame format) in data8[]
+                                // encode 1st frame
+                                gsm_encode( wavefile->vocoder, (gsm_signal *)(wavefile->voice16), (uint8_t *)(wavefile->data8) );
+                                // encode 2nd frame
+                                gsm_encode( wavefile->vocoder, (gsm_signal *)(wavefile->voice16+160), (uint8_t *)(wavefile->data8+32) );
+
+                                //write 65 GSM bytes from data8[] to file
+                                n = fwrite( wavefile->data8, sizeof(uint8_t), 65, wavefile->fp );
+                                if(n!=65) {
+                                        MYLOG_ERROR( "Could not write GSM610 frame: %d bytes of %d have been written: %d:%s",
+                                                    n,65,errno,strerror(errno) );
+                                }
+                                wavefile->voice16_samples -= 320;
+                                wavefile->total_bytes    += 65;
+                                wavefile->total_samples  += 320;
+                        }
+                        wavefile->voice16[wavefile->voice16_samples++] = voice[i];
+                }
+                return(0);
+#endif //SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Invalid wavetype=%d",wavefile->wavetype);
+                return(-1);
+        }
+}
+
+//------------------------------------------------------------
+int wavefile_write_set_end ( wavefile_t * wavefile )
+{
+        MYLOG_TRACE("@ (wavefile=%p)",wavefile);
+
+        //Check input parameters
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(wavefile->fp==NULL) {
+                MYLOG_ERROR("wavefile is not opened yet!");
+                return(-1);
+        }
+        //store info about last speech place
+        wavefile->end_samples = wavefile->total_samples;
+        wavefile->end_bytes   = wavefile->total_bytes;
+        return(0);
+}
+
+//------------------------------------------------------------
+int wavefile_read_open ( wavefile_t * wavefile, char * filename )
+{
+        int err;
+
+        //Check input arguments
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(filename == NULL) {
+                MYLOG_ERROR("Invalid value: filename=NULL");
+                return(-1);
+        }
+        //Check if wavefile is already in process
+        if(wavefile->fp) {
+                MYLOG_ERROR("wavefile is already used (filename=%s)! Close it before!",wavefile->filename);
+                return(-1);
+        }
+        //Try to open file
+        wavefile->fp = fopen(filename,"r");
+        if(wavefile->fp==NULL) {
+                MYLOG_ERROR("Could not open file (filename=%s) in read mode: %d: %s",filename,errno,strerror(errno));
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        //Read header
+        wavefile->header = waveheader_create();
+        if(wavefile->header == NULL) {
+                MYLOG_ERROR("Could not allocate memory for wavefile->header");
+                wavefile_close(wavefile);
+                return(-1);
+        }
+        err = waveheader_read( wavefile->fp, wavefile->header );
+        if(err) {
+                MYLOG_ERROR("Could not read waveheader from file");
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        //Set wave-file structure
+        snprintf( wavefile->filename, sizeof(wavefile->filename), filename );
+        switch(wavefile->header->type)
+        {
+        case WAV_PCM:
+                if( (wavefile->header->channels           != 1    ) ||
+                    (wavefile->header->samples_per_second != 8000 ) ||
+                    (wavefile->header->bytes_per_second   != 16000) ||
+                    (wavefile->header->block_align        != 2    ) ||
+                    (wavefile->header->bits_per_sample    != 16   ) ||
+                    (wavefile->header->extra_format_bytes != 0    )   )
+                {
+                        MYLOG_ERROR( "Unsupported type of PCM wavefile: chans=%d sps=%d bps=%d blalign=%d bits=%d exfmtbytes=%d\n",
+                                     wavefile->header->channels,
+                                     wavefile->header->samples_per_second,
+                                     wavefile->header->bytes_per_second,
+                                     wavefile->header->block_align,
+                                     wavefile->header->bits_per_sample,
+                                     wavefile->header->extra_format_bytes );
+                }
+                wavefile->wavetype = WAVETYPE_MONO_8000HZ_PCM16;
+                break;
+        case WAV_PCMU:
+                if( (wavefile->header->channels           != 1    ) ||
+                    (wavefile->header->samples_per_second != 8000 ) ||
+                    (wavefile->header->bytes_per_second   != 8000 ) ||
+                    (wavefile->header->block_align        != 1    ) ||
+                    (wavefile->header->bits_per_sample    != 8    ) ||
+                    (wavefile->header->extra_format_bytes != 0    )   )
+                {
+                        MYLOG_ERROR( "Unsupported type of PCMU wavefile: chans=%d sps=%d bps=%d blalign=%d bits=%d exfmtbytes=%d\n",
+                                     wavefile->header->channels,
+                                     wavefile->header->samples_per_second,
+                                     wavefile->header->bytes_per_second,
+                                     wavefile->header->block_align,
+                                     wavefile->header->bits_per_sample,
+                                     wavefile->header->extra_format_bytes );
+                }
+                wavefile->wavetype = WAVETYPE_MONO_8000HZ_PCMU;
+                break;
+        case WAV_PCMA:
+                if( (wavefile->header->channels           != 1    ) ||
+                    (wavefile->header->samples_per_second != 8000 ) ||
+                    (wavefile->header->bytes_per_second   != 8000 ) ||
+                    (wavefile->header->block_align        != 1    ) ||
+                    (wavefile->header->bits_per_sample    != 8    ) ||
+                    (wavefile->header->extra_format_bytes != 0    )   )
+                {
+                        MYLOG_ERROR( "Unsupported type of PCMA wavefile: chans=%d sps=%d bps=%d blalign=%d bits=%d exfmtbytes=%d\n",
+                                     wavefile->header->channels,
+                                     wavefile->header->samples_per_second,
+                                     wavefile->header->bytes_per_second,
+                                     wavefile->header->block_align,
+                                     wavefile->header->bits_per_sample,
+                                     wavefile->header->extra_format_bytes );
+                }
+                wavefile->wavetype = WAVETYPE_MONO_8000HZ_PCMA;
+                break;
+#ifdef SUPP_GSM
+        case WAV_GSM610:
+                if( (wavefile->header->channels             != 1                   ) ||
+                    (wavefile->header->samples_per_second   != 8000                ) ||
+                    (wavefile->header->bytes_per_second     != 1625                ) ||
+                    (wavefile->header->block_align          != 65                  ) ||
+                    (wavefile->header->bits_per_sample      != 0                   ) ||
+                    (wavefile->header->extra_format_bytes   != 2                   ) ||
+                    (wavefile->header->extra_format_data[0] != (320        & 0xFF) ) ||  //samples per block
+                    (wavefile->header->extra_format_data[1] != ((320 >> 8) & 0xFF) )   ) //samples per block
+                {
+                        MYLOG_ERROR( "Unsupported type of GSM610 wavefile: chans=%d sps=%d bps=%d blalign=%d bits=%d exfmtbytes=%d exfmtdata[0]=%d exfmtdata[1]=%d\n",
+                                     wavefile->header->channels,
+                                     wavefile->header->samples_per_second,
+                                     wavefile->header->bytes_per_second,
+                                     wavefile->header->block_align,
+                                     wavefile->header->bits_per_sample,
+                                     wavefile->header->extra_format_bytes,
+                                     wavefile->header->extra_format_data[0],
+                                     wavefile->header->extra_format_data[1]  );
+                }
+                wavefile->wavetype = WAVETYPE_MONO_8000HZ_GSM610;
+                break;
+#endif //SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Unsupported type of wavefile: header->type=%d",wavefile->header->type);
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        if( wavefile->header->fact_length >= 4 ) {
+                wavefile->end_samples = ((uint32_t)(wavefile->header->fact_data[0]) << 0 ) +
+                                        ((uint32_t)(wavefile->header->fact_data[1]) << 8 ) +
+                                        ((uint32_t)(wavefile->header->fact_data[2]) << 16) +
+                                        ((uint32_t)(wavefile->header->fact_data[3]) << 24) ;
+        }
+        else {
+                wavefile->end_samples = wavefile->header->data_length >> 1;  //PCM: 2 bytes = 1 sample
+        }
+        wavefile->total_samples = wavefile->end_samples;
+        wavefile->end_bytes     = wavefile->header->data_length;
+        wavefile->total_bytes   = wavefile->end_bytes;
+        wavefile->rwmode        = WAVEFILE_RWMODE_READ;
+
+        MYLOG_TRACE("wavefile->end_samples  =%u",wavefile->end_samples  );
+        MYLOG_TRACE("wavefile->total_samples=%u",wavefile->total_samples);
+        MYLOG_TRACE("wavefile->end_bytes    =%u",wavefile->end_bytes    );
+        MYLOG_TRACE("wavefile->total_bytes  =%u",wavefile->total_bytes  );
+
+        wavefile->data8_bytes     = 0;
+        wavefile->voice16_samples = 0;
+
+        //Create/init vocoder if it is needed
+        init_g711();
+        switch(wavefile->wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+        case WAVETYPE_MONO_8000HZ_PCMA:
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                //do nothing
+                break;
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                //create vocoder
+                if(wavefile->vocoder==NULL) {
+                        wavefile->vocoder = gsm_create();
+                        if(wavefile->vocoder==NULL) {
+                                MYLOG_ERROR("Could not create GSM0610 vocoder!");
+                                fclose(wavefile->fp);
+                                wavefile->fp = NULL;
+                                return(-1);
+                        }
+                }
+                //init vocoder
+                gsm_init(wavefile->vocoder);
+                //set WAV49 option
+                {
+                        int one;
+                        one = 1;
+                        gsm_option(wavefile->vocoder, GSM_OPT_WAV49, &one);
+                }
+                break;
+#endif //SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Invalid value: wavefile->wavetype=%u",wavefile->wavetype);
+                wavefile_close(wavefile);
+                return(-1);
+        }
+
+        MYLOG_TRACE("wavefile (filename=%s) was successfuly opened in read mode", wavefile->filename);
+        return(0);
+}
+
+//------------------------------------------------------------
+//Read encoded data from opened wavefile
+//inputs:  wavefile = pointer to wavefile
+//         data     = destination buffer for readed data bytes
+//         bytes    = number of bytes to be read
+//outputs: wavetype = actual wavetype of readed bytes
+//returns: 0 = ok
+//         1 = end of file
+//        -1 = error
+int wavefile_read_data ( wavefile_t * wavefile, uint8_t * data, int bytes, uint8_t * wavetype )
+{
+        int n;
+
+        MYLOG_TRACE("@ (wavefile=%p,data=%p,bytes=%d,wavetype=%p)",wavefile,data,bytes,wavetype);
+
+        //Check input parameters
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(wavefile->fp == NULL) {
+                MYLOG_ERROR("Wavefile is not opened!");
+                return(-1);
+        }
+        if(wavefile->rwmode != WAVEFILE_RWMODE_READ) {
+                MYLOG_ERROR("Wavefile is not opened in read mode!");
+                return(-1);
+        }
+        if(data==NULL) {
+                MYLOG_ERROR("Invalid value: data=NULL");
+                return(-1);
+        }
+        if(wavetype==NULL) {
+                MYLOG_ERROR("Invalid value: wavetype=NULL");
+                return(-1);
+        }
+        if(bytes<0) {
+                MYLOG_ERROR("Invalid value: bytes=%d",bytes);
+                return(-1);
+        }
+        if(bytes==0) {
+                //read nothing
+                *wavetype = wavefile->wavetype;
+                return(0);
+        }
+
+        //Read data from file (without conversion)
+        *wavetype = wavefile->wavetype;
+        n = fread( data, sizeof(uint8_t), bytes, wavefile->fp );
+        if(n != bytes) {
+                if( feof(wavefile->fp) ) {
+                        return(1); //end of file
+                }
+                else {
+                        MYLOG_ERROR( "Could not read bytes! %d bytes of %d have been read: %d:%s",
+                                     n,bytes,errno,strerror(errno) );
+                        return(-1);
+                }
+        }
+        return(0);
+}
+
+//------------------------------------------------------------
+//Read samples from opened wavefile
+//inputs:  wavefile = pointer to wavefile
+//         voice    = destination buffer for readed samples
+//         samples  = number of samples to be read
+//returns: 0 = ok
+//         1 = end of file
+//        -1 = error
+int wavefile_read_voice ( wavefile_t * wavefile, int16_t * voice, int samples )
+{
+        int       i;
+        int       n;
+
+        //Check input parameters
+        if(wavefile == NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(-1);
+        }
+        if(wavefile->fp == NULL) {
+                MYLOG_ERROR("Wavefile is not opened!");
+                return(-1);
+        }
+        if(wavefile->rwmode != WAVEFILE_RWMODE_READ) {
+                MYLOG_ERROR("Wavefile is not opened in read mode!");
+                return(-1);
+        }
+        if(voice==NULL) {
+                MYLOG_ERROR("Invalid value: voice=NULL");
+                return(-1);
+        }
+        if(samples<0) {
+                MYLOG_ERROR("Invalid value: samples=%d",samples);
+                return(-1);
+        }
+        if(samples==0) {
+                //read nothing
+                return(0);
+        }
+
+        //read data and convert to voice
+        switch(wavefile->wavetype)
+        {
+        case WAVETYPE_MONO_8000HZ_PCM16:
+                n = fread( voice, sizeof(int16_t), samples, wavefile->fp );
+                if(n != samples) {
+                        if( feof(wavefile->fp) ) {
+                                return(1); //end of file
+                        }
+                        else {
+                                MYLOG_ERROR( "Could not read PCM16 samples! %d bytes of %d have been read: %d:%s",
+                                             n,samples,errno,strerror(errno) );
+                                return(-1);
+                        }
+                }
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMA:
+                for(i=0; i<samples; i++) {
+                        n = fread( wavefile->data8, sizeof(uint8_t), 1, wavefile->fp );
+                        if(n != 1) {
+                                if( feof(wavefile->fp) ) {
+                                        return(1); //end of file
+                                }
+                                else {
+                                        MYLOG_ERROR( "Could not read PCMA samples: %d:%s",
+                                                     errno,strerror(errno) );
+                                        return(-1);
+                                }
+                        }
+                        voice[i] = alaw2linear( wavefile->data8[0] );
+                }
+                return(0);
+
+        case WAVETYPE_MONO_8000HZ_PCMU:
+                for(i=0; i<samples; i++) {
+                        n = fread( wavefile->data8, sizeof(uint8_t), 1, wavefile->fp );
+                        if(n != 1) {
+                                if( feof(wavefile->fp) ) {
+                                        return(1); //end of file
+                                }
+                                else {
+                                        MYLOG_ERROR( "Could not read PCMA samples: %d:%s",
+                                                     errno,strerror(errno) );
+                                        return(-1);
+                                }
+                        }
+                        voice[i] = mulaw2linear( wavefile->data8[0] );
+                }
+                return(0);
+
+#ifdef SUPP_GSM
+        case WAVETYPE_MONO_8000HZ_GSM610:
+                if(wavefile->vocoder == NULL) {
+                        MYLOG_ERROR("wavefile->vocoder=NULL!");
+                        return(-1);
+                }
+                for(i=0; i<samples; i++) {
+                        if(wavefile->voice16_samples<=0) {
+                                //read 65 GSM bytes from file to data8[]
+                                n = fread( wavefile->data8, sizeof(uint8_t), 65, wavefile->fp );
+                                if(n!=65) {
+                                        if( feof(wavefile->fp) ) {
+                                                //end of file
+                                                return(1);
+                                        }
+                                        else {
+                                                MYLOG_ERROR( "Could not read GSM610 samples: %d bytes of %d have been written: %d:%s",
+                                                            n,65,errno,strerror(errno) );
+                                                return(-1);
+                                        }
+                                }
+                                //convert block of 65 compressed data bytes (MS GSM frame format) in data8[]
+                                //to 320 samples in voice16[]
+                                // decode 1st frame
+                                gsm_decode( wavefile->vocoder, (uint8_t*)(data8), (gsm_signal*)(wavefile->voice16) );
+                                // decode 2nd frame
+                                gsm_decode( wavefile->vocoder, (uint8_t*)(data8)+32, (gsm_signal*)(wavefile->voice16+160) );
+                                wavefile->voice16_samples += 320;
+                        }
+                        voice[i] = wavefile->voice16[ wavefile->voice16_samples-- ];
+                }
+                return(0);
+#endif //SUPP_GSM
+
+        default:
+                MYLOG_ERROR("Invalid wavetype=%d",wavefile->wavetype);
+                return(-1);
+        }
+}
+
+//------------------------------------------------------------
+//Get wavetype of opened wave-file
+uint8_t wavefile_get_wavetype ( wavefile_t * wavefile )
+{
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(WAVETYPE_NOTSET);
+        }
+        return(wavefile->wavetype);
+}
+
+//------------------------------------------------------------
+//Get size of opened wave-file (in bytes)
+//NOTE: when writing wave-file - call this function only after wavefile_write_close()
+//      when reading wave-file - call this function any time after wavefile_read_start()
+//inputs:   wavefile = pointer to wavefile structure
+//returns:  filesize = bytes
+//          0 = error
+uint32_t wavefile_get_bytes( wavefile_t * wavefile )
+{
+        //Check input parameters
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(0);
+        }
+        return(  wavefile->header->file_length + 8  );
+}
+
+//------------------------------------------------------------
+//Get length of opened wave-file (in samples)
+//NOTE: when writing wave-file - call this function only after wavefile_write_close()
+//      when reading wave-file - call this function any time after wavefile_read_start()
+//inputs:   wavefile = pointer to wavefile structure
+//returns:  lenght  = samples
+//          0 = error
+uint32_t wavefile_get_samples( wavefile_t * wavefile )
+{
+        //Check input parameters
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(0);
+        }
+        return(  wavefile->total_samples  );
+}
+
+//------------------------------------------------------------
+//Get length of opened wave-file (in seconds)
+//NOTE: when writing wave-file - call this function only after wavefile_write_close()
+//      when reading wave-file - call this function any time after wavefile_read_start()
+//inputs:   wavefile = pointer to wavefile structure
+//returns:  length   = seconds
+//          0 = error
+uint32_t wavefile_get_seconds( wavefile_t * wavefile )
+{
+        //Check input parameters
+        if(wavefile==NULL) {
+                MYLOG_ERROR("Invalid value: wavefile=NULL");
+                return(0);
+        }
+
+        return(  wavefile->total_samples / wavefile->header->samples_per_second );
+}
+
+
+
+
diff -Nura v4l2rtspserver_imp_tools/filter/wave.h v4l2rtspserver-master/filter/wave.h
--- v4l2rtspserver_imp_tools/filter/wave.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/filter/wave.h	2019-02-03 20:24:23.642172000 +0100
@@ -0,0 +1,139 @@
+/******************************************************************************/
+/* WAVE-FILES UTILITES                                                        */
+/* wave.h                                                                     */
+/* (c) Sergei Mashkin, 2015                                                   */
+/******************************************************************************/
+
+#ifndef WAVE_H
+#define WAVE_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "types.h"
+
+/******************************************************************************/
+/* DEFINITIONS                                                                */
+/******************************************************************************/
+
+#define  ABS_PATH_MAX                 1024
+
+//Types of wave-files
+#define  WAVETYPE_NOTSET              0 //set wavetype automatically on first write operation
+#define  WAVETYPE_MONO_8000HZ_PCM16   1
+#define  WAVETYPE_MONO_8000HZ_PCMA    2
+#define  WAVETYPE_MONO_8000HZ_PCMU    3
+#define  WAVETYPE_MONO_8000HZ_GSM610  4
+#define  WAVETYPE_DEFAULT             WAVETYPE_MONO_8000HZ_PCM16
+
+#define  WAVEFILE_RWMODE_NOTSET       0
+#define  WAVEFILE_RWMODE_READ         1
+#define  WAVEFILE_RWMODE_WRITE        2
+
+#define  WAVEFILE_BUFF_SIZE           320  //>=320
+
+//------------------------------------------------------------------------------
+//Canonical WAVE format sructure
+typedef struct waveheader_t waveheader_t;
+struct waveheader_t
+{
+    //==== RIFF Header for WAVE-file
+    char          riff[4];              //'RIFF'
+    uint32_t      file_length;          //(file size-8) bytes
+    char          wave[4];              //'WAVE'
+
+    //==== fmt chunk
+    char          fmt[4];               //'fmt '
+    uint32_t      fmt_length;           //length of fmt data = (18+extra format bytes), bytes
+    uint16_t      type;                 //0x0001=PCM, 0x0006=alaw, 0x0007=ulaw, 0x0031=GSM610
+    uint16_t      channels;             //1=mono,2=stereo
+    uint32_t      samples_per_second;   //samples per second (44100,8000,16000,..)
+    uint32_t      bytes_per_second;     //samples_per_second * block_align
+    uint16_t      block_align;          //channels * bits_per_sample / 8
+    uint16_t      bits_per_sample;      //8 or 16
+    uint16_t      extra_format_bytes;   //number of extra format bytes
+    char          extra_format_data[2]; //set maximum supported extra format bytes here
+
+    //==== fact chunk
+    char          fact[4];              //'fact'
+    uint32_t      fact_length;          //length of the fact block (bytes) = 4
+    char          fact_data[4];         //set maximum supported fact bytes here
+
+    //==== data chunk
+    char          data[4];              //'data'
+    uint32_t      data_length;          //length of the data block (bytes, must be x2)
+};
+
+//------------------------------------------------------------------------------
+//WAVE-FILE structure
+typedef struct wavefile_t wavefile_t;
+struct wavefile_t
+{
+    unsigned char  wavetype;               //WAVETYPE_MONO_8000HZ_PCM16 / WAVETYPE_MONO_8000HZ_PCMA / ...
+    char           filename[ABS_PATH_MAX]; //name of currently used wave-file ("" = not opened)
+    uint8_t        rwmode;
+
+    waveheader_t * header;
+    FILE         * fp;                     //pointer to opened file
+    long           pos;                    //current read/write  pos
+
+    uint32_t       end_samples;            //samples from beginig to end mark
+    uint32_t       end_bytes;              //number of data-bytes from beginig to end mark
+    uint32_t       total_samples;          //samples from beginig to end of file
+    uint32_t       total_bytes;            //number of data-bytes from beginig to end of file
+
+    //==== vocoder
+    void *         vocoder;
+
+    uint8_t        data8[WAVEFILE_BUFF_SIZE];
+    int            data8_bytes;
+
+    int16_t        voice16[WAVEFILE_BUFF_SIZE];
+    int            voice16_samples;
+};
+
+//NOTE:
+//For multi-channel data, samples are interleaved between channels, like this:
+// sample 0 for channel 0
+// sample 0 for channel 1
+// sample 1 for channel 0
+// sample 1 for channel 1
+//...
+
+/******************************************************************************/
+/* FUNCTIONS                                                                  */
+/******************************************************************************/
+
+waveheader_t * waveheader_create           ( void );
+void           waveheader_destroy          ( waveheader_t * header );
+int            waveheader_set_default      ( waveheader_t * header, uint8_t wavetype );
+int            waveheader_write            ( FILE * fid, waveheader_t * header );
+int            waveheader_read             ( FILE * fid, waveheader_t * header );
+int            waveheader_get_default_size ( uint8_t wavetype );
+
+
+wavefile_t   * wavefile_create             ( void );
+void           wavefile_destroy            ( wavefile_t * wavefile );
+
+int            wavefile_write_open         ( wavefile_t * wavefile, char * filename, uint8_t wavetype );
+int            wavefile_write_data         ( wavefile_t * wavefile, uint8_t * data, int bytes, int samples, uint8_t wavetype );
+int            wavefile_write_voice        ( wavefile_t * wavefile, int16_t * voice, int samples );
+int            wavefile_write_set_end      ( wavefile_t * wavefile );
+
+int            wavefile_read_open          ( wavefile_t * wavefile, char * filename );
+int            wavefile_read_data          ( wavefile_t * wavefile, uint8_t * data, int bytes, uint8_t * wavetype );
+int            wavefile_read_voice         ( wavefile_t * wavefile, int16_t * voice, int samples );
+
+int            wavefile_close              ( wavefile_t * wavefile );
+
+int            wavefile_set_wavetype       ( wavefile_t * wavefile, uint8_t wavetype );
+uint8_t        wavefile_get_wavetype       ( wavefile_t * wavefile );
+
+uint32_t       wavefile_get_bytes          ( wavefile_t * wavefile );
+uint32_t       wavefile_get_samples        ( wavefile_t * wavefile );
+uint32_t       wavefile_get_seconds        ( wavefile_t * wavefile );
+
+#endif //WAVE_H
diff -Nura v4l2rtspserver_imp_tools/.gitignore v4l2rtspserver-master/.gitignore
--- v4l2rtspserver_imp_tools/.gitignore	2019-02-01 20:08:29.538626000 +0100
+++ v4l2rtspserver-master/.gitignore	2019-02-03 20:24:23.639172000 +0100
@@ -3,10 +3,17 @@
 CMakeCache.txt
 *.cmake
 Makefile
+!v4l2wrapper/Makefile
 # build
 libv4l2wrapper.a
+h264_v4l2_rtspserver
 v4l2rtspserver
+v4l2rtspserver-master
+_install/
+rootfs
+*.a
 # cpack
 _CPack_Packages
 install_manifest.txt
 *.deb
+.idea/*
\ No newline at end of file
diff -Nura v4l2rtspserver_imp_tools/.gitlab-ci.yml v4l2rtspserver-master/.gitlab-ci.yml
--- v4l2rtspserver_imp_tools/.gitlab-ci.yml	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/.gitlab-ci.yml	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-image: docker:stable
-services:
-  - docker:dind
-
-variables:
-  DOCKER_HOST: tcp://docker:2375
-  DOCKER_DRIVER: overlay2
-  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
-
-before_script:
-  - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
-
-build:
-  stage: build
-  script:
-    - docker build -t $IMAGE_TAG .
-    - docker push $IMAGE_TAG
-
diff -Nura v4l2rtspserver_imp_tools/inc/AddH26xMarkerFilter.h v4l2rtspserver-master/inc/AddH26xMarkerFilter.h
--- v4l2rtspserver_imp_tools/inc/AddH26xMarkerFilter.h	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/inc/AddH26xMarkerFilter.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-/* ---------------------------------------------------------------------------
-** This software is in the public domain, furnished "as is", without technical
-** support, and with no warranty, express or implied, as to its usefulness for
-** any purpose.
-**
-** AddH26xMarkerFilter.h
-** 
-** -------------------------------------------------------------------------*/
-
-#pragma once
-
-class AddH26xMarkerFilter : public FramedFilter {
-	public:
-		AddH26xMarkerFilter (UsageEnvironment& env, FramedSource* inputSource): FramedFilter(env, inputSource) {
-			m_bufferSize = OutPacketBuffer::maxSize;
-			m_buffer = new unsigned char[m_bufferSize];
-		}
-		virtual ~AddH26xMarkerFilter () {
-			delete [] m_buffer;
-		}
-		
-	private:
-
-		static void afterGettingFrame(void* clientData, unsigned frameSize,
-						 unsigned numTruncatedBytes,
-						 struct timeval presentationTime,
-						 unsigned durationInMicroseconds) {
-			AddH26xMarkerFilter* sink = (AddH26xMarkerFilter*)clientData;
-			sink->afterGettingFrame(frameSize, numTruncatedBytes, presentationTime);
-		}
-				
-		void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime) 
-		{
-			fPresentationTime = presentationTime;
-			fDurationInMicroseconds = 0;
-			if (numTruncatedBytes > 0) 
-			{
-				envir() << "AddH26xMarkerFilter::afterGettingFrame(): The input frame data was too large for our buffer size truncated:" << numTruncatedBytes << " bufferSize:" << m_bufferSize << "\n";
-				m_bufferSize += numTruncatedBytes;
-				delete[] m_buffer;
-				m_buffer = new unsigned char[m_bufferSize];
-				fFrameSize = 0;
-			} else {
-				char marker[] = {0,0,0,1};
-				fFrameSize = frameSize + sizeof(marker);
-				if (fFrameSize > fMaxSize) {
-					fNumTruncatedBytes = fFrameSize - fMaxSize; 
-					envir() << "AddH26xMarkerFilter::afterGettingFrame(): buffer too small truncated:" << fNumTruncatedBytes << " bufferSize:" << fFrameSize << "\n";
-				} else {
-					fNumTruncatedBytes = 0;
-					memcpy(fTo, marker, sizeof(marker));
-					memcpy(fTo+sizeof(marker), m_buffer, frameSize); 
-				}
-			}
-			afterGetting(this);
-		}
-		
-		virtual void doGetNextFrame() {
-			if (fInputSource != NULL) 
-			{
-				fInputSource->getNextFrame(m_buffer, m_bufferSize,
-						afterGettingFrame, this,
-						handleClosure, this);
-			}			
-		}
-		
-		unsigned char* m_buffer;
-		unsigned int m_bufferSize;
-};
-
-
diff -Nura v4l2rtspserver_imp_tools/inc/ALSACapture.h v4l2rtspserver-master/inc/ALSACapture.h
--- v4l2rtspserver_imp_tools/inc/ALSACapture.h	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/inc/ALSACapture.h	2019-02-03 20:24:23.642172000 +0100
@@ -14,26 +14,44 @@
 #ifndef ALSA_CAPTURE
 #define ALSA_CAPTURE
 
-#include <list>
 
-#include <alsa/asoundlib.h>
+#include "lame.h"
 #include "logger.h"
+#include <opus.h>
+#include "../tools/sharedmem.h"
+typedef enum
+{
+    ENCODE_MP3,
+    ENCODE_OPUS,
+    ENCODE_PCM,
+    ENCODE_ULAW,
+} audioencoding;
+
+typedef enum
+{
+    SOURCE_IMP,
+    SOURCE_DSP,
+} audioSource;
+
 
 struct ALSACaptureParameters 
 {
-	ALSACaptureParameters(const char* devname, const std::list<snd_pcm_format_t> & formatList, unsigned int sampleRate, unsigned int channels, int verbose) : 
-		m_devName(devname), m_formatList(formatList), m_sampleRate(sampleRate), m_channels(channels), m_verbose(verbose) {
-			
-	}
-		
+	ALSACaptureParameters(const char* devname,  unsigned int inSampleRate, unsigned int outSampleRate, int verbose, audioencoding encode, audioSource source) :
+		m_devName(devname), m_inSampleRate(inSampleRate),m_outSampleRate(outSampleRate), m_channels(1), m_verbose(verbose), m_encode(encode),m_source(source)  {};
+
+
 	std::string      m_devName;
-	std::list<snd_pcm_format_t> m_formatList;		
-	unsigned int     m_sampleRate;
-	unsigned int     m_channels;
+	unsigned int     m_inSampleRate;
+	unsigned int     m_outSampleRate;
+	unsigned int     m_channels; //Always 1
 	int              m_verbose;
+	audioencoding    m_encode;
+    audioSource      m_source;
 };
 
-class ALSACapture 
+// Todo calculate the buffer depending on the inpus format + audio format
+#define RECBUF_SIZE		44100*2*1
+class ALSACapture
 {
 	public:
 		static ALSACapture* createNew(const ALSACaptureParameters & params) ;
@@ -42,27 +60,55 @@
 	
 	protected:
 		ALSACapture(const ALSACaptureParameters & params);
-		int configureFormat(snd_pcm_hw_params_t *hw_params);
-			
+		size_t readMP3(char* buffer, size_t bufferSize, int volume);
+		size_t readOpus(char* buffer, size_t bufferSize, int volume);
+		size_t readPCM(char* buffer, size_t bufferSize, int volume);
+		size_t readULAW(char* buffer, size_t bufferSize, int volume);
+
+		// This is non object progamming, sorry ...
+		size_t readMP3IMP(char* buffer, size_t bufferSize, int volume);
+        size_t readOpusIMP(char* buffer, size_t bufferSize, int volume);
+        size_t readPCMIMP(char* buffer, size_t bufferSize, int volume);
+        size_t readULAWIMP(char* buffer, size_t bufferSize, int volume);
+
+        void udpateHWVolume(unsigned int newVol);
+        void UpdateIMPFilter();
+        short filter(short val,bool swap, int num_sample =0);
+        void setSwVolume(short &val, int vol);
+        unsigned char ulaw_encode(short sample);
+
+        ssize_t readAudio(int fd, void *buf, size_t count);
+
+        void initAudioIMP(const ALSACaptureParameters & params);
+        void initAudio(const ALSACaptureParameters & params);
+
 	public:
 		virtual size_t read(char* buffer, size_t bufferSize);		
 		virtual int getFd();
 		
-		virtual unsigned long getBufferSize() { return m_bufferSize; };
+		virtual unsigned long getBufferSize();// { return RECBUF_SIZE; };
 		virtual int getWidth()  {return -1;}
 		virtual int getHeight() {return -1;}	
-		virtual int getCaptureFormat() {return -1;}	
 		
-		unsigned long getSampleRate() { return m_params.m_sampleRate; }
-		unsigned long getChannels  () { return m_params.m_channels;   }
-		snd_pcm_format_t getFormat () { return m_fmt;                 }
+		unsigned long getInSampleRate() { return m_params.m_inSampleRate; };
+		unsigned long getOutSampleRate() { return m_params.m_outSampleRate; };
+		unsigned long getChannels  () { return m_params.m_channels; };
 		
 	private:
-		snd_pcm_t*            m_pcm;
 		unsigned long         m_bufferSize;
 		unsigned long         m_periodSize;
 		ALSACaptureParameters m_params;
-		snd_pcm_format_t      m_fmt;
+        int fd;
+		lame_global_flags *gfp;
+		OpusEncoder *encoder;
+		SharedMem m_sharedMem;
+		struct shared_conf m_currentConfig;
+		shared_conf *m_newConfig;
+		int m_Filtermethod;
+		bool m_HighFiltermethod;
+		bool m_AECFiltermethod;
+		audioSource m_audioSource;
+
 };
 
 #endif
diff -Nura v4l2rtspserver_imp_tools/inc/ConfigReader.h v4l2rtspserver-master/inc/ConfigReader.h
--- v4l2rtspserver_imp_tools/inc/ConfigReader.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/ConfigReader.h	2019-02-03 20:24:23.642172000 +0100
@@ -0,0 +1,50 @@
+ #ifndef DEF_ConfigReader
+ #define DEF_ConfigReader
+
+#include <stdio.h>
+
+
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
+
+#include "logger.h"
+#include <sstream>
+#include "INIReader.h"
+
+
+
+ class ConfigReader
+ {
+ public:
+    static ConfigReader& instance()
+    {
+       static ConfigReader _instance;
+       return _instance;
+    }
+    ~ConfigReader() {}
+    void readConfig();
+    char* getSensorName();
+    int getSensorAddr();
+    int getWidth();
+    int getHeight();
+    int getFps();
+    int getEncoderMode();
+    int getBitrate();
+    int getRtspPort();
+    char* getRtspUrl();
+    int getRtspMode();
+
+    bool getAudioEnabled();
+    INIReader *reader;
+
+
+ private:
+    ConfigReader() {}           // verhindert, dass ein Objekt von außerhalb von ConfigReader erzeugt wird.
+                    // protected, wenn man von der Klasse noch erben möchte
+    ConfigReader( const ConfigReader& ); /* verhindert, dass eine weitere Instanz via
+ Kopier-Konstruktor erstellt werden kann */
+    ConfigReader & operator = (const ConfigReader &); //Verhindert weitere Instanz durch Kopie
+ };
+
+
+#endif
\ No newline at end of file
diff -Nura v4l2rtspserver_imp_tools/inc/DeviceInterface.h v4l2rtspserver-master/inc/DeviceInterface.h
--- v4l2rtspserver_imp_tools/inc/DeviceInterface.h	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/inc/DeviceInterface.h	2019-02-03 20:24:23.642172000 +0100
@@ -23,7 +23,6 @@
 		virtual unsigned long getBufferSize() = 0;
 		virtual int getWidth() = 0;	
 		virtual int getHeight() = 0;	
-		virtual int getCaptureFormat() = 0;
 		virtual ~DeviceInterface() {};
 };
 
@@ -41,9 +40,8 @@
 		virtual size_t read(char* buffer, size_t bufferSize) { return m_device->read(buffer, bufferSize); }
 		virtual int getFd()                                  { return m_device->getFd(); }
 		virtual unsigned long getBufferSize()                { return m_device->getBufferSize(); }
-		virtual int getWidth()                               { return m_device->getWidth(); }
-		virtual int getHeight()                              { return m_device->getHeight(); }
-		virtual int getCaptureFormat()                       { return m_device->getFormat(); }
+		virtual int getWidth()                                  { return m_device->getWidth(); }
+		virtual int getHeight()                                  { return m_device->getHeight(); }
 			
 	protected:
 		T* m_device;
diff -Nura v4l2rtspserver_imp_tools/inc/DeviceSource.h v4l2rtspserver-master/inc/DeviceSource.h
--- v4l2rtspserver_imp_tools/inc/DeviceSource.h	2019-02-01 20:08:29.559626000 +0100
+++ v4l2rtspserver-master/inc/DeviceSource.h	2019-02-03 20:24:23.642172000 +0100
@@ -18,8 +18,6 @@
 #include <iostream>
 #include <iomanip>
 
-#include <pthread.h>
-
 // live555
 #include <liveMedia.hh>
 
@@ -39,7 +37,7 @@
 			~Frame()  { delete [] m_buffer; };
 			
 			char* m_buffer;
-			unsigned int m_size;
+			int m_size;
 			timeval m_timestamp;
 		};
 		
@@ -64,10 +62,8 @@
 	public:
 		static V4L2DeviceSource* createNew(UsageEnvironment& env, DeviceInterface * device, int outputFd, unsigned int queueSize, bool useThread) ;
 		std::string getAuxLine() { return m_auxLine; };	
-		void setAuxLine(const std::string auxLine) { m_auxLine = auxLine; };	
 		int getWidth() { return m_device->getWidth(); };	
 		int getHeight() { return m_device->getHeight(); };	
-		int getCaptureFormat() { return m_device->getCaptureFormat(); };	
 
 	protected:
 		V4L2DeviceSource(UsageEnvironment& env, DeviceInterface * device, int outputFd, unsigned int queueSize, bool useThread);
diff -Nura v4l2rtspserver_imp_tools/inc/filt.h v4l2rtspserver-master/inc/filt.h
--- v4l2rtspserver_imp_tools/inc/filt.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/filt.h	2019-02-03 20:24:23.644172000 +0100
@@ -0,0 +1,160 @@
+/*
+ * FIR filter class, by Mike Perkins
+ * 
+ * a simple C++ class for linear phase FIR filtering
+ *
+ * For background, see the post http://www.cardinalpeak.com/blog?p=1841
+ *
+ * Copyright (c) 2013, Cardinal Peak, LLC.  http://www.cardinalpeak.com
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1) Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 
+ * 2) Redistributions in binary form must reproduce the above
+ *    copyright notice, this list of conditions and the following
+ *    disclaimer in the documentation and/or other materials provided
+ *    with the distribution.
+ * 
+ * 3) Neither the name of Cardinal Peak nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * CARDINAL PEAK, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * 
+ * PURPOSE:
+ * This object designs digital filters and filters digital data streams
+ * 
+ * USAGE:
+ * Invoke an object of type Filter.  Two constructors are available.
+ * One is used for LPF and HPF filters, one is used for BPFs.
+ * The arguments to the constructors are as follows:
+ * 
+ * 		// For LPF or HPF only
+ * 		Filter(filterType filt_t, int num_taps, double Fs, double Fx);
+ * 		// For BPF only
+ * 		Filter(filterType filt_t, int num_taps, double Fs, double Fl, double Fu);
+ * 
+ * filt_t: is LPF, HPF or BPF
+ * num_taps: is the number of taps you want the filter to use
+ * Fs: is the sampling frequency of the digital data being filtered
+ * Fx: is the "transition" frequency for LPF and HPF filters
+ * Fl, Fu: are the upper and lower transition frequencies for BPF filters
+ * 
+ * Once the filter is created, you can start filtering data.  Here
+ * is an example for 51 tap lowpass filtering of an audio stream sampled at
+ * 44.1Khz (the CD sampling rate), where the goal is to create a signal
+ * of "telephone" bandwidth (4Khz):
+ * 
+ * Filter *my_filter;
+ * 
+ * my_filter = new Filter(LPF, 51, 44.1, 4.0)
+ * if( my_filter->get_error_flag() != 0 ) // abort in an appropriate manner
+ * 
+ * while(data_to_be_filtered){
+ * 	next_sample = // Get the next sample from the data stream somehow
+ * 	filtered_sample = my_filter->do_sample( next_sample );
+ *   .
+ * 	.
+ * 	.
+ * }
+ * delete my_filter;
+ * 
+ * Several helper functions are provided:
+ *     init(): The filter can be re-initialized with a call to this function
+ *     get_taps(double *taps): returns the filter taps in the array "taps"
+ *     write_taps_to_file(char *filename): writes the filter taps to a file
+ *     write_freqres_to_file(char *filename): output frequency response to a file
+ * 
+ * Finally, a get_error_flag() function is provided.  Recommended usage
+ * is to check the get_error_flag() return value for a non-zero
+ * value after the new Filter object is created.  If it is non-zero, print 
+ * out the non-zero value and look at the following table to see the
+ * error:
+ * -1:  Fs <= 0
+ * -2:  Fx <= 0 or Fx >= Fs/2
+ * -3:  num_taps <= 0 or num_taps >= MAX_NUM_FILTER_TAPS
+ * -4:  memory allocation for the needed arrays failed
+ * -5:  an invalid filterType was passed into a constructor
+ * -10: Fs <= 0 (BPF case)
+ * -11: Fl >= Fu
+ * -12: Fl <= 0 || Fl >= Fs/2
+ * -13: Fu <= 0 || Fu >= Fs/2
+ * -14: num_taps <= 0 or num_taps >= MAX_NUM_FILTER_TAPS (BPF case)
+ * -15:  memory allocation for the needed arrays failed (BPF case)
+ * -16:  an invalid filterType was passed into a constructor (BPF case)
+ * 
+ * Note that if a non-zero error code value occurs, every call to do_sample()
+ * will return the value 0. write_taps_fo_file() will fail and return a -1 (it
+ * also returns a -1 if it fails to open the tap file passed into it).
+ * get_taps() will have no effect on the array passed in if the error_flag
+ * is non-zero. write_freqres_to_file( ) returns different error codes
+ * depending on the nature of the error...see the function itself for details.
+ * 
+ * The filters are designed using the "Fourier Series Method".  This
+ * means that the coefficients of a Fourier Series approximation to the
+ * frequency response of an ideal filter (LPF, HPF, BPF) are used as
+ * the filter taps.  The resulting filters have some ripple in the passband 
+ * due to the Gibbs phenomenon; the filters are linear phase.
+ */
+
+#ifndef _FILTER_H
+#define _FILTER_H
+
+#define MAX_NUM_FILTER_TAPS 1000
+
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <inttypes.h>
+
+enum filterType {LPF, HPF, BPF};
+
+class Filter{
+	private:
+		filterType m_filt_t;
+		int m_num_taps;
+		int m_error_flag;
+		double m_Fs;
+		double m_Fx;
+		double m_lambda;
+		double *m_taps;
+		double *m_sr;
+		void designLPF();
+		void designHPF();
+
+		// Only needed for the bandpass filter case
+		double m_Fu, m_phi;
+		void designBPF();
+
+	public:
+		Filter(filterType filt_t, int num_taps, double Fs, double Fx);
+		Filter(filterType filt_t, int num_taps, double Fs, double Fl, double Fu);
+		~Filter( );
+		void init();
+		double do_sample(double data_sample);
+		int get_error_flag(){return m_error_flag;};
+		void get_taps( double *taps );
+
+};
+
+#endif
diff -Nura v4l2rtspserver_imp_tools/inc/HTTPServer.h v4l2rtspserver-master/inc/HTTPServer.h
--- v4l2rtspserver_imp_tools/inc/HTTPServer.h	2019-02-01 20:08:29.559626000 +0100
+++ v4l2rtspserver-master/inc/HTTPServer.h	2019-02-03 20:24:23.642172000 +0100
@@ -35,7 +35,6 @@
 			void streamSource(FramedSource* source);	
 			void streamSource(const std::string & content);
 			ServerMediaSubsession* getSubsesion(const char* urlSuffix);
-			bool sendFile(char const* urlSuffix);
 			bool sendM3u8PlayList(char const* urlSuffix);
 			bool sendMpdPlayList(char const* urlSuffix);
 			virtual void handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr);
diff -Nura v4l2rtspserver_imp_tools/inc/ImpCapture.h v4l2rtspserver-master/inc/ImpCapture.h
--- v4l2rtspserver_imp_tools/inc/ImpCapture.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/ImpCapture.h	2019-02-03 20:24:23.643172000 +0100
@@ -0,0 +1,33 @@
+#ifndef _WEBCAM_JPEG_DEVICE_SOURCE_HH
+#define _WEBCAM_JPEG_DEVICE_SOURCE_HH
+
+#include "DeviceSource.h"
+#include "ImpEncoder.h"
+#include "logger.h"
+
+class ImpCapture {
+public:
+    ImpCapture(impParams params);
+
+    int getWidth();
+
+    int getHeight();
+
+    size_t read(char *buffer, size_t bufferSize);
+
+    int getFd();
+
+    unsigned long getBufferSize();
+
+    void *thread();
+
+protected:
+    ImpEncoder *impEncoder;
+    int width;
+    int height;
+    int mode;
+   //unsigned char *m_buffer;
+
+};
+
+#endif // _WEBCAM_JPEG_DEVICE_SOURCE_HH
\ No newline at end of file
diff -Nura v4l2rtspserver_imp_tools/inc/ImpEncoder.h v4l2rtspserver-master/inc/ImpEncoder.h
--- v4l2rtspserver_imp_tools/inc/ImpEncoder.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/ImpEncoder.h	2019-02-03 20:24:23.643172000 +0100
@@ -0,0 +1,167 @@
+#ifndef __SAMPLE_ENCODER_JPEG_H__
+#define __SAMPLE_ENCODER_JPEG_H__
+
+#include <imp/imp_common.h>
+#include <imp/imp_osd.h>
+#include <imp/imp_framesource.h>
+#include <imp/imp_isp.h>
+#include <unistd.h>
+#include <imp/imp_encoder.h>
+#include <list>
+#include <sys/ioctl.h>
+
+typedef enum detectionSaveToDiskState
+{
+    BUFFERIZE = 0,
+    LIVETODISK =1,
+    LIVETODISKBUFFER=2
+} DetectionSaveToDiskState;
+
+#define IMP_MODE_JPEG 1
+#define IMP_MODE_H264_STREAM 2
+#define IMP_MODE_H264_SNAP 3
+#define CH0_INDEX  0
+#define CH1_INDEX  1
+#define CHN_ENABLE 1
+#define CHN_DISABLE 0
+#define CHN0_EN                 1
+#define CHN1_EN                 1
+#define CROP_EN                    1
+#define SENSOR_FRAME_RATE_NUM        25
+#define SENSOR_FRAME_RATE_DEN        1
+#define SENSOR_WIDTH_SECOND        640
+#define SENSOR_HEIGHT_SECOND        360
+
+#define FS_CHN_NUM            1
+#define ENC_H264_CHANNEL        0
+#define ENC_JPEG_CHANNEL        1
+#define SLEEP_TIME            1
+#define SENSOR_NAME                "jxf22"
+#define SENSOR_CUBS_TYPE        TX_SENSOR_CONTROL_INTERFACE_I2C
+#define SENSOR_I2C_ADDR            0x40
+#define SENSOR_WIDTH            320
+#define SENSOR_HEIGHT            240
+#define STRING_MAX_SIZE          256
+
+
+#define SENSOR_INFO_IOC_MAGIC  'S'
+#define IOCTL_SINFO_GET			_IO(SENSOR_INFO_IOC_MAGIC, 100)
+#define IOCTL_SINFO_FLASH		_IO(SENSOR_INFO_IOC_MAGIC, 101)
+
+#define SENSOR_TYPE_INVALID	-1
+
+enum SENSOR_TYPE
+{
+    SENSOR_TYPE_OV9712=0,
+    SENSOR_TYPE_OV9732,
+    SENSOR_TYPE_OV9750,
+    SENSOR_TYPE_JXH42,
+    SENSOR_TYPE_SC1035,
+    SENSOR_TYPE_SC1135,
+    SENSOR_TYPE_SC1045,
+    SENSOR_TYPE_SC1145,
+    SENSOR_TYPE_AR0130,
+    SENSOR_TYPE_JXH61,
+    SENSOR_TYPE_GC1024,
+    SENSOR_TYPE_GC1064,
+    SENSOR_TYPE_GC2023,
+    SENSOR_TYPE_BF3115,
+    SENSOR_TYPE_IMX225,
+    SENSOR_TYPE_OV2710,
+    SENSOR_TYPE_IMX322,
+    SENSOR_TYPE_SC2135,
+    SENSOR_TYPE_SP1409,
+    SENSOR_TYPE_JXH62,
+    SENSOR_TYPE_BG0806,
+    SENSOR_TYPE_OV4689,
+    SENSOR_TYPE_JXF22,
+    SENSOR_TYPE_IMX323,
+    SENSOR_TYPE_IMX291
+};
+
+typedef struct SENSOR_INFO_S
+{
+    const char *name;
+} SENSOR_INFO_T;
+
+
+
+struct impParams {
+    int mode;
+    int width;
+    int height;
+    int bitrate;
+    int framerate;
+    int rcmode;
+};
+struct chn_conf {
+    unsigned int index;//0 for main channel ,1 for second channel
+    unsigned int enable;
+    IMPFSChnAttr fs_chn_attr;
+    IMPCell framesource_chn;
+    IMPCell imp_encoder;
+    IMPCell OSD_Cell;
+};
+
+class ImpEncoder {
+public:
+    ImpEncoder(impParams params);
+
+    ~ImpEncoder();
+
+    void requestIDR();
+
+    int snap_h264(uint8_t *buffer);
+
+    bool listEmpty();
+
+    IMPEncoderPack getFrame();
+
+    void static setNightVision(bool state);
+
+    void writeBufferToDisk();
+private:
+    int encoderMode;
+
+    int sample_system_init();
+
+
+    int sample_system_exit();
+
+    int sample_framesource_streamon();
+
+    int sample_framesource_streamoff();
+
+    int sample_framesource_init();
+
+    int sample_framesource_exit();
+
+    int sample_encoder_init(int, int, int);
+
+    int sample_jpeg_init();
+
+    int sample_encoder_exit(void);
+
+    //IMPRgnHandle *sample_osd_init(int grpNum, int, int,int);
+
+    int sample_osd_exit(IMPRgnHandle *prHandle, int grpNum);
+
+
+    IMPSensorInfo sensor_info;
+
+    impParams currentParams;
+
+    int encoder_chn_exit(int encChn);
+
+    chn_conf chn;
+
+  //  std::list <IMPEncoderPack> frameList;
+    pthread_mutex_t m_mutex;
+
+    int getSensorName();
+
+
+};
+
+
+#endif
diff -Nura v4l2rtspserver_imp_tools/inc/INIReader.h v4l2rtspserver-master/inc/INIReader.h
--- v4l2rtspserver_imp_tools/inc/INIReader.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/INIReader.h	2019-02-03 20:24:23.643172000 +0100
@@ -0,0 +1,441 @@
+// Read an INI file into easy-to-access name/value pairs.
+
+// inih and INIReader are released under the New BSD license (see LICENSE.txt).
+// Go to the project home page for more info:
+//
+// https://github.com/benhoyt/inih
+/* inih -- simple .INI file parser
+
+inih is released under the New BSD license (see LICENSE.txt). Go to the project
+home page for more info:
+
+https://github.com/benhoyt/inih
+
+*/
+
+#ifndef __INI_H__
+#define __INI_H__
+
+/* Make this header file easier to include in C++ code */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+/* Typedef for prototype of handler function. */
+typedef int (*ini_handler)(void* user, const char* section,
+                           const char* name, const char* value);
+
+/* Typedef for prototype of fgets-style reader function. */
+typedef char* (*ini_reader)(char* str, int num, void* stream);
+
+/* Parse given INI-style file. May have [section]s, name=value pairs
+   (whitespace stripped), and comments starting with ';' (semicolon). Section
+   is "" if name=value pair parsed before any section heading. name:value
+   pairs are also supported as a concession to Python's configparser.
+
+   For each name=value pair parsed, call handler function with given user
+   pointer as well as section, name, and value (data only valid for duration
+   of handler call). Handler should return nonzero on success, zero on error.
+
+   Returns 0 on success, line number of first error on parse error (doesn't
+   stop on first error), -1 on file open error, or -2 on memory allocation
+   error (only when INI_USE_STACK is zero).
+*/
+int ini_parse(const char* filename, ini_handler handler, void* user);
+
+/* Same as ini_parse(), but takes a FILE* instead of filename. This doesn't
+   close the file when it's finished -- the caller must do that. */
+int ini_parse_file(FILE* file, ini_handler handler, void* user);
+
+/* Same as ini_parse(), but takes an ini_reader function pointer instead of
+   filename. Used for implementing custom or string-based I/O. */
+int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,
+                     void* user);
+
+/* Nonzero to allow multi-line value parsing, in the style of Python's
+   configparser. If allowed, ini_parse() will call the handler with the same
+   name for each subsequent line parsed. */
+#ifndef INI_ALLOW_MULTILINE
+#define INI_ALLOW_MULTILINE 1
+#endif
+
+/* Nonzero to allow a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of
+   the file. See http://code.google.com/p/inih/issues/detail?id=21 */
+#ifndef INI_ALLOW_BOM
+#define INI_ALLOW_BOM 1
+#endif
+
+/* Nonzero to allow inline comments (with valid inline comment characters
+   specified by INI_INLINE_COMMENT_PREFIXES). Set to 0 to turn off and match
+   Python 3.2+ configparser behaviour. */
+#ifndef INI_ALLOW_INLINE_COMMENTS
+#define INI_ALLOW_INLINE_COMMENTS 1
+#endif
+#ifndef INI_INLINE_COMMENT_PREFIXES
+#define INI_INLINE_COMMENT_PREFIXES ";"
+#endif
+
+/* Nonzero to use stack, zero to use heap (malloc/free). */
+#ifndef INI_USE_STACK
+#define INI_USE_STACK 1
+#endif
+
+/* Stop parsing on first error (default is to keep parsing). */
+#ifndef INI_STOP_ON_FIRST_ERROR
+#define INI_STOP_ON_FIRST_ERROR 0
+#endif
+
+/* Maximum line length for any line in INI file. */
+#ifndef INI_MAX_LINE
+#define INI_MAX_LINE 200
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/* inih -- simple .INI file parser
+
+inih is released under the New BSD license (see LICENSE.txt). Go to the project
+home page for more info:
+
+https://github.com/benhoyt/inih
+
+*/
+
+#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
+#define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+
+#if !INI_USE_STACK
+#include <stdlib.h>
+#endif
+
+#define MAX_SECTION 50
+#define MAX_NAME 50
+
+/* Strip whitespace chars off end of given string, in place. Return s. */
+inline static char* rstrip(char* s)
+{
+    char* p = s + strlen(s);
+    while (p > s && isspace((unsigned char)(*--p)))
+        *p = '\0';
+    return s;
+}
+
+/* Return pointer to first non-whitespace char in given string. */
+inline static char* lskip(const char* s)
+{
+    while (*s && isspace((unsigned char)(*s)))
+        s++;
+    return (char*)s;
+}
+
+/* Return pointer to first char (of chars) or inline comment in given string,
+   or pointer to null at end of string if neither found. Inline comment must
+   be prefixed by a whitespace character to register as a comment. */
+inline static char* find_chars_or_comment(const char* s, const char* chars)
+{
+#if INI_ALLOW_INLINE_COMMENTS
+    int was_space = 0;
+    while (*s && (!chars || !strchr(chars, *s)) &&
+           !(was_space && strchr(INI_INLINE_COMMENT_PREFIXES, *s))) {
+        was_space = isspace((unsigned char)(*s));
+        s++;
+    }
+#else
+    while (*s && (!chars || !strchr(chars, *s))) {
+        s++;
+    }
+#endif
+    return (char*)s;
+}
+
+/* Version of strncpy that ensures dest (size bytes) is null-terminated. */
+inline static char* strncpy0(char* dest, const char* src, size_t size)
+{
+    strncpy(dest, src, size);
+    dest[size - 1] = '\0';
+    return dest;
+}
+
+/* See documentation in header file. */
+inline int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,
+                     void* user)
+{
+    /* Uses a fair bit of stack (use heap instead if you need to) */
+#if INI_USE_STACK
+    char line[INI_MAX_LINE];
+#else
+    char* line;
+#endif
+    char section[MAX_SECTION] = "";
+    char prev_name[MAX_NAME] = "";
+
+    char* start;
+    char* end;
+    char* name;
+    char* value;
+    int lineno = 0;
+    int error = 0;
+
+#if !INI_USE_STACK
+    line = (char*)malloc(INI_MAX_LINE);
+    if (!line) {
+        return -2;
+    }
+#endif
+
+    /* Scan through stream line by line */
+    while (reader(line, INI_MAX_LINE, stream) != NULL) {
+        lineno++;
+
+        start = line;
+#if INI_ALLOW_BOM
+        if (lineno == 1 && (unsigned char)start[0] == 0xEF &&
+                           (unsigned char)start[1] == 0xBB &&
+                           (unsigned char)start[2] == 0xBF) {
+            start += 3;
+        }
+#endif
+        start = lskip(rstrip(start));
+
+        if (*start == ';' || *start == '#') {
+            /* Per Python configparser, allow both ; and # comments at the
+               start of a line */
+        }
+#if INI_ALLOW_MULTILINE
+        else if (*prev_name && *start && start > line) {
+
+#if INI_ALLOW_INLINE_COMMENTS
+        end = find_chars_or_comment(start, NULL);
+        if (*end)
+            *end = '\0';
+        rstrip(start);
+#endif
+
+            /* Non-blank line with leading whitespace, treat as continuation
+               of previous name's value (as per Python configparser). */
+            if (!handler(user, section, prev_name, start) && !error)
+                error = lineno;
+        }
+#endif
+        else if (*start == '[') {
+            /* A "[section]" line */
+            end = find_chars_or_comment(start + 1, "]");
+            if (*end == ']') {
+                *end = '\0';
+                strncpy0(section, start + 1, sizeof(section));
+                *prev_name = '\0';
+            }
+            else if (!error) {
+                /* No ']' found on section line */
+                error = lineno;
+            }
+        }
+        else if (*start) {
+            /* Not a comment, must be a name[=:]value pair */
+            end = find_chars_or_comment(start, "=:");
+            if (*end == '=' || *end == ':') {
+                *end = '\0';
+                name = rstrip(start);
+                value = lskip(end + 1);
+#if INI_ALLOW_INLINE_COMMENTS
+                end = find_chars_or_comment(value, NULL);
+                if (*end)
+                    *end = '\0';
+#endif
+                rstrip(value);
+
+                /* Valid name[=:]value pair found, call handler */
+                strncpy0(prev_name, name, sizeof(prev_name));
+                if (!handler(user, section, name, value) && !error)
+                    error = lineno;
+            }
+            else if (!error) {
+                /* No '=' or ':' found on name[=:]value line */
+                error = lineno;
+            }
+        }
+
+#if INI_STOP_ON_FIRST_ERROR
+        if (error)
+            break;
+#endif
+    }
+
+#if !INI_USE_STACK
+    free(line);
+#endif
+
+    return error;
+}
+
+/* See documentation in header file. */
+inline int ini_parse_file(FILE* file, ini_handler handler, void* user)
+{
+    return ini_parse_stream((ini_reader)fgets, file, handler, user);
+}
+
+/* See documentation in header file. */
+inline int ini_parse(const char* filename, ini_handler handler, void* user)
+{
+    FILE* file;
+    int error;
+
+    file = fopen(filename, "r");
+    if (!file)
+        return -1;
+    error = ini_parse_file(file, handler, user);
+    fclose(file);
+    return error;
+}
+
+#endif /* __INI_H__ */
+
+
+#ifndef __INIREADER_H__
+#define __INIREADER_H__
+
+#include <map>
+#include <set>
+#include <string>
+
+// Read an INI file into easy-to-access name/value pairs. (Note that I've gone
+// for simplicity here rather than speed, but it should be pretty decent.)
+class INIReader
+{
+public:
+    // Empty Constructor
+    INIReader() {};
+  
+    // Construct INIReader and parse given filename. See ini.h for more info
+    // about the parsing.
+    INIReader(std::string filename);
+
+    // Return the result of ini_parse(), i.e., 0 on success, line number of
+    // first error on parse error, or -1 on file open error.
+    int ParseError() const;
+
+    // Return the list of sections found in ini file
+    const std::set<std::string>& Sections() const;
+
+    // Get a string value from INI file, returning default_value if not found.
+    std::string Get(std::string section, std::string name,
+                    std::string default_value) const;
+
+    // Get an integer (long) value from INI file, returning default_value if
+    // not found or not a valid integer (decimal "1234", "-1234", or hex "0x4d2").
+    long GetInteger(std::string section, std::string name, long default_value) const;
+
+    // Get a real (floating point double) value from INI file, returning
+    // default_value if not found or not a valid floating point value
+    // according to strtod().
+    double GetReal(std::string section, std::string name, double default_value) const;
+
+    // Get a boolean value from INI file, returning default_value if not found or if
+    // not a valid true/false value. Valid true values are "true", "yes", "on", "1",
+    // and valid false values are "false", "no", "off", "0" (not case sensitive).
+    bool GetBoolean(std::string section, std::string name, bool default_value) const;
+
+private:
+    int _error;
+    std::map<std::string, std::string> _values;
+    std::set<std::string> _sections;
+    static std::string MakeKey(std::string section, std::string name);
+    static int ValueHandler(void* user, const char* section, const char* name,
+                            const char* value);
+};
+
+#endif  // __INIREADER_H__
+
+
+#ifndef __INIREADER__
+#define __INIREADER__
+
+#include <algorithm>
+#include <cctype>
+#include <cstdlib>
+
+using std::string;
+
+inline INIReader::INIReader(string filename)
+{
+    _error = ini_parse(filename.c_str(), ValueHandler, this);
+}
+
+inline int INIReader::ParseError() const
+{
+    return _error;
+}
+
+inline const std::set<string>& INIReader::Sections() const
+{
+    return _sections;
+}
+
+inline string INIReader::Get(string section, string name, string default_value) const
+{
+    string key = MakeKey(section, name);
+    return _values.count(key) ? _values.at(key) : default_value;
+}
+
+inline long INIReader::GetInteger(string section, string name, long default_value) const
+{
+    string valstr = Get(section, name, "");
+    const char* value = valstr.c_str();
+    char* end;
+    // This parses "1234" (decimal) and also "0x4D2" (hex)
+    long n = strtol(value, &end, 0);
+    return end > value ? n : default_value;
+}
+
+inline double INIReader::GetReal(string section, string name, double default_value) const
+{
+    string valstr = Get(section, name, "");
+    const char* value = valstr.c_str();
+    char* end;
+    double n = strtod(value, &end);
+    return end > value ? n : default_value;
+}
+
+inline bool INIReader::GetBoolean(string section, string name, bool default_value) const
+{
+    string valstr = Get(section, name, "");
+    // Convert to lower case to make string comparisons case-insensitive
+    std::transform(valstr.begin(), valstr.end(), valstr.begin(), ::tolower);
+    if (valstr == "true" || valstr == "yes" || valstr == "on" || valstr == "1")
+        return true;
+    else if (valstr == "false" || valstr == "no" || valstr == "off" || valstr == "0")
+        return false;
+    else
+        return default_value;
+}
+
+inline string INIReader::MakeKey(string section, string name)
+{
+    string key = section + "=" + name;
+    // Convert to lower case to make section/name lookups case-insensitive
+    std::transform(key.begin(), key.end(), key.begin(), ::tolower);
+    return key;
+}
+
+inline int INIReader::ValueHandler(void* user, const char* section, const char* name,
+                            const char* value)
+{
+    INIReader* reader = (INIReader*)user;
+    string key = MakeKey(section, name);
+    if (reader->_values[key].size() > 0)
+        reader->_values[key] += "\n";
+    reader->_values[key] += value;
+    reader->_sections.insert(section);
+    return 1;
+}
+
+#endif  // __INIREADER__
diff -Nura v4l2rtspserver_imp_tools/inc/lame.h v4l2rtspserver-master/inc/lame.h
--- v4l2rtspserver_imp_tools/inc/lame.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/lame.h	2019-02-03 20:24:23.646172000 +0100
@@ -0,0 +1,1342 @@
+/*
+ *	Interface to MP3 LAME encoding engine
+ *
+ *	Copyright (c) 1999 Mark Taylor
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* $Id: lame.h,v 1.192 2017/08/31 14:14:46 robert Exp $ */
+
+#ifndef LAME_LAME_H
+#define LAME_LAME_H
+
+/* for size_t typedef */
+#include <stddef.h>
+/* for va_list typedef */
+#include <stdarg.h>
+/* for FILE typedef, TODO: remove when removing lame_mp3_tags_fid */
+#include <stdio.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef void (*lame_report_function)(const char *format, va_list ap);
+
+#if defined(WIN32) || defined(_WIN32)
+#undef CDECL
+#define CDECL __cdecl
+#else
+#define CDECL
+#endif
+
+#define DEPRECATED_OR_OBSOLETE_CODE_REMOVED 1
+
+typedef enum vbr_mode_e {
+  vbr_off=0,
+  vbr_mt,               /* obsolete, same as vbr_mtrh */
+  vbr_rh,
+  vbr_abr,
+  vbr_mtrh,
+  vbr_max_indicator,    /* Don't use this! It's used for sanity checks.       */
+  vbr_default=vbr_mtrh    /* change this to change the default VBR mode of LAME */
+} vbr_mode;
+
+
+/* MPEG modes */
+typedef enum MPEG_mode_e {
+  STEREO = 0,
+  JOINT_STEREO,
+  DUAL_CHANNEL,   /* LAME doesn't supports this! */
+  MONO,
+  NOT_SET,
+  MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} MPEG_mode;
+
+/* Padding types */
+typedef enum Padding_type_e {
+  PAD_NO = 0,
+  PAD_ALL,
+  PAD_ADJUST,
+  PAD_MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} Padding_type;
+
+
+
+/*presets*/
+typedef enum preset_mode_e {
+    /*values from 8 to 320 should be reserved for abr bitrates*/
+    /*for abr I'd suggest to directly use the targeted bitrate as a value*/
+    ABR_8 = 8,
+    ABR_320 = 320,
+
+    V9 = 410, /*Vx to match Lame and VBR_xx to match FhG*/
+    VBR_10 = 410,
+    V8 = 420,
+    VBR_20 = 420,
+    V7 = 430,
+    VBR_30 = 430,
+    V6 = 440,
+    VBR_40 = 440,
+    V5 = 450,
+    VBR_50 = 450,
+    V4 = 460,
+    VBR_60 = 460,
+    V3 = 470,
+    VBR_70 = 470,
+    V2 = 480,
+    VBR_80 = 480,
+    V1 = 490,
+    VBR_90 = 490,
+    V0 = 500,
+    VBR_100 = 500,
+
+
+
+    /*still there for compatibility*/
+    R3MIX = 1000,
+    STANDARD = 1001,
+    EXTREME = 1002,
+    INSANE = 1003,
+    STANDARD_FAST = 1004,
+    EXTREME_FAST = 1005,
+    MEDIUM = 1006,
+    MEDIUM_FAST = 1007
+} preset_mode;
+
+
+/*asm optimizations*/
+typedef enum asm_optimizations_e {
+    MMX = 1,
+    AMD_3DNOW = 2,
+    SSE = 3
+} asm_optimizations;
+
+
+/* psychoacoustic model */
+typedef enum Psy_model_e {
+    PSY_GPSYCHO = 1,
+    PSY_NSPSYTUNE = 2
+} Psy_model;
+
+
+/* buffer considerations */
+typedef enum buffer_constraint_e {
+    MDB_DEFAULT=0,
+    MDB_STRICT_ISO=1,
+    MDB_MAXIMUM=2
+} buffer_constraint;
+
+
+struct lame_global_struct;
+typedef struct lame_global_struct lame_global_flags;
+typedef lame_global_flags *lame_t;
+
+
+
+
+/***********************************************************************
+ *
+ *  The LAME API
+ *  These functions should be called, in this order, for each
+ *  MP3 file to be encoded.  See the file "API" for more documentation
+ *
+ ***********************************************************************/
+
+
+/*
+ * REQUIRED:
+ * initialize the encoder.  sets default for all encoder parameters,
+ * returns NULL if some malloc()'s failed
+ * otherwise returns pointer to structure needed for all future
+ * API calls.
+ */
+lame_global_flags * CDECL lame_init(void);
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* obsolete version */
+int CDECL lame_init_old(lame_global_flags *);
+#endif
+
+/*
+ * OPTIONAL:
+ * set as needed to override defaults
+ */
+
+/********************************************************************
+ *  input stream description
+ ***********************************************************************/
+/* number of samples.  default = 2^32-1   */
+int CDECL lame_set_num_samples(lame_global_flags *, unsigned long);
+unsigned long CDECL lame_get_num_samples(const lame_global_flags *);
+
+/* input sample rate in Hz.  default = 44100hz */
+int CDECL lame_set_in_samplerate(lame_global_flags *, int);
+int CDECL lame_get_in_samplerate(const lame_global_flags *);
+
+/* number of channels in input stream. default=2  */
+int CDECL lame_set_num_channels(lame_global_flags *, int);
+int CDECL lame_get_num_channels(const lame_global_flags *);
+
+/*
+  scale the input by this amount before encoding.  default=1
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale(lame_global_flags *, float);
+float CDECL lame_get_scale(const lame_global_flags *);
+
+/*
+  scale the channel 0 (left) input by this amount before encoding.  default=1
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_left(lame_global_flags *, float);
+float CDECL lame_get_scale_left(const lame_global_flags *);
+
+/*
+  scale the channel 1 (right) input by this amount before encoding.  default=1
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_right(lame_global_flags *, float);
+float CDECL lame_get_scale_right(const lame_global_flags *);
+
+/*
+  output sample rate in Hz.  default = 0, which means LAME picks best value
+  based on the amount of compression.  MPEG only allows:
+  MPEG1    32, 44.1,   48khz
+  MPEG2    16, 22.05,  24
+  MPEG2.5   8, 11.025, 12
+  (not used by decoding routines)
+*/
+int CDECL lame_set_out_samplerate(lame_global_flags *, int);
+int CDECL lame_get_out_samplerate(const lame_global_flags *);
+
+
+/********************************************************************
+ *  general control parameters
+ ***********************************************************************/
+/* 1=cause LAME to collect data for an MP3 frame analyzer. default=0 */
+int CDECL lame_set_analysis(lame_global_flags *, int);
+int CDECL lame_get_analysis(const lame_global_flags *);
+
+/*
+  1 = write a Xing VBR header frame.
+  default = 1
+  this variable must have been added by a Hungarian notation Windows programmer :-)
+*/
+int CDECL lame_set_bWriteVbrTag(lame_global_flags *, int);
+int CDECL lame_get_bWriteVbrTag(const lame_global_flags *);
+
+/* 1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 */
+int CDECL lame_set_decode_only(lame_global_flags *, int);
+int CDECL lame_get_decode_only(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* 1=encode a Vorbis .ogg file.  default=0 */
+/* DEPRECATED */
+int CDECL lame_set_ogg(lame_global_flags *, int);
+int CDECL lame_get_ogg(const lame_global_flags *);
+#endif
+
+/*
+  internal algorithm selection.  True quality is determined by the bitrate
+  but this variable will effect quality by selecting expensive or cheap algorithms.
+  quality=0..9.  0=best (very slow).  9=worst.
+  recommended:  2     near-best quality, not too slow
+                5     good quality, fast
+                7     ok quality, really fast
+*/
+int CDECL lame_set_quality(lame_global_flags *, int);
+int CDECL lame_get_quality(const lame_global_flags *);
+
+/*
+  mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
+  default: lame picks based on compression ration and input channels
+*/
+int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);
+MPEG_mode CDECL lame_get_mode(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+  mode_automs.  Use a M/S mode with a switching threshold based on
+  compression ratio
+  DEPRECATED
+*/
+int CDECL lame_set_mode_automs(lame_global_flags *, int);
+int CDECL lame_get_mode_automs(const lame_global_flags *);
+#endif
+
+/*
+  force_ms.  Force M/S for all frames.  For testing only.
+  default = 0 (disabled)
+*/
+int CDECL lame_set_force_ms(lame_global_flags *, int);
+int CDECL lame_get_force_ms(const lame_global_flags *);
+
+/* use free_format?  default = 0 (disabled) */
+int CDECL lame_set_free_format(lame_global_flags *, int);
+int CDECL lame_get_free_format(const lame_global_flags *);
+
+/* perform ReplayGain analysis?  default = 0 (disabled) */
+int CDECL lame_set_findReplayGain(lame_global_flags *, int);
+int CDECL lame_get_findReplayGain(const lame_global_flags *);
+
+/* decode on the fly. Search for the peak sample. If the ReplayGain
+ * analysis is enabled then perform the analysis on the decoded data
+ * stream. default = 0 (disabled)
+ * NOTE: if this option is set the build-in decoder should not be used */
+int CDECL lame_set_decode_on_the_fly(lame_global_flags *, int);
+int CDECL lame_get_decode_on_the_fly(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* DEPRECATED: now does the same as lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_input(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as
+   lame_set_decode_on_the_fly() && lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as lame_set_decode_on_the_fly()
+   default = 0 (disabled) */
+int CDECL lame_set_findPeakSample(lame_global_flags *, int);
+int CDECL lame_get_findPeakSample(const lame_global_flags *);
+#endif
+
+/* counters for gapless encoding */
+int CDECL lame_set_nogap_total(lame_global_flags*, int);
+int CDECL lame_get_nogap_total(const lame_global_flags*);
+
+int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);
+int CDECL lame_get_nogap_currentindex(const lame_global_flags*);
+
+
+/*
+ * OPTIONAL:
+ * Set printf like error/debug/message reporting functions.
+ * The second argument has to be a pointer to a function which looks like
+ *   void my_debugf(const char *format, va_list ap)
+ *   {
+ *       (void) vfprintf(stdout, format, ap);
+ *   }
+ * If you use NULL as the value of the pointer in the set function, the
+ * lame buildin function will be used (prints to stderr).
+ * To quiet any output you have to replace the body of the example function
+ * with just "return;" and use it in the set function.
+ */
+int CDECL lame_set_errorf(lame_global_flags *, lame_report_function);
+int CDECL lame_set_debugf(lame_global_flags *, lame_report_function);
+int CDECL lame_set_msgf  (lame_global_flags *, lame_report_function);
+
+
+
+/* set one of brate compression ratio.  default is compression ratio of 11.  */
+int CDECL lame_set_brate(lame_global_flags *, int);
+int CDECL lame_get_brate(const lame_global_flags *);
+int CDECL lame_set_compression_ratio(lame_global_flags *, float);
+float CDECL lame_get_compression_ratio(const lame_global_flags *);
+
+
+int CDECL lame_set_preset( lame_global_flags*  gfp, int );
+int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );
+
+
+
+/********************************************************************
+ *  frame params
+ ***********************************************************************/
+/* mark as copyright.  default=0 */
+int CDECL lame_set_copyright(lame_global_flags *, int);
+int CDECL lame_get_copyright(const lame_global_flags *);
+
+/* mark as original.  default=1 */
+int CDECL lame_set_original(lame_global_flags *, int);
+int CDECL lame_get_original(const lame_global_flags *);
+
+/* error_protection.  Use 2 bytes from each frame for CRC checksum. default=0 */
+int CDECL lame_set_error_protection(lame_global_flags *, int);
+int CDECL lame_get_error_protection(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default) */
+int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);
+Padding_type CDECL lame_get_padding_type(const lame_global_flags *);
+#endif
+
+/* MP3 'private extension' bit  Meaningless.  default=0 */
+int CDECL lame_set_extension(lame_global_flags *, int);
+int CDECL lame_get_extension(const lame_global_flags *);
+
+/* enforce strict ISO compliance.  default=0 */
+int CDECL lame_set_strict_ISO(lame_global_flags *, int);
+int CDECL lame_get_strict_ISO(const lame_global_flags *);
+
+
+/********************************************************************
+ * quantization/noise shaping
+ ***********************************************************************/
+
+/* disable the bit reservoir. For testing only. default=0 */
+int CDECL lame_set_disable_reservoir(lame_global_flags *, int);
+int CDECL lame_get_disable_reservoir(const lame_global_flags *);
+
+/* select a different "best quantization" function. default=0  */
+int CDECL lame_set_quant_comp(lame_global_flags *, int);
+int CDECL lame_get_quant_comp(const lame_global_flags *);
+int CDECL lame_set_quant_comp_short(lame_global_flags *, int);
+int CDECL lame_get_quant_comp_short(const lame_global_flags *);
+
+int CDECL lame_set_experimentalX(lame_global_flags *, int); /* compatibility*/
+int CDECL lame_get_experimentalX(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalY(lame_global_flags *, int);
+int CDECL lame_get_experimentalY(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalZ(lame_global_flags *, int);
+int CDECL lame_get_experimentalZ(const lame_global_flags *);
+
+/* Naoki's psycho acoustic model.  default=0 */
+int CDECL lame_set_exp_nspsytune(lame_global_flags *, int);
+int CDECL lame_get_exp_nspsytune(const lame_global_flags *);
+
+void CDECL lame_set_msfix(lame_global_flags *, double);
+float CDECL lame_get_msfix(const lame_global_flags *);
+
+
+/********************************************************************
+ * VBR control
+ ***********************************************************************/
+/* Types of VBR.  default = vbr_off = CBR */
+int CDECL lame_set_VBR(lame_global_flags *, vbr_mode);
+vbr_mode CDECL lame_get_VBR(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest  */
+int CDECL lame_set_VBR_q(lame_global_flags *, int);
+int CDECL lame_get_VBR_q(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest, Range [0,...,10[  */
+int CDECL lame_set_VBR_quality(lame_global_flags *, float);
+float CDECL lame_get_VBR_quality(const lame_global_flags *);
+
+/* Ignored except for VBR=vbr_abr (ABR mode) */
+int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_min_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_max_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);
+
+/*
+  1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
+  analog silence
+*/
+int CDECL lame_set_VBR_hard_min(lame_global_flags *, int);
+int CDECL lame_get_VBR_hard_min(const lame_global_flags *);
+
+/* for preset */
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+int CDECL lame_set_preset_expopts(lame_global_flags *, int);
+#endif
+
+/********************************************************************
+ * Filtering control
+ ***********************************************************************/
+/* freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_lowpassfreq(lame_global_flags *, int);
+int CDECL lame_get_lowpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_lowpasswidth(lame_global_flags *, int);
+int CDECL lame_get_lowpasswidth(const lame_global_flags *);
+
+/* freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_highpassfreq(lame_global_flags *, int);
+int CDECL lame_get_highpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_highpasswidth(lame_global_flags *, int);
+int CDECL lame_get_highpasswidth(const lame_global_flags *);
+
+
+/********************************************************************
+ * psycho acoustics and other arguments which you should not change
+ * unless you know what you are doing
+ ***********************************************************************/
+
+/* only use ATH for masking */
+int CDECL lame_set_ATHonly(lame_global_flags *, int);
+int CDECL lame_get_ATHonly(const lame_global_flags *);
+
+/* only use ATH for short blocks */
+int CDECL lame_set_ATHshort(lame_global_flags *, int);
+int CDECL lame_get_ATHshort(const lame_global_flags *);
+
+/* disable ATH */
+int CDECL lame_set_noATH(lame_global_flags *, int);
+int CDECL lame_get_noATH(const lame_global_flags *);
+
+/* select ATH formula */
+int CDECL lame_set_ATHtype(lame_global_flags *, int);
+int CDECL lame_get_ATHtype(const lame_global_flags *);
+
+/* lower ATH by this many db */
+int CDECL lame_set_ATHlower(lame_global_flags *, float);
+float CDECL lame_get_ATHlower(const lame_global_flags *);
+
+/* select ATH adaptive adjustment type */
+int CDECL lame_set_athaa_type( lame_global_flags *, int);
+int CDECL lame_get_athaa_type( const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* select the loudness approximation used by the ATH adaptive auto-leveling  */
+int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);
+int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);
+#endif
+
+/* adjust (in dB) the point below which adaptive ATH level adjustment occurs */
+int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);
+float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* OBSOLETE: predictability limit (ISO tonality formula) */
+int CDECL lame_set_cwlimit(lame_global_flags *, int);
+int CDECL lame_get_cwlimit(const lame_global_flags *);
+#endif
+
+/*
+  allow blocktypes to differ between channels?
+  default: 0 for jstereo, 1 for stereo
+*/
+int CDECL lame_set_allow_diff_short(lame_global_flags *, int);
+int CDECL lame_get_allow_diff_short(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_useTemporal(lame_global_flags *, int);
+int CDECL lame_get_useTemporal(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_interChRatio(lame_global_flags *, float);
+float CDECL lame_get_interChRatio(const lame_global_flags *);
+
+/* disable short blocks */
+int CDECL lame_set_no_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_no_short_blocks(const lame_global_flags *);
+
+/* force short blocks */
+int CDECL lame_set_force_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_force_short_blocks(const lame_global_flags *);
+
+/* Input PCM is emphased PCM (for instance from one of the rarely
+   emphased CDs), it is STRONGLY not recommended to use this, because
+   psycho does not take it into account, and last but not least many decoders
+   ignore these bits */
+int CDECL lame_set_emphasis(lame_global_flags *, int);
+int CDECL lame_get_emphasis(const lame_global_flags *);
+
+
+
+/************************************************************************/
+/* internal variables, cannot be set...                                 */
+/* provided because they may be of use to calling application           */
+/************************************************************************/
+/* version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)     */
+int CDECL lame_get_version(const lame_global_flags *);
+
+/* encoder delay   */
+int CDECL lame_get_encoder_delay(const lame_global_flags *);
+
+/*
+  padding appended to the input to make sure decoder can fully decode
+  all input.  Note that this value can only be calculated during the
+  call to lame_encoder_flush().  Before lame_encoder_flush() has
+  been called, the value of encoder_padding = 0.
+*/
+int CDECL lame_get_encoder_padding(const lame_global_flags *);
+
+/* size of MPEG frame */
+int CDECL lame_get_framesize(const lame_global_flags *);
+
+/* number of PCM samples buffered, but not yet encoded to mp3 data. */
+int CDECL lame_get_mf_samples_to_encode( const lame_global_flags*  gfp );
+
+/*
+  size (bytes) of mp3 data buffered, but not yet encoded.
+  this is the number of bytes which would be output by a call to
+  lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
+  more bytes than this because it will encode the reamining buffered
+  PCM samples before flushing the mp3 buffers.
+*/
+int CDECL lame_get_size_mp3buffer( const lame_global_flags*  gfp );
+
+/* number of frames encoded so far */
+int CDECL lame_get_frameNum(const lame_global_flags *);
+
+/*
+  lame's estimate of the total number of frames to be encoded
+   only valid if calling program set num_samples
+*/
+int CDECL lame_get_totalframes(const lame_global_flags *);
+
+/* RadioGain value. Multiplied by 10 and rounded to the nearest. */
+int CDECL lame_get_RadioGain(const lame_global_flags *);
+
+/* AudiophileGain value. Multipled by 10 and rounded to the nearest. */
+int CDECL lame_get_AudiophileGain(const lame_global_flags *);
+
+/* the peak sample */
+float CDECL lame_get_PeakSample(const lame_global_flags *);
+
+/* Gain change required for preventing clipping. The value is correct only if
+   peak sample searching was enabled. If negative then the waveform
+   already does not clip. The value is multiplied by 10 and rounded up. */
+int CDECL lame_get_noclipGainChange(const lame_global_flags *);
+
+/* user-specified scale factor required for preventing clipping. Value is
+   correct only if peak sample searching was enabled and no user-specified
+   scaling was performed. If negative then either the waveform already does
+   not clip or the value cannot be determined */
+float CDECL lame_get_noclipScale(const lame_global_flags *);
+
+/* returns the limit of PCM samples, which one can pass in an encode call
+   under the constrain of a provided buffer of size buffer_size */
+int CDECL lame_get_maximum_number_of_samples(lame_t gfp, size_t buffer_size);
+
+
+
+
+/*
+ * REQUIRED:
+ * sets more internal configuration based on data provided above.
+ * returns -1 if something failed.
+ */
+int CDECL lame_init_params(lame_global_flags *);
+
+
+/*
+ * OPTIONAL:
+ * get the version number, in a string. of the form:
+ * "3.63 (beta)" or just "3.63".
+ */
+const char*  CDECL get_lame_version       ( void );
+const char*  CDECL get_lame_short_version ( void );
+const char*  CDECL get_lame_very_short_version ( void );
+const char*  CDECL get_psy_version        ( void );
+const char*  CDECL get_lame_url           ( void );
+const char*  CDECL get_lame_os_bitness    ( void );
+
+/*
+ * OPTIONAL:
+ * get the version numbers in numerical form.
+ */
+typedef struct {
+    /* generic LAME version */
+    int major;
+    int minor;
+    int alpha;               /* 0 if not an alpha version                  */
+    int beta;                /* 0 if not a beta version                    */
+
+    /* version of the psy model */
+    int psy_major;
+    int psy_minor;
+    int psy_alpha;           /* 0 if not an alpha version                  */
+    int psy_beta;            /* 0 if not a beta version                    */
+
+    /* compile time features */
+    const char *features;    /* Don't make assumptions about the contents! */
+} lame_version_t;
+void CDECL get_lame_version_numerical(lame_version_t *);
+
+
+/*
+ * OPTIONAL:
+ * print internal lame configuration to message handler
+ */
+void CDECL lame_print_config(const lame_global_flags*  gfp);
+
+void CDECL lame_print_internals( const lame_global_flags *gfp);
+
+
+/*
+ * input pcm data, output (maybe) mp3 frames.
+ * This routine handles all buffering, resampling and filtering for you.
+ *
+ * return code     number of bytes output in mp3buf. Can be 0
+ *                 -1:  mp3buf was too small
+ *                 -2:  malloc() problem
+ *                 -3:  lame_init_params() not called
+ *                 -4:  psycho acoustic problems
+ *
+ * The required mp3buf_size can be computed from num_samples,
+ * samplerate and encoding rate, but here is a worst case estimate:
+ *
+ * mp3buf_size in bytes = 1.25*num_samples + 7200
+ *
+ * I think a tighter bound could be:  (mt, March 2000)
+ * MPEG1:
+ *    num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
+ * MPEG2:
+ *    num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
+ *
+ * but test first if you use that!
+ *
+ * set mp3buf_size = 0 and LAME will not check if mp3buf_size is
+ * large enough.
+ *
+ * NOTE:
+ * if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
+ * will be averaged into the L channel before encoding only the L channel
+ * This will overwrite the data in buffer_l[] and buffer_r[].
+ *
+*/
+int CDECL lame_encode_buffer (
+        lame_global_flags*  gfp,           /* global context handle         */
+        const short int     buffer_l [],   /* PCM data for left channel     */
+        const short int     buffer_r [],   /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/*
+ * as above, but input has L & R channel data interleaved.
+ * NOTE:
+ * num_samples = number of samples in the L (or R)
+ * channel, not the total number of samples in pcm[]
+ */
+int CDECL lame_encode_buffer_interleaved(
+        lame_global_flags*  gfp,           /* global context handlei        */
+        short int           pcm[],         /* PCM data for left and right
+                                              channel, interleaved          */
+        int                 num_samples,   /* number of samples per channel,
+                                              _not_ number of samples in
+                                              pcm[]                         */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        int                 mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+/* as lame_encode_buffer, but for 'float's.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ */
+int CDECL lame_encode_buffer_float(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const float         pcm_l [],      /* PCM data for left channel     */
+        const float         pcm_r [],      /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* as lame_encode_buffer, but for 'float's.
+ * !! NOTE: !! data must be scaled to +/- 1 full scale
+ */
+int CDECL lame_encode_buffer_ieee_float(
+        lame_t          gfp,
+        const float     pcm_l [],          /* PCM data for left channel     */
+        const float     pcm_r [],          /* PCM data for right channel    */
+        const int       nsamples,
+        unsigned char * mp3buf,
+        const int       mp3buf_size);
+int CDECL lame_encode_buffer_interleaved_ieee_float(
+        lame_t          gfp,
+        const float     pcm[],             /* PCM data for left and right
+                                              channel, interleaved          */
+        const int       nsamples,
+        unsigned char * mp3buf,
+        const int       mp3buf_size);
+
+/* as lame_encode_buffer, but for 'double's.
+ * !! NOTE: !! data must be scaled to +/- 1 full scale
+ */
+int CDECL lame_encode_buffer_ieee_double(
+        lame_t          gfp,
+        const double    pcm_l [],          /* PCM data for left channel     */
+        const double    pcm_r [],          /* PCM data for right channel    */
+        const int       nsamples,
+        unsigned char * mp3buf,
+        const int       mp3buf_size);
+int CDECL lame_encode_buffer_interleaved_ieee_double(
+        lame_t          gfp,
+        const double    pcm[],             /* PCM data for left and right
+                                              channel, interleaved          */
+        const int       nsamples,
+        unsigned char * mp3buf,
+        const int       mp3buf_size);
+
+/* as lame_encode_buffer, but for long's
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ *
+ * This scaling was a mistake (doesn't allow one to exploit full
+ * precision of type 'long'.  Use lame_encode_buffer_long2() instead.
+ *
+ */
+int CDECL lame_encode_buffer_long(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* Same as lame_encode_buffer_long(), but with correct scaling.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * type 'long'.   Data should be in the range:  +/- 2^(8*size(long)-1)
+ *
+ */
+int CDECL lame_encode_buffer_long2(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* as lame_encode_buffer, but for int's
+ * !! NOTE: !! input should be scaled to the maximum range of 'int'
+ * If int is 4 bytes, then the values should range from
+ * +/- 2147483648.
+ *
+ * This routine does not (and cannot, without loosing precision) use
+ * the same scaling as the rest of the lame_encode_buffer() routines.
+ *
+ */
+int CDECL lame_encode_buffer_int(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const int      buffer_l [],       /* PCM data for left channel     */
+        const int      buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/*
+ * as above, but for interleaved data.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * type 'int32_t'.   Data should be in the range:  +/- 2^(8*size(int32_t)-1)
+ * NOTE:
+ * num_samples = number of samples in the L (or R)
+ * channel, not the total number of samples in pcm[]
+ */
+int
+lame_encode_buffer_interleaved_int(
+        lame_t          gfp,
+        const int       pcm [],            /* PCM data for left and right
+                                              channel, interleaved          */
+        const int       nsamples,          /* number of samples per channel,
+                                              _not_ number of samples in
+                                              pcm[]                         */
+        unsigned char*  mp3buf,            /* pointer to encoded MP3 stream */
+        const int       mp3buf_size );     /* number of valid octets in this
+                                              stream                        */
+
+
+
+/*
+ * REQUIRED:
+ * lame_encode_flush will flush the intenal PCM buffers, padding with
+ * 0's to make sure the final frame is complete, and then flush
+ * the internal MP3 buffers, and thus may return a
+ * final few mp3 frames.  'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * will also write id3v1 tags (if any) into the bitstream
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * lame_encode_flush_nogap will flush the internal mp3 buffers and pad
+ * the last frame with ancillary data so it is a complete mp3 frame.
+ *
+ * 'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * After a call to this routine, the outputed mp3 data is complete, but
+ * you may continue to encode new PCM samples and write future mp3 data
+ * to a different file.  The two mp3 files will play back with no gaps
+ * if they are concatenated together.
+ *
+ * This routine will NOT write id3v1 tags into the bitstream.
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush_nogap(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * Normally, this is called by lame_init_params().  It writes id3v2 and
+ * Xing headers into the front of the bitstream, and sets frame counters
+ * and bitrate histogram data to 0.  You can also call this after
+ * lame_encode_flush_nogap().
+ */
+int CDECL lame_init_bitstream(
+        lame_global_flags *  gfp);    /* global context handle                 */
+
+
+
+/*
+ * OPTIONAL:    some simple statistics
+ * a bitrate histogram to visualize the distribution of used frame sizes
+ * a stereo mode histogram to visualize the distribution of used stereo
+ *   modes, useful in joint-stereo mode only
+ *   0: LR    left-right encoded
+ *   1: LR-I  left-right and intensity encoded (currently not supported)
+ *   2: MS    mid-side encoded
+ *   3: MS-I  mid-side and intensity encoded (currently not supported)
+ *
+ * attention: don't call them after lame_encode_finish
+ * suggested: lame_encode_flush -> lame_*_hist -> lame_close
+ */
+
+void CDECL lame_bitrate_hist(
+        const lame_global_flags * gfp,
+        int bitrate_count[14] );
+void CDECL lame_bitrate_kbps(
+        const lame_global_flags * gfp,
+        int bitrate_kbps [14] );
+void CDECL lame_stereo_mode_hist(
+        const lame_global_flags * gfp,
+        int stereo_mode_count[4] );
+
+void CDECL lame_bitrate_stereo_mode_hist (
+        const lame_global_flags * gfp,
+        int bitrate_stmode_count[14][4] );
+
+void CDECL lame_block_type_hist (
+        const lame_global_flags * gfp,
+        int btype_count[6] );
+
+void CDECL lame_bitrate_block_type_hist (
+        const lame_global_flags * gfp,
+        int bitrate_btype_count[14][6] );
+
+#if (DEPRECATED_OR_OBSOLETE_CODE_REMOVED && 0)
+#else
+/*
+ * OPTIONAL:
+ * lame_mp3_tags_fid will rewrite a Xing VBR tag to the mp3 file with file
+ * pointer fid.  These calls perform forward and backwards seeks, so make
+ * sure fid is a real file.  Make sure lame_encode_flush has been called,
+ * and all mp3 data has been written to the file before calling this
+ * function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME because
+ * the output is not a regular file, this call does nothing
+ * NOTE:
+ * LAME wants to read from the file to skip an optional ID3v2 tag, so
+ * make sure you opened the file for writing and reading.
+ * NOTE:
+ * You can call lame_get_lametag_frame instead, if you want to insert
+ * the lametag yourself.
+*/
+void CDECL lame_mp3_tags_fid(lame_global_flags *, FILE* fid);
+#endif
+
+/*
+ * OPTIONAL:
+ * lame_get_lametag_frame copies the final LAME-tag into 'buffer'.
+ * The function returns the number of bytes copied into buffer, or
+ * the required buffer size, if the provided buffer is too small.
+ * Function failed, if the return value is larger than 'size'!
+ * Make sure lame_encode flush has been called before calling this function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME,
+ * this call does nothing and returns 0.
+ * NOTE:
+ * LAME inserted an empty frame in the beginning of mp3 audio data,
+ * which you have to replace by the final LAME-tag frame after encoding.
+ * In case there is no ID3v2 tag, usually this frame will be the very first
+ * data in your mp3 file. If you put some other leading data into your
+ * file, you'll have to do some bookkeeping about where to write this buffer.
+ */
+size_t CDECL lame_get_lametag_frame(
+        const lame_global_flags *, unsigned char* buffer, size_t size);
+
+/*
+ * REQUIRED:
+ * final call to free all remaining buffers
+ */
+int  CDECL lame_close (lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+ * OBSOLETE:
+ * lame_encode_finish combines lame_encode_flush() and lame_close() in
+ * one call.  However, once this call is made, the statistics routines
+ * will no longer work because the data will have been cleared, and
+ * lame_mp3_tags_fid() cannot be called to add data to the VBR header
+ */
+int CDECL lame_encode_finish(
+        lame_global_flags*  gfp,
+        unsigned char*      mp3buf,
+        int                 size );
+#endif
+
+
+
+
+
+
+/*********************************************************************
+ *
+ * decoding
+ *
+ * a simple interface to mpglib, part of mpg123, is also included if
+ * libmp3lame is compiled with HAVE_MPGLIB
+ *
+ *********************************************************************/
+
+struct hip_global_struct;
+typedef struct hip_global_struct hip_global_flags;
+typedef hip_global_flags *hip_t;
+
+
+typedef struct {
+  int header_parsed;   /* 1 if header was parsed and following data was
+                          computed                                       */
+  int stereo;          /* number of channels                             */
+  int samplerate;      /* sample rate                                    */
+  int bitrate;         /* bitrate                                        */
+  int mode;            /* mp3 frame type                                 */
+  int mode_ext;        /* mp3 frame type                                 */
+  int framesize;       /* number of samples per mp3 frame                */
+
+  /* this data is only computed if mpglib detects a Xing VBR header */
+  unsigned long nsamp; /* number of samples in mp3 file.                 */
+  int totalframes;     /* total number of frames in mp3 file             */
+
+  /* this data is not currently computed by the mpglib routines */
+  int framenum;        /* frames decoded counter                         */
+} mp3data_struct;
+
+/* required call to initialize decoder */
+hip_t CDECL hip_decode_init(void);
+
+/* cleanup call to exit decoder  */
+int CDECL hip_decode_exit(hip_t gfp);
+
+/* HIP reporting functions */
+void CDECL hip_set_errorf(hip_t gfp, lame_report_function f);
+void CDECL hip_set_debugf(hip_t gfp, lame_report_function f);
+void CDECL hip_set_msgf  (hip_t gfp, lame_report_function f);
+
+/*********************************************************************
+ * input 1 mp3 frame, output (maybe) pcm data.
+ *
+ *  nout = hip_decode(hip, mp3buf,len,pcm_l,pcm_r);
+ *
+ * input:
+ *    len          :  number of bytes of mp3 data in mp3buf
+ *    mp3buf[len]  :  mp3 data to be decoded
+ *
+ * output:
+ *    nout:  -1    : decoding error
+ *            0    : need more data before we can complete the decode
+ *           >0    : returned 'nout' samples worth of data in pcm_l,pcm_r
+ *    pcm_l[nout]  : left channel data
+ *    pcm_r[nout]  : right channel data
+ *
+ *********************************************************************/
+int CDECL hip_decode( hip_t           gfp
+                    , unsigned char * mp3buf
+                    , size_t          len
+                    , short           pcm_l[]
+                    , short           pcm_r[]
+                    );
+
+/* same as hip_decode, and also returns mp3 header data */
+int CDECL hip_decode_headers( hip_t           gfp
+                            , unsigned char*  mp3buf
+                            , size_t          len
+                            , short           pcm_l[]
+                            , short           pcm_r[]
+                            , mp3data_struct* mp3data
+                            );
+
+/* same as hip_decode, but returns at most one frame */
+int CDECL hip_decode1( hip_t          gfp
+                     , unsigned char* mp3buf
+                     , size_t         len
+                     , short          pcm_l[]
+                     , short          pcm_r[]
+                     );
+
+/* same as hip_decode1, but returns at most one frame and mp3 header data */
+int CDECL hip_decode1_headers( hip_t           gfp
+                             , unsigned char*  mp3buf
+                             , size_t          len
+                             , short           pcm_l[]
+                             , short           pcm_r[]
+                             , mp3data_struct* mp3data
+                             );
+
+/* same as hip_decode1_headers, but also returns enc_delay and enc_padding
+   from VBR Info tag, (-1 if no info tag was found) */
+int CDECL hip_decode1_headersB( hip_t gfp
+                              , unsigned char*   mp3buf
+                              , size_t           len
+                              , short            pcm_l[]
+                              , short            pcm_r[]
+                              , mp3data_struct*  mp3data
+                              , int             *enc_delay
+                              , int             *enc_padding
+                              );
+
+
+
+/* OBSOLETE:
+ * lame_decode... functions are there to keep old code working
+ * but it is strongly recommended to replace calls by hip_decode...
+ * function calls, see above.
+ */
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+int CDECL lame_decode_init(void);
+int CDECL lame_decode(
+        unsigned char *  mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[] );
+int CDECL lame_decode_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1(
+        unsigned char*  mp3buf,
+        int             len,
+        short           pcm_l[],
+        short           pcm_r[] );
+int CDECL lame_decode1_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1_headersB(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data,
+        int              *enc_delay,
+        int              *enc_padding );
+int CDECL lame_decode_exit(void);
+
+#endif /* obsolete lame_decode API calls */
+
+
+/*********************************************************************
+ *
+ * id3tag stuff
+ *
+ *********************************************************************/
+
+/*
+ * id3tag.h -- Interface to write ID3 version 1 and 2 tags.
+ *
+ * Copyright (C) 2000 Don Melton.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* utility to obtain alphabetically sorted list of genre names with numbers */
+void CDECL id3tag_genre_list(
+        void (*handler)(int, const char *, void *),
+        void*  cookie);
+
+void CDECL id3tag_init     (lame_t gfp);
+
+/* force addition of version 2 tag */
+void CDECL id3tag_add_v2   (lame_t gfp);
+
+/* add only a version 1 tag */
+void CDECL id3tag_v1_only  (lame_t gfp);
+
+/* add only a version 2 tag */
+void CDECL id3tag_v2_only  (lame_t gfp);
+
+/* pad version 1 tag with spaces instead of nulls */
+void CDECL id3tag_space_v1 (lame_t gfp);
+
+/* pad version 2 tag with extra 128 bytes */
+void CDECL id3tag_pad_v2   (lame_t gfp);
+
+/* pad version 2 tag with extra n bytes */
+void CDECL id3tag_set_pad  (lame_t gfp, size_t n);
+
+void CDECL id3tag_set_title(lame_t gfp, const char* title);
+void CDECL id3tag_set_artist(lame_t gfp, const char* artist);
+void CDECL id3tag_set_album(lame_t gfp, const char* album);
+void CDECL id3tag_set_year(lame_t gfp, const char* year);
+void CDECL id3tag_set_comment(lame_t gfp, const char* comment);
+            
+/* return -1 result if track number is out of ID3v1 range
+                    and ignored for ID3v1 */
+int CDECL id3tag_set_track(lame_t gfp, const char* track);
+
+/* return non-zero result if genre name or number is invalid
+  result 0: OK
+  result -1: genre number out of range
+  result -2: no valid ID3v1 genre name, mapped to ID3v1 'Other'
+             but taken as-is for ID3v2 genre tag */
+int CDECL id3tag_set_genre(lame_t gfp, const char* genre);
+
+/* return non-zero result if field name is invalid */
+int CDECL id3tag_set_fieldvalue(lame_t gfp, const char* fieldvalue);
+
+/* return non-zero result if image type is invalid */
+int CDECL id3tag_set_albumart(lame_t gfp, const char* image, size_t size);
+
+/* lame_get_id3v1_tag copies ID3v1 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v1 tag.
+ */
+size_t CDECL lame_get_id3v1_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* lame_get_id3v2_tag copies ID3v2 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v2 tag.
+ */
+size_t CDECL lame_get_id3v2_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* normaly lame_init_param writes ID3v2 tags into the audio stream
+ * Call lame_set_write_id3tag_automatic(gfp, 0) before lame_init_param
+ * to turn off this behaviour and get ID3v2 tag with above function
+ * write it yourself into your file.
+ */
+void CDECL lame_set_write_id3tag_automatic(lame_global_flags * gfp, int);
+int CDECL lame_get_write_id3tag_automatic(lame_global_flags const* gfp);
+
+/* experimental */
+int CDECL id3tag_set_textinfo_latin1(lame_t gfp, char const *id, char const *text);
+
+/* experimental */
+int CDECL id3tag_set_comment_latin1(lame_t gfp, char const *lang, char const *desc, char const *text);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* experimental */
+int CDECL id3tag_set_textinfo_ucs2(lame_t gfp, char const *id, unsigned short const *text);
+
+/* experimental */
+int CDECL id3tag_set_comment_ucs2(lame_t gfp, char const *lang,
+                                  unsigned short const *desc, unsigned short const *text);
+
+/* experimental */
+int CDECL id3tag_set_fieldvalue_ucs2(lame_t gfp, const unsigned short *fieldvalue);
+#endif
+
+/* experimental */
+int CDECL id3tag_set_fieldvalue_utf16(lame_t gfp, const unsigned short *fieldvalue);
+
+/* experimental */
+int CDECL id3tag_set_textinfo_utf16(lame_t gfp, char const *id, unsigned short const *text);
+
+/* experimental */
+int CDECL id3tag_set_comment_utf16(lame_t gfp, char const *lang, unsigned short const *desc, unsigned short const *text);
+
+
+/***********************************************************************
+*
+*  list of valid bitrates [kbps] & sample frequencies [Hz].
+*  first index: 0: MPEG-2   values  (sample frequencies 16...24 kHz)
+*               1: MPEG-1   values  (sample frequencies 32...48 kHz)
+*               2: MPEG-2.5 values  (sample frequencies  8...12 kHz)
+***********************************************************************/
+
+extern const int     bitrate_table    [3][16];
+extern const int     samplerate_table [3][ 4];
+
+/* access functions for use in DLL, global vars are not exported */
+int CDECL lame_get_bitrate(int mpeg_version, int table_index);
+int CDECL lame_get_samplerate(int mpeg_version, int table_index);
+
+
+/* maximum size of albumart image (128KB), which affects LAME_MAXMP3BUFFER
+   as well since lame_encode_buffer() also returns ID3v2 tag data */
+#define LAME_MAXALBUMART    (128 * 1024)
+
+/* maximum size of mp3buffer needed if you encode at most 1152 samples for
+   each call to lame_encode_buffer.  see lame_encode_buffer() below  
+   (LAME_MAXMP3BUFFER is now obsolete)  */
+#define LAME_MAXMP3BUFFER   (16384 + LAME_MAXALBUMART)
+
+
+typedef enum {
+    LAME_OKAY             =   0,
+    LAME_NOERROR          =   0,
+    LAME_GENERICERROR     =  -1,
+    LAME_NOMEM            = -10,
+    LAME_BADBITRATE       = -11,
+    LAME_BADSAMPFREQ      = -12,
+    LAME_INTERNALERROR    = -13,
+
+    FRONTEND_READERROR    = -80,
+    FRONTEND_WRITEERROR   = -81,
+    FRONTEND_FILETOOLARGE = -82
+
+} lame_errorcodes_t;
+
+#if defined(__cplusplus)
+}
+#endif
+#endif /* LAME_LAME_H */
+
diff -Nura v4l2rtspserver_imp_tools/inc/loguru.hpp v4l2rtspserver-master/inc/loguru.hpp
--- v4l2rtspserver_imp_tools/inc/loguru.hpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/loguru.hpp	2019-02-03 20:24:23.647172000 +0100
@@ -0,0 +1,3037 @@
+/*
+Loguru logging library for C++, by Emil Ernerfeldt.
+www.github.com/emilk/loguru
+If you find Loguru useful, please let me know on twitter or in a mail!
+Twitter: @ernerfeldt
+Mail:    emil.ernerfeldt@gmail.com
+Website: www.ilikebigbits.com
+
+# License
+	This software is in the public domain. Where that dedication is not
+	recognized, you are granted a perpetual, irrevocable license to copy
+	and modify this file as you see fit.
+
+# Inspiration
+	Much of Loguru was inspired by GLOG, https://code.google.com/p/google-glog/.
+	The whole "single header" and public domain is fully due Sean T. Barrett
+	and his wonderful stb libraries at https://github.com/nothings/stb.
+
+# Version history
+	* Version 0.1.0 - 2015-03-22 - Works great on Mac.
+	* Version 0.2.0 - 2015-09-17 - Removed the only dependency.
+	* Version 0.3.0 - 2015-10-02 - Drop-in replacement for most of GLOG
+	* Version 0.4.0 - 2015-10-07 - Single-file!
+	* Version 0.5.0 - 2015-10-17 - Improved file logging
+	* Version 0.6.0 - 2015-10-24 - Add stack traces
+	* Version 0.7.0 - 2015-10-27 - Signals
+	* Version 0.8.0 - 2015-10-30 - Color logging.
+	* Version 0.9.0 - 2015-11-26 - ABORT_S and proper handling of FATAL
+	* Version 1.0.0 - 2016-02-14 - ERROR_CONTEXT
+	* Version 1.1.0 - 2016-02-19 - -v OFF, -v INFO etc
+	* Version 1.1.1 - 2016-02-20 - textprintf vs strprintf
+	* Version 1.1.2 - 2016-02-22 - Remove g_alsologtostderr
+	* Version 1.1.3 - 2016-02-29 - ERROR_CONTEXT as linked list
+	* Version 1.2.0 - 2016-03-19 - Add get_thread_name()
+	* Version 1.2.1 - 2016-03-20 - Minor fixes
+	* Version 1.2.2 - 2016-03-29 - Fix issues with set_fatal_handler throwing an exception
+	* Version 1.2.3 - 2016-05-16 - Log current working directory in loguru::init().
+	* Version 1.2.4 - 2016-05-18 - Custom replacement for -v in loguru::init() by bjoernpollex
+	* Version 1.2.5 - 2016-05-18 - Add ability to print ERROR_CONTEXT of parent thread.
+	* Version 1.2.6 - 2016-05-19 - Bug fix regarding VLOG verbosity argument lacking ().
+	* Version 1.2.7 - 2016-05-23 - Fix PATH_MAX problem.
+	* Version 1.2.8 - 2016-05-26 - Add shutdown() and remove_all_callbacks()
+	* Version 1.2.9 - 2016-06-09 - Use a monotonic clock for uptime.
+	* Version 1.3.0 - 2016-07-20 - Fix issues with callback flush/close not being called.
+	* Version 1.3.1 - 2016-07-20 - Add LOGURU_UNSAFE_SIGNAL_HANDLER to toggle stacktrace on signals.
+	* Version 1.3.2 - 2016-07-20 - Add loguru::arguments()
+	* Version 1.4.0 - 2016-09-15 - Semantic versioning + add loguru::create_directories
+	* Version 1.4.1 - 2016-09-29 - Customize formating with LOGURU_FILENAME_WIDTH
+	* Version 1.5.0 - 2016-12-22 - LOGURU_USE_FMTLIB by kolis and LOGURU_WITH_FILEABS by scinart
+	* Version 1.5.1 - 2017-08-08 - Terminal colors on Windows 10 thanks to looki
+	* Version 1.6.0 - 2018-01-03 - Add LOGURU_RTTI and LOGURU_STACKTRACES settings
+	* Version 1.7.0 - 2018-01-03 - Add ability to turn off the preamble with loguru::g_preamble
+	* Version 1.7.1 - 2018-04-05 - Add function get_fatal_handler
+	* Version 1.7.2 - 2018-04-22 - Fix a bug where large file names could cause stack corruption (thanks @ccamporesi)
+	* Version 1.8.0 - 2018-04-23 - Shorten long file names to keep preamble fixed width
+
+# Compiling
+	Just include <loguru.hpp> where you want to use Loguru.
+	Then, in one .cpp file:
+		#define LOGURU_IMPLEMENTATION 1
+		#include <loguru.hpp>
+	Make sure you compile with -std=c++11 -lstdc++ -lpthread -ldl
+
+# Usage
+	#include <loguru.hpp>
+
+	// Optional, but useful to time-stamp the start of the log.
+	// Will also detect verbosity level on command line as -v.
+	loguru::init(argc, argv);
+
+	// Put every log message in "everything.log":
+	loguru::add_file("everything.log", loguru::Append, loguru::Verbosity_MAX);
+
+	// Only log INFO, WARNING, ERROR and FATAL to "latest_readable.log":
+	loguru::add_file("latest_readable.log", loguru::Truncate, loguru::Verbosity_INFO);
+
+	// Only show most relevant things on stderr:
+	loguru::g_stderr_verbosity = 1;
+
+	// Or just go with what Loguru suggests:
+	char log_path[PATH_MAX];
+	loguru::suggest_log_path("~/loguru/", log_path, sizeof(log_path));
+	loguru::add_file(log_path, loguru::FileMode::Truncate, loguru::Verbosity_MAX);
+
+	LOG_SCOPE_F(INFO, "Will indent all log messages within this scope.");
+	LOG_F(INFO, "I'm hungry for some %.3f!", 3.14159);
+	LOG_F(2, "Will only show if verbosity is 2 or higher");
+	VLOG_F(get_log_level(), "Use vlog for dynamic log level (integer in the range 0-9, inclusive)");
+	LOG_IF_F(ERROR, badness, "Will only show if badness happens");
+	auto fp = fopen(filename, "r");
+	CHECK_F(fp != nullptr, "Failed to open file '%s'", filename);
+	CHECK_GT_F(length, 0); // Will print the value of `length` on failure.
+	CHECK_EQ_F(a, b, "You can also supply a custom message, like to print something: %d", a + b);
+
+	// Each function also comes with a version prefixed with D for Debug:
+	DCHECK_F(expensive_check(x)); // Only checked #if LOGURU_DEBUG_CHECKS
+	DLOG_F("Only written in debug-builds");
+
+	// Turn off writing to stderr:
+	loguru::g_stderr_verbosity = loguru::Verbosity_OFF;
+
+	// Turn off writing err/warn in red:
+	loguru::g_colorlogtostderr = false;
+
+	// Throw exceptions instead of aborting on CHECK fails:
+	loguru::set_fatal_handler([](const loguru::Message& message){
+		throw std::runtime_error(std::string(message.prefix) + message.message);
+	});
+
+	If you prefer logging with streams:
+
+	#define LOGURU_WITH_STREAMS 1
+	#include <loguru.hpp>
+	...
+	LOG_S(INFO) << "Look at my custom object: " << a.cross(b);
+	CHECK_EQ_S(pi, 3.14) << "Maybe it is closer to " << M_PI;
+
+	Before including <loguru.hpp> you may optionally want to define the following to 1:
+
+	LOGURU_DEBUG_LOGGING (default 1 #if !NDEBUG, else 0):
+		Enables debug versions of logging statements.
+
+	LOGURU_DEBUG_CHECKS (default 1 #if !NDEBUG, else 0):
+		Enables debug versions of checks.
+
+	LOGURU_REDEFINE_ASSERT (default 0):
+		Redefine "assert" call Loguru version (!NDEBUG only).
+
+	LOGURU_WITH_STREAMS (default 0):
+		Add support for _S versions for all LOG and CHECK functions:
+			LOG_S(INFO) << "My vec3: " << x.cross(y);
+			CHECK_EQ_S(a, b) << "I expected a and b to be the same!";
+		This is off by default to keep down compilation times.
+
+	LOGURU_REPLACE_GLOG (default 0):
+		Make Loguru mimic GLOG as close as possible,
+		including #defining LOG, CHECK, VLOG_IS_ON etc.
+		LOGURU_REPLACE_GLOG implies LOGURU_WITH_STREAMS.
+
+	LOGURU_UNSAFE_SIGNAL_HANDLER (default 1):
+		Make Loguru try to do unsafe but useful things,
+		like printing a stack trace, when catching signals.
+		This may lead to bad things like deadlocks in certain situations.
+
+	LOGURU_USE_FMTLIB (default 0):
+		Use fmtlib formatting. See https://github.com/fmtlib/fmt
+		This will make loguru.hpp depend on <fmt/format.h>
+		You will need to link against `fmtlib` or use the `FMT_HEADER_ONLY` preprocessor definition.
+		Feature by kolis (https://github.com/emilk/loguru/pull/22)
+
+	LOGURU_WITH_FILEABS (default 0):
+		When LOGURU_WITH_FILEABS is defined, a check of file change will be performed on every call to file_log.
+		If the file is moved, or inode changes, file is reopened using the same FileMode as is done by add_file.
+		Such a scheme is useful if you have a daemon program that moves the log file every 24 hours and expects new file to be created.
+		Feature by scinart (https://github.com/emilk/loguru/pull/23).
+
+	LOGURU_STACKTRACES (default 1 on supported platforms):
+		Print stack traces on abort.
+
+	LOGURU_RTTI (try to detect automatically by default):
+		Set to 0 if your platform does not support runtime type information (-fno-rtti).
+
+	You can also configure:
+	loguru::g_flush_interval_ms:
+		If set to zero Loguru will flush on every line (unbuffered mode).
+		Else Loguru will flush outputs every g_flush_interval_ms milliseconds (buffered mode).
+		The default is g_flush_interval_ms=0, i.e. unbuffered mode.
+
+# Notes:
+	* Any arguments to CHECK:s are only evaluated once.
+	* Any arguments to LOG functions or LOG_SCOPE are only evaluated iff the verbosity test passes.
+	* Any arguments to LOG_IF functions are only evaluated if the test passes.
+*/
+#define _GLIBCXX_USE_NANOSLEEP
+
+// Disable all warnings from gcc/clang:
+#if defined(__clang__)
+	#pragma clang system_header
+#elif defined(__GNUC__)
+	#pragma GCC system_header
+#endif
+
+#ifndef LOGURU_HAS_DECLARED_FORMAT_HEADER
+#define LOGURU_HAS_DECLARED_FORMAT_HEADER
+
+// Semantic versioning. Loguru version can be printed with printf("%d.%d.%d", LOGURU_VERSION_MAJOR, LOGURU_VERSION_MINOR, LOGURU_VERSION_PATCH);
+#define LOGURU_VERSION_MAJOR 1
+#define LOGURU_VERSION_MINOR 8
+#define LOGURU_VERSION_PATCH 0
+
+#if defined(_MSC_VER)
+#include <sal.h>	// Needed for _In_z_ etc annotations
+#endif
+
+// ----------------------------------------------------------------------------
+
+#ifndef LOGURU_SCOPE_TEXT_SIZE
+	// Maximum length of text that can be printed by a LOG_SCOPE.
+	// This should be long enough to get most things, but short enough not to clutter the stack.
+	#define LOGURU_SCOPE_TEXT_SIZE 196
+#endif
+
+#ifndef LOGURU_FILENAME_WIDTH
+	// Width of the column containing the file name
+	#define LOGURU_FILENAME_WIDTH 23
+#endif
+
+#ifndef LOGURU_THREADNAME_WIDTH
+	// Width of the column containing the thread name
+	#define LOGURU_THREADNAME_WIDTH 16
+#endif
+
+#ifndef LOGURU_CATCH_SIGABRT
+	// Should Loguru catch SIGABRT to print stack trace etc?
+	#define LOGURU_CATCH_SIGABRT 1
+#endif
+
+#ifndef LOGURU_REDEFINE_ASSERT
+	#define LOGURU_REDEFINE_ASSERT 0
+#endif
+
+#ifndef LOGURU_WITH_STREAMS
+	#define LOGURU_WITH_STREAMS 0
+#endif
+
+#ifndef LOGURU_REPLACE_GLOG
+	#define LOGURU_REPLACE_GLOG 0
+#endif
+
+#if LOGURU_REPLACE_GLOG
+	#undef LOGURU_WITH_STREAMS
+	#define LOGURU_WITH_STREAMS 1
+#endif
+
+#ifndef LOGURU_UNSAFE_SIGNAL_HANDLER
+	#define LOGURU_UNSAFE_SIGNAL_HANDLER 1
+#endif
+
+#if LOGURU_IMPLEMENTATION
+	#undef LOGURU_WITH_STREAMS
+	#define LOGURU_WITH_STREAMS 1
+#endif
+
+#ifndef LOGURU_USE_FMTLIB
+	#define LOGURU_USE_FMTLIB 0
+#endif
+
+#ifndef LOGURU_WITH_FILEABS
+	#define LOGURU_WITH_FILEABS 0
+#endif
+
+#ifndef LOGURU_RTTI
+#if defined(__clang__)
+	#if __has_feature(cxx_rtti)
+		#define LOGURU_RTTI 1
+	#endif
+#elif defined(__GNUG__)
+	#if defined(__GXX_RTTI)
+		#define LOGURU_RTTI 1
+	#endif
+#elif defined(_MSC_VER)
+	#if defined(_CPPRTTI)
+		#define LOGURU_RTTI 1
+	#endif
+#endif
+#endif
+
+// --------------------------------------------------------------------
+// Utility macros
+
+#define LOGURU_CONCATENATE_IMPL(s1, s2) s1 ## s2
+#define LOGURU_CONCATENATE(s1, s2) LOGURU_CONCATENATE_IMPL(s1, s2)
+
+#ifdef __COUNTER__
+#   define LOGURU_ANONYMOUS_VARIABLE(str) LOGURU_CONCATENATE(str, __COUNTER__)
+#else
+#   define LOGURU_ANONYMOUS_VARIABLE(str) LOGURU_CONCATENATE(str, __LINE__)
+#endif
+
+#if defined(__clang__) || defined(__GNUC__)
+	// Helper macro for declaring functions as having similar signature to printf.
+	// This allows the compiler to catch format errors at compile-time.
+	#define LOGURU_PRINTF_LIKE(fmtarg, firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
+	#define LOGURU_FORMAT_STRING_TYPE const char*
+#elif defined(_MSC_VER)
+	#define LOGURU_PRINTF_LIKE(fmtarg, firstvararg)
+	#define LOGURU_FORMAT_STRING_TYPE _In_z_ _Printf_format_string_ const char*
+#else
+	#define LOGURU_PRINTF_LIKE(fmtarg, firstvararg)
+	#define LOGURU_FORMAT_STRING_TYPE const char*
+#endif
+
+// Used to mark log_and_abort for the benefit of the static analyzer and optimizer.
+#if defined(_MSC_VER)
+#define LOGURU_NORETURN __declspec(noreturn)
+#else
+#define LOGURU_NORETURN __attribute__((noreturn))
+#endif
+
+#if defined(_MSC_VER)
+#define LOGURU_PREDICT_FALSE(x) (x)
+#define LOGURU_PREDICT_TRUE(x)  (x)
+#else
+#define LOGURU_PREDICT_FALSE(x) (__builtin_expect(x,     0))
+#define LOGURU_PREDICT_TRUE(x)  (__builtin_expect(!!(x), 1))
+#endif
+
+#if LOGURU_USE_FMTLIB
+	#include <fmt/format.h>
+#endif
+
+// --------------------------------------------------------------------
+
+namespace loguru
+{
+	// Simple RAII ownership of a char*.
+	class Text
+	{
+	public:
+		explicit Text(char* owned_str) : _str(owned_str) {}
+		~Text();
+		Text(Text&& t)
+		{
+			_str = t._str;
+			t._str = nullptr;
+		}
+		Text(Text& t) = delete;
+		Text& operator=(Text& t) = delete;
+		void operator=(Text&& t) = delete;
+
+		const char* c_str() const { return _str; }
+		bool empty() const { return _str == nullptr || *_str == '\0'; }
+
+		char* release()
+		{
+			auto result = _str;
+			_str = nullptr;
+			return result;
+		}
+
+	private:
+		char* _str;
+	};
+
+	// Like printf, but returns the formated text.
+	Text textprintf(LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(1, 2);
+
+	// Overloaded for variadic template matching.
+	Text textprintf();
+
+	using Verbosity = int;
+
+#undef FATAL
+#undef ERROR
+#undef WARNING
+#undef INFO
+#undef MAX
+
+	enum NamedVerbosity : Verbosity
+	{
+		// You may use Verbosity_OFF on g_stderr_verbosity, but for nothing else!
+		Verbosity_OFF     = -9, // Never do LOG_F(OFF)
+
+		// Prefer to use ABORT_F or ABORT_S over LOG_F(FATAL) or LOG_S(FATAL).
+		Verbosity_FATAL   = -3,
+		Verbosity_ERROR   = -2,
+		Verbosity_WARNING = -1,
+
+		// Normal messages. By default written to stderr.
+		Verbosity_INFO    =  0,
+
+		// Same as Verbosity_INFO in every way.
+		Verbosity_0       =  0,
+
+		// Verbosity levels 1-9 are generally not written to stderr, but are written to file.
+		Verbosity_1       = +1,
+		Verbosity_2       = +2,
+		Verbosity_3       = +3,
+		Verbosity_4       = +4,
+		Verbosity_5       = +5,
+		Verbosity_6       = +6,
+		Verbosity_7       = +7,
+		Verbosity_8       = +8,
+		Verbosity_9       = +9,
+
+		// Don not use higher verbosity levels, as that will make grepping log files harder.
+		Verbosity_MAX     = +9,
+	};
+
+	struct Message
+	{
+		// You would generally print a Message by just concating the buffers without spacing.
+		// Optionally, ignore preamble and indentation.
+		Verbosity   verbosity;   // Already part of preamble
+		const char* filename;    // Already part of preamble
+		unsigned    line;        // Already part of preamble
+		const char* preamble;    // Date, time, uptime, thread, file:line, verbosity.
+		const char* indentation; // Just a bunch of spacing.
+		const char* prefix;      // Assertion failure info goes here (or "").
+		const char* message;     // User message goes here.
+	};
+
+	/* Everything with a verbosity equal or greater than g_stderr_verbosity will be
+	written to stderr. You can set this in code or via the -v argument.
+	Set to logurur::Verbosity_OFF to write nothing to stderr.
+	Default is 0, i.e. only log ERROR, WARNING and INFO are written to stderr.
+	*/
+	extern Verbosity g_stderr_verbosity;
+	extern bool      g_colorlogtostderr; // True by default.
+	extern unsigned  g_flush_interval_ms; // 0 (unbuffered) by default.
+	extern bool      g_preamble; // Prefix each log line with date, time etc? True by default.
+
+	// Turn off individual parts of the preamble
+	extern bool      g_preamble_date; // The date field
+	extern bool      g_preamble_time; // The time of the current day
+	extern bool      g_preamble_uptime; // The time since init call
+	extern bool      g_preamble_thread; // The logging thread
+	extern bool      g_preamble_file; // The file from which the log originates from
+	extern bool      g_preamble_verbose; // The verbosity field
+	extern bool      g_preamble_pipe; // The pipe symbol right before the message
+
+	// May not throw!
+	typedef void (*log_handler_t)(void* user_data, const Message& message);
+	typedef void (*close_handler_t)(void* user_data);
+	typedef void (*flush_handler_t)(void* user_data);
+
+	// May throw if that's how you'd like to handle your errors.
+	typedef void (*fatal_handler_t)(const Message& message);
+
+	/*  Should be called from the main thread.
+		You don't *need* to call this, but if you do you get:
+			* Signal handlers installed
+			* Program arguments logged
+			* Working dir logged
+			* Optional -v verbosity flag parsed
+			* Main thread name set to "main thread"
+			* Explanation of the preamble (date, threanmae etc) logged
+
+		loguru::init() will look for arguments meant for loguru and remove them.
+		Arguments meant for loguru are:
+			-v n   Set loguru::g_stderr_verbosity level. Examples:
+				-v 3        Show verbosity level 3 and lower.
+				-v 0        Only show INFO, WARNING, ERROR, FATAL (default).
+				-v INFO     Only show INFO, WARNING, ERROR, FATAL (default).
+				-v WARNING  Only show WARNING, ERROR, FATAL.
+				-v ERROR    Only show ERROR, FATAL.
+				-v FATAL    Only show FATAL.
+				-v OFF      Turn off logging to stderr.
+
+		Tip: You can set g_stderr_verbosity before calling loguru::init.
+		That way you can set the default but have the user override it with the -v flag.
+		Note that -v does not affect file logging (see loguru::add_file).
+
+		You can use something else instead of "-v" via verbosity_flag.
+		You can also set verbosity_flag to nullptr.
+	*/
+	void init(int& argc, char* argv[], const char* verbosity_flag = "-v");
+
+	// Will call remove_all_callbacks(). After calling this, logging will still go to stderr.
+	// You generally don't need to call this.
+	void shutdown();
+
+	// What ~ will be replaced with, e.g. "/home/your_user_name/"
+	const char* home_dir();
+
+	/* Returns the name of the app as given in argv[0] but without leading path.
+	   That is, if argv[0] is "../foo/app" this will return "app".
+	*/
+	const char* argv0_filename();
+
+	// Returns all arguments given to loguru::init(), but escaped with a single space as separator.
+	const char* arguments();
+
+	// Returns the path to the current working dir when loguru::init() was called.
+	const char* current_dir();
+
+	// Returns the part of the path after the last / or \ (if any).
+	const char* filename(const char* path);
+
+	// e.g. "foo/bar/baz.ext" will create the directories "foo/" and "foo/bar/"
+	bool create_directories(const char* file_path_const);
+
+	// Writes date and time with millisecond precision, e.g. "20151017_161503.123"
+	void write_date_time(char* buff, unsigned buff_size);
+
+	// Helper: thread-safe version strerror
+	Text errno_as_text();
+
+	/* Given a prefix of e.g. "~/loguru/" this might return
+	   "/home/your_username/loguru/app_name/20151017_161503.123.log"
+
+	   where "app_name" is a sanitized version of argv[0].
+	*/
+	void suggest_log_path(const char* prefix, char* buff, unsigned buff_size);
+
+	enum FileMode { Truncate, Append };
+
+	/*  Will log to a file at the given path.
+		Any logging message with a verbosity lower or equal to
+		the given verbosity will be included.
+		The function will create all directories in 'path' if needed.
+		If path starts with a ~, it will be replaced with loguru::home_dir()
+		To stop the file logging, just call loguru::remove_callback(path) with the same path.
+	*/
+	bool add_file(const char* path, FileMode mode, Verbosity verbosity);
+
+	/*  Will be called right before abort().
+		You can for instance use this to print custom error messages, or throw an exception.
+		Feel free to call LOG:ing function from this, but not FATAL ones! */
+	void set_fatal_handler(fatal_handler_t handler);
+
+	// Get the current fatal handler, if any. Default value is nullptr.
+	fatal_handler_t get_fatal_handler();
+
+	/*  Will be called on each log messages with a verbosity less or equal to the given one.
+		Useful for displaying messages on-screen in a game, for example.
+		The given on_close is also expected to flush (if desired).
+	*/
+	void add_callback(
+		const char*     id,
+		log_handler_t   callback,
+		void*           user_data,
+		Verbosity       verbosity,
+		close_handler_t on_close = nullptr,
+		flush_handler_t on_flush = nullptr);
+
+	// Returns true iff the callback was found (and removed).
+	bool remove_callback(const char* id);
+
+	// Shut down all file logging and any other callback hooks installed.
+	void remove_all_callbacks();
+
+	// Returns the maximum of g_stderr_verbosity and all file/custom outputs.
+	Verbosity current_verbosity_cutoff();
+
+#if LOGURU_USE_FMTLIB
+	// Actual logging function. Use the LOG macro instead of calling this directly.
+	void log(Verbosity verbosity, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, fmt::ArgList args);
+	FMT_VARIADIC(void, log, Verbosity, const char*, unsigned, LOGURU_FORMAT_STRING_TYPE)
+
+	// Log without any preamble or indentation.
+	void raw_log(Verbosity verbosity, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, fmt::ArgList args);
+	FMT_VARIADIC(void, raw_log, Verbosity, const char*, unsigned, LOGURU_FORMAT_STRING_TYPE)
+#else // LOGURU_USE_FMTLIB?
+	// Actual logging function. Use the LOG macro instead of calling this directly.
+	void log(Verbosity verbosity, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(4, 5);
+
+	// Log without any preamble or indentation.
+	void raw_log(Verbosity verbosity, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(4, 5);
+#endif // !LOGURU_USE_FMTLIB
+
+	// Helper class for LOG_SCOPE_F
+	class LogScopeRAII
+	{
+	public:
+		LogScopeRAII() : _file(nullptr) {} // No logging
+		LogScopeRAII(Verbosity verbosity, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(5, 6);
+		~LogScopeRAII();
+
+		LogScopeRAII(LogScopeRAII&& other) = default;
+
+	private:
+		LogScopeRAII(const LogScopeRAII&) = delete;
+		LogScopeRAII& operator=(const LogScopeRAII&) = delete;
+		void operator=(LogScopeRAII&&) = delete;
+
+		Verbosity   _verbosity;
+		const char* _file; // Set to null if we are disabled due to verbosity
+		unsigned    _line;
+		bool        _indent_stderr; // Did we?
+		long long   _start_time_ns;
+		char        _name[LOGURU_SCOPE_TEXT_SIZE];
+	};
+
+	// Marked as 'noreturn' for the benefit of the static analyzer and optimizer.
+	// stack_trace_skip is the number of extrace stack frames to skip above log_and_abort.
+	LOGURU_NORETURN void log_and_abort(int stack_trace_skip, const char* expr, const char* file, unsigned line, LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(5, 6);
+	LOGURU_NORETURN void log_and_abort(int stack_trace_skip, const char* expr, const char* file, unsigned line);
+
+	// Flush output to stderr and files.
+	// If g_flush_interval_ms is set to non-zero, this will be called automatically this often.
+	// If not set, you do not need to call this at all.
+	void flush();
+
+	template<class T> inline Text format_value(const T&)                    { return textprintf("N/A");     }
+	template<>        inline Text format_value(const char& v)               { return textprintf("%c",   v); }
+	template<>        inline Text format_value(const int& v)                { return textprintf("%d",   v); }
+	template<>        inline Text format_value(const unsigned int& v)       { return textprintf("%u",   v); }
+	template<>        inline Text format_value(const long& v)               { return textprintf("%lu",  v); }
+	template<>        inline Text format_value(const unsigned long& v)      { return textprintf("%ld",  v); }
+	template<>        inline Text format_value(const long long& v)          { return textprintf("%llu", v); }
+	template<>        inline Text format_value(const unsigned long long& v) { return textprintf("%lld", v); }
+	template<>        inline Text format_value(const float& v)              { return textprintf("%f",   v); }
+	template<>        inline Text format_value(const double& v)             { return textprintf("%f",   v); }
+
+	/* Thread names can be set for the benefit of readable logs.
+	   If you do not set the thread name, a hex id will be shown instead.
+	   These thread names may or may not be the same as the system thread names,
+	   depending on the system.
+	   Try to limit the thread name to 15 characters or less. */
+	void set_thread_name(const char* name);
+
+	/* Returns the thread name for this thread.
+	   On OSX this will return the system thread name (settable from both within and without Loguru).
+	   On other systems it will return whatever you set in set_thread_name();
+	   If no thread name is set, this will return a hexadecimal thread id.
+	   length should be the number of bytes available in the buffer.
+	   17 is a good number for length.
+	   right_align_hext_id means any hexadecimal thread id will be written to the end of buffer.
+	*/
+	void get_thread_name(char* buffer, unsigned long long length, bool right_align_hext_id);
+
+	/* Generates a readable stacktrace as a string.
+	   'skip' specifies how many stack frames to skip.
+	   For instance, the default skip (1) means:
+	   don't include the call to loguru::stacktrace in the stack trace. */
+	Text stacktrace(int skip = 1);
+
+	/*  Add a string to be replaced with something else in the stack output.
+
+		For instance, instead of having a stack trace look like this:
+			0x41f541 some_function(std::basic_ofstream<char, std::char_traits<char> >&)
+		You can clean it up with:
+			auto verbose_type_name = loguru::demangle(typeid(std::ofstream).name());
+			loguru::add_stack_cleanup(verbose_type_name.c_str(); "std::ofstream");
+		So the next time you will instead see:
+			0x41f541 some_function(std::ofstream&)
+
+		`replace_with_this` must be shorter than `find_this`.
+	*/
+	void add_stack_cleanup(const char* find_this, const char* replace_with_this);
+
+	// Example: demangle(typeid(std::ofstream).name()) -> "std::basic_ofstream<char, std::char_traits<char> >"
+	Text demangle(const char* name);
+
+	// ------------------------------------------------------------------------
+	/*
+	Not all terminals support colors, but if they do, and g_colorlogtostderr
+	is set, Loguru will write them to stderr to make errors in red, etc.
+
+	You also have the option to manually use them, via the function below.
+
+	Note, however, that if you do, the color codes could end up in your logfile!
+
+	This means if you intend to use them functions you should either:
+		* Use them on the stderr/stdout directly (bypass Loguru).
+		* Don't add file outputs to Loguru.
+		* Expect some \e[1m things in your logfile.
+
+	Usage:
+		printf("%sRed%sGreen%sBold green%sClear again\n",
+			   loguru::terminal_red(), loguru::terminal_green(),
+			   loguru::terminal_bold(), loguru::terminal_reset());
+
+	If the terminal at hand does not support colors the above output
+	will just not have funky \e[1m things showing.
+	*/
+
+	// Do the output terminal support colors?
+	bool terminal_has_color();
+
+	// Colors
+	const char* terminal_black();
+	const char* terminal_red();
+	const char* terminal_green();
+	const char* terminal_yellow();
+	const char* terminal_blue();
+	const char* terminal_purple();
+	const char* terminal_cyan();
+	const char* terminal_light_gray();
+	const char* terminal_light_red();
+	const char* terminal_white();
+
+	// Formating
+	const char* terminal_bold();
+	const char* terminal_underline();
+
+	// You should end each line with this!
+	const char* terminal_reset();
+
+	// --------------------------------------------------------------------
+	// Error context related:
+
+	struct StringStream;
+
+	// Use this in your EcEntryBase::print_value overload.
+	void stream_print(StringStream& out_string_stream, const char* text);
+
+	class EcEntryBase
+	{
+	public:
+		EcEntryBase(const char* file, unsigned line, const char* descr);
+		~EcEntryBase();
+		EcEntryBase(const EcEntryBase&) = delete;
+		EcEntryBase(EcEntryBase&&) = delete;
+		EcEntryBase& operator=(const EcEntryBase&) = delete;
+		EcEntryBase& operator=(EcEntryBase&&) = delete;
+
+		virtual void print_value(StringStream& out_string_stream) const = 0;
+
+		EcEntryBase* previous() const { return _previous; }
+
+	// private:
+		const char*  _file;
+		unsigned     _line;
+		const char*  _descr;
+		EcEntryBase* _previous;
+	};
+
+	template<typename T>
+	class EcEntryData : public EcEntryBase
+	{
+	public:
+		using Printer = Text(*)(T data);
+
+		EcEntryData(const char* file, unsigned line, const char* descr, T data, Printer&& printer)
+			: EcEntryBase(file, line, descr), _data(data), _printer(printer) {}
+
+		virtual void print_value(StringStream& out_string_stream) const override
+		{
+			const auto str = _printer(_data);
+			stream_print(out_string_stream, str.c_str());
+		}
+
+	private:
+		T   _data;
+		Printer _printer;
+	};
+
+	// template<typename Printer>
+	// class EcEntryLambda : public EcEntryBase
+	// {
+	// public:
+	// 	EcEntryLambda(const char* file, unsigned line, const char* descr, Printer&& printer)
+	// 		: EcEntryBase(file, line, descr), _printer(std::move(printer)) {}
+
+	// 	virtual void print_value(StringStream& out_string_stream) const override
+	// 	{
+	// 		const auto str = _printer();
+	// 		stream_print(out_string_stream, str.c_str());
+	// 	}
+
+	// private:
+	// 	Printer _printer;
+	// };
+
+	// template<typename Printer>
+	// EcEntryLambda<Printer> make_ec_entry_lambda(const char* file, unsigned line, const char* descr, Printer&& printer)
+	// {
+	// 	return {file, line, descr, std::move(printer)};
+	// }
+
+	template <class T>
+	struct decay_char_array { using type = T; };
+
+	template <unsigned long long  N>
+	struct decay_char_array<const char(&)[N]> { using type = const char*; };
+
+	template <class T>
+	struct make_const_ptr { using type = T; };
+
+	template <class T>
+	struct make_const_ptr<T*> { using type = const T*; };
+
+	template <class T>
+	struct make_ec_type { using type = typename make_const_ptr<typename decay_char_array<T>::type>::type; };
+
+	/* 	A stack trace gives you the names of the function at the point of a crash.
+		With ERROR_CONTEXT, you can also get the values of select local variables.
+		Usage:
+
+		void process_customers(const std::string& filename)
+		{
+			ERROR_CONTEXT("Processing file", filename.c_str());
+			for (int customer_index : ...)
+			{
+				ERROR_CONTEXT("Customer index", customer_index);
+				...
+			}
+		}
+
+		The context is in effect during the scope of the ERROR_CONTEXT.
+		Use loguru::get_error_context() to get the contents of the active error contexts.
+
+		Example result:
+
+		------------------------------------------------
+		[ErrorContext]                main.cpp:416   Processing file:    "customers.json"
+		[ErrorContext]                main.cpp:417   Customer index:     42
+		------------------------------------------------
+
+		Error contexts are printed automatically on crashes, and only on crashes.
+		This makes them much faster than logging the value of a variable.
+	*/
+	#define ERROR_CONTEXT(descr, data)                                             \
+		const loguru::EcEntryData<loguru::make_ec_type<decltype(data)>::type>      \
+			LOGURU_ANONYMOUS_VARIABLE(error_context_scope_)(                       \
+				__FILE__, __LINE__, descr, data,                                   \
+				static_cast<loguru::EcEntryData<loguru::make_ec_type<decltype(data)>::type>::Printer>(loguru::ec_to_text) ) // For better error messages
+
+/*
+	#define ERROR_CONTEXT(descr, data)                                 \
+		const auto LOGURU_ANONYMOUS_VARIABLE(error_context_scope_)(    \
+			loguru::make_ec_entry_lambda(__FILE__, __LINE__, descr,    \
+				[=](){ return loguru::ec_to_text(data); }))
+*/
+
+	using EcHandle = const EcEntryBase*;
+
+	/*
+		Get a light-weight handle to the error context stack on this thread.
+		The handle is valid as long as the current thread has no changes to its error context stack.
+		You can pass the handle to loguru::get_error_context on another thread.
+		This can be very useful for when you have a parent thread spawning several working threads,
+		and you want the error context of the parent thread to get printed (too) when there is an
+		error on the child thread. You can accomplish this thusly:
+
+		void foo(const char* parameter)
+		{
+			ERROR_CONTEXT("parameter", parameter)
+			const auto parent_ec_handle = loguru::get_thread_ec_handle();
+
+			std::thread([=]{
+				loguru::set_thread_name("child thread");
+				ERROR_CONTEXT("parent context", parent_ec_handle);
+				dangerous_code();
+			}.join();
+		}
+
+	*/
+	EcHandle get_thread_ec_handle();
+
+	// Get a string describing the current stack of error context. Empty string if there is none.
+	Text get_error_context();
+
+	// Get a string describing the error context of the given thread handle.
+	Text get_error_context_for(EcHandle ec_handle);
+
+	// ------------------------------------------------------------------------
+
+	Text ec_to_text(const char* data);
+	Text ec_to_text(char data);
+	Text ec_to_text(int data);
+	Text ec_to_text(unsigned int data);
+	Text ec_to_text(long data);
+	Text ec_to_text(unsigned long data);
+	Text ec_to_text(long long data);
+	Text ec_to_text(unsigned long long data);
+	Text ec_to_text(float data);
+	Text ec_to_text(double data);
+	Text ec_to_text(long double data);
+	Text ec_to_text(EcHandle);
+
+	/*
+	You can add ERROR_CONTEXT support for your own types by overloading ec_to_text. Here's how:
+
+	some.hpp:
+		namespace loguru {
+			Text ec_to_text(MySmallType data)
+			Text ec_to_text(const MyBigType* data)
+		} // namespace loguru
+
+	some.cpp:
+		namespace loguru {
+			Text ec_to_text(MySmallType small_value)
+			{
+				// Called only when needed, i.e. on a crash.
+				std::string str = small_value.as_string(); // Format 'small_value' here somehow.
+				return Text{strdup(str.c_str())};
+			}
+
+			Text ec_to_text(const MyBigType* big_value)
+			{
+				// Called only when needed, i.e. on a crash.
+				std::string str = big_value->as_string(); // Format 'big_value' here somehow.
+				return Text{strdup(str.c_str())};
+			}
+		} // namespace loguru
+
+	Any file that include some.hpp:
+		void foo(MySmallType small, const MyBigType& big)
+		{
+			ERROR_CONTEXT("Small", small); // Copy ´small` by value.
+			ERROR_CONTEXT("Big",   &big);  // `big` should not change during this scope!
+			....
+		}
+	*/
+} // namespace loguru
+
+// --------------------------------------------------------------------
+// Logging macros
+
+// LOG_F(2, "Only logged if verbosity is 2 or higher: %d", some_number);
+#define VLOG_F(verbosity, ...)                                                                     \
+	((verbosity) > loguru::current_verbosity_cutoff()) ? (void)0                                   \
+									  : loguru::log(verbosity, __FILE__, __LINE__, __VA_ARGS__)
+
+// LOG_F(INFO, "Foo: %d", some_number);
+#define LOG_F(verbosity_name, ...) VLOG_F(loguru::Verbosity_ ## verbosity_name, __VA_ARGS__)
+
+#define VLOG_IF_F(verbosity, cond, ...)                                                            \
+	((verbosity) > loguru::current_verbosity_cutoff() || (cond) == false)                          \
+		? (void)0                                                                                  \
+		: loguru::log(verbosity, __FILE__, __LINE__, __VA_ARGS__)
+
+#define LOG_IF_F(verbosity_name, cond, ...)                                                        \
+	VLOG_IF_F(loguru::Verbosity_ ## verbosity_name, cond, __VA_ARGS__)
+
+#define VLOG_SCOPE_F(verbosity, ...)                                                               \
+	loguru::LogScopeRAII LOGURU_ANONYMOUS_VARIABLE(error_context_RAII_) =                          \
+	((verbosity) > loguru::current_verbosity_cutoff()) ? loguru::LogScopeRAII() :                  \
+	loguru::LogScopeRAII(verbosity, __FILE__, __LINE__, __VA_ARGS__)
+
+// Raw logging - no preamble, no indentation. Slightly faster than full logging.
+#define RAW_VLOG_F(verbosity, ...)                                                                 \
+	((verbosity) > loguru::current_verbosity_cutoff()) ? (void)0                                   \
+									  : loguru::raw_log(verbosity, __FILE__, __LINE__, __VA_ARGS__)
+
+#define RAW_LOG_F(verbosity_name, ...) RAW_VLOG_F(loguru::Verbosity_ ## verbosity_name, __VA_ARGS__)
+
+// Use to book-end a scope. Affects logging on all threads.
+#define LOG_SCOPE_F(verbosity_name, ...)                                                           \
+	VLOG_SCOPE_F(loguru::Verbosity_ ## verbosity_name, __VA_ARGS__)
+
+#define LOG_SCOPE_FUNCTION(verbosity_name) LOG_SCOPE_F(verbosity_name, __func__)
+
+// -----------------------------------------------
+// ABORT_F macro. Usage:  ABORT_F("Cause of error: %s", error_str);
+
+// Message is optional
+#define ABORT_F(...) loguru::log_and_abort(0, "ABORT: ", __FILE__, __LINE__, __VA_ARGS__)
+
+// --------------------------------------------------------------------
+// CHECK_F macros:
+
+#define CHECK_WITH_INFO_F(test, info, ...)                                                         \
+	LOGURU_PREDICT_TRUE((test) == true) ? (void)0 : loguru::log_and_abort(0, "CHECK FAILED:  " info "  ", __FILE__,      \
+													   __LINE__, ##__VA_ARGS__)
+
+/* Checked at runtime too. Will print error, then call fatal_handler (if any), then 'abort'.
+   Note that the test must be boolean.
+   CHECK_F(ptr); will not compile, but CHECK_F(ptr != nullptr); will. */
+#define CHECK_F(test, ...) CHECK_WITH_INFO_F(test, #test, ##__VA_ARGS__)
+
+#define CHECK_NOTNULL_F(x, ...) CHECK_WITH_INFO_F((x) != nullptr, #x " != nullptr", ##__VA_ARGS__)
+
+#define CHECK_OP_F(expr_left, expr_right, op, ...)                                                 \
+	do                                                                                             \
+	{                                                                                              \
+		auto val_left = expr_left;                                                                 \
+		auto val_right = expr_right;                                                               \
+		if (! LOGURU_PREDICT_TRUE(val_left op val_right))                                          \
+		{                                                                                          \
+			auto str_left = loguru::format_value(val_left);                                        \
+			auto str_right = loguru::format_value(val_right);                                      \
+			auto fail_info = loguru::textprintf("CHECK FAILED:  %s %s %s  (%s %s %s)  ",           \
+				#expr_left, #op, #expr_right, str_left.c_str(), #op, str_right.c_str());           \
+			auto user_msg = loguru::textprintf(__VA_ARGS__);                                       \
+			loguru::log_and_abort(0, fail_info.c_str(), __FILE__, __LINE__,                        \
+			                      "%s", user_msg.c_str());                                         \
+		}                                                                                          \
+	} while (false)
+
+#ifndef LOGURU_DEBUG_LOGGING
+	#ifndef NDEBUG
+		#define LOGURU_DEBUG_LOGGING 1
+	#else
+		#define LOGURU_DEBUG_LOGGING 0
+	#endif
+#endif
+
+#if LOGURU_DEBUG_LOGGING
+	// Debug logging enabled:
+	#define DLOG_F(verbosity_name, ...)     LOG_F(verbosity_name, __VA_ARGS__)
+	#define DVLOG_F(verbosity, ...)         VLOG_F(verbosity, __VA_ARGS__)
+	#define DLOG_IF_F(verbosity_name, ...)  LOG_IF_F(verbosity_name, __VA_ARGS__)
+	#define DVLOG_IF_F(verbosity, ...)      VLOG_IF_F(verbosity, __VA_ARGS__)
+	#define DRAW_LOG_F(verbosity_name, ...) RAW_LOG_F(verbosity_name, __VA_ARGS__)
+	#define DRAW_VLOG_F(verbosity, ...)     RAW_VLOG_F(verbosity, __VA_ARGS__)
+#else
+	// Debug logging disabled:
+	#define DLOG_F(verbosity_name, ...)
+	#define DVLOG_F(verbosity, ...)
+	#define DLOG_IF_F(verbosity_name, ...)
+	#define DVLOG_IF_F(verbosity, ...)
+	#define DRAW_LOG_F(verbosity_name, ...)
+	#define DRAW_VLOG_F(verbosity, ...)
+#endif
+
+#define CHECK_EQ_F(a, b, ...) CHECK_OP_F(a, b, ==, ##__VA_ARGS__)
+#define CHECK_NE_F(a, b, ...) CHECK_OP_F(a, b, !=, ##__VA_ARGS__)
+#define CHECK_LT_F(a, b, ...) CHECK_OP_F(a, b, < , ##__VA_ARGS__)
+#define CHECK_GT_F(a, b, ...) CHECK_OP_F(a, b, > , ##__VA_ARGS__)
+#define CHECK_LE_F(a, b, ...) CHECK_OP_F(a, b, <=, ##__VA_ARGS__)
+#define CHECK_GE_F(a, b, ...) CHECK_OP_F(a, b, >=, ##__VA_ARGS__)
+
+#ifndef LOGURU_DEBUG_CHECKS
+	#ifndef NDEBUG
+		#define LOGURU_DEBUG_CHECKS 1
+	#else
+		#define LOGURU_DEBUG_CHECKS 0
+	#endif
+#endif
+
+#if LOGURU_DEBUG_CHECKS
+	// Debug checks enabled:
+	#define DCHECK_F(test, ...)             CHECK_F(test, ##__VA_ARGS__)
+	#define DCHECK_NOTNULL_F(x, ...)        CHECK_NOTNULL_F(x, ##__VA_ARGS__)
+	#define DCHECK_EQ_F(a, b, ...)          CHECK_EQ_F(a, b, ##__VA_ARGS__)
+	#define DCHECK_NE_F(a, b, ...)          CHECK_NE_F(a, b, ##__VA_ARGS__)
+	#define DCHECK_LT_F(a, b, ...)          CHECK_LT_F(a, b, ##__VA_ARGS__)
+	#define DCHECK_LE_F(a, b, ...)          CHECK_LE_F(a, b, ##__VA_ARGS__)
+	#define DCHECK_GT_F(a, b, ...)          CHECK_GT_F(a, b, ##__VA_ARGS__)
+	#define DCHECK_GE_F(a, b, ...)          CHECK_GE_F(a, b, ##__VA_ARGS__)
+#else
+	// Debug checks disabled:
+	#define DCHECK_F(test, ...)
+	#define DCHECK_NOTNULL_F(x, ...)
+	#define DCHECK_EQ_F(a, b, ...)
+	#define DCHECK_NE_F(a, b, ...)
+	#define DCHECK_LT_F(a, b, ...)
+	#define DCHECK_LE_F(a, b, ...)
+	#define DCHECK_GT_F(a, b, ...)
+	#define DCHECK_GE_F(a, b, ...)
+#endif // NDEBUG
+
+
+#ifdef LOGURU_REDEFINE_ASSERT
+	#undef assert
+	#ifndef NDEBUG
+		// Debug:
+		#define assert(test) CHECK_WITH_INFO_F(!!(test), #test) // HACK
+	#else
+		#define assert(test)
+	#endif
+#endif // LOGURU_REDEFINE_ASSERT
+
+#endif // LOGURU_HAS_DECLARED_FORMAT_HEADER
+
+// ----------------------------------------------------------------------------
+// .dP"Y8 888888 88""Yb 888888    db    8b    d8 .dP"Y8
+// `Ybo."   88   88__dP 88__     dPYb   88b  d88 `Ybo."
+// o.`Y8b   88   88"Yb  88""    dP__Yb  88YbdP88 o.`Y8b
+// 8bodP'   88   88  Yb 888888 dP""""Yb 88 YY 88 8bodP'
+
+#if LOGURU_WITH_STREAMS
+#ifndef LOGURU_HAS_DECLARED_STREAMS_HEADER
+#define LOGURU_HAS_DECLARED_STREAMS_HEADER
+
+/* This file extends loguru to enable std::stream-style logging, a la Glog.
+   It's an optional feature behind the LOGURU_WITH_STREAMS settings
+   because including it everywhere will slow down compilation times.
+*/
+
+#include <cstdarg>
+#include <sstream> // Adds about 38 kLoC on clang.
+#include <string>
+
+namespace loguru
+{
+	// Like sprintf, but returns the formated text.
+	std::string strprintf(LOGURU_FORMAT_STRING_TYPE format, ...) LOGURU_PRINTF_LIKE(1, 2);
+
+	// Like vsprintf, but returns the formated text.
+	std::string vstrprintf(LOGURU_FORMAT_STRING_TYPE format, va_list) LOGURU_PRINTF_LIKE(1, 0);
+
+	class StreamLogger
+	{
+	public:
+		StreamLogger(Verbosity verbosity, const char* file, unsigned line) : _verbosity(verbosity), _file(file), _line(line) {}
+		~StreamLogger() noexcept(false);
+
+		template<typename T>
+		StreamLogger& operator<<(const T& t)
+		{
+			_ss << t;
+			return *this;
+		}
+
+		// std::endl and other iomanip:s.
+		StreamLogger& operator<<(std::ostream&(*f)(std::ostream&))
+		{
+			f(_ss);
+			return *this;
+		}
+
+	private:
+		Verbosity   _verbosity;
+		const char* _file;
+		unsigned    _line;
+		std::ostringstream _ss;
+	};
+
+	class AbortLogger
+	{
+	public:
+		AbortLogger(const char* expr, const char* file, unsigned line) : _expr(expr), _file(file), _line(line) { }
+		LOGURU_NORETURN ~AbortLogger() noexcept(false);
+
+		template<typename T>
+		AbortLogger& operator<<(const T& t)
+		{
+			_ss << t;
+			return *this;
+		}
+
+		// std::endl and other iomanip:s.
+		AbortLogger& operator<<(std::ostream&(*f)(std::ostream&))
+		{
+			f(_ss);
+			return *this;
+		}
+
+	private:
+		const char*        _expr;
+		const char*        _file;
+		unsigned           _line;
+		std::ostringstream _ss;
+	};
+
+	class Voidify
+	{
+	public:
+		Voidify() {}
+		// This has to be an operator with a precedence lower than << but higher than ?:
+		void operator&(const StreamLogger&) { }
+		void operator&(const AbortLogger&)  { }
+	};
+
+	/*  Helper functions for CHECK_OP_S macro.
+		GLOG trick: The (int, int) specialization works around the issue that the compiler
+		will not instantiate the template version of the function on values of unnamed enum type. */
+	#define DEFINE_CHECK_OP_IMPL(name, op)                                                             \
+		template <typename T1, typename T2>                                                            \
+		inline std::string* name(const char* expr, const T1& v1, const char* op_str, const T2& v2)     \
+		{                                                                                              \
+			if (LOGURU_PREDICT_TRUE(v1 op v2)) { return NULL; }                                        \
+			std::ostringstream ss;                                                                     \
+			ss << "CHECK FAILED:  " << expr << "  (" << v1 << " " << op_str << " " << v2 << ")  ";     \
+			return new std::string(ss.str());                                                          \
+		}                                                                                              \
+		inline std::string* name(const char* expr, int v1, const char* op_str, int v2)                 \
+		{                                                                                              \
+			return name<int, int>(expr, v1, op_str, v2);                                               \
+		}
+
+	DEFINE_CHECK_OP_IMPL(check_EQ_impl, ==)
+	DEFINE_CHECK_OP_IMPL(check_NE_impl, !=)
+	DEFINE_CHECK_OP_IMPL(check_LE_impl, <=)
+	DEFINE_CHECK_OP_IMPL(check_LT_impl, < )
+	DEFINE_CHECK_OP_IMPL(check_GE_impl, >=)
+	DEFINE_CHECK_OP_IMPL(check_GT_impl, > )
+	#undef DEFINE_CHECK_OP_IMPL
+
+	/*  GLOG trick: Function is overloaded for integral types to allow static const integrals
+		declared in classes and not defined to be used as arguments to CHECK* macros. */
+	template <class T>
+	inline const T&           referenceable_value(const T&           t) { return t; }
+	inline char               referenceable_value(char               t) { return t; }
+	inline unsigned char      referenceable_value(unsigned char      t) { return t; }
+	inline signed char        referenceable_value(signed char        t) { return t; }
+	inline short              referenceable_value(short              t) { return t; }
+	inline unsigned short     referenceable_value(unsigned short     t) { return t; }
+	inline int                referenceable_value(int                t) { return t; }
+	inline unsigned int       referenceable_value(unsigned int       t) { return t; }
+	inline long               referenceable_value(long               t) { return t; }
+	inline unsigned long      referenceable_value(unsigned long      t) { return t; }
+	inline long long          referenceable_value(long long          t) { return t; }
+	inline unsigned long long referenceable_value(unsigned long long t) { return t; }
+} // namespace loguru
+
+// -----------------------------------------------
+// Logging macros:
+
+// usage:  LOG_STREAM(INFO) << "Foo " << std::setprecision(10) << some_value;
+#define VLOG_IF_S(verbosity, cond)                                                                 \
+	((verbosity) > loguru::current_verbosity_cutoff() || (cond) == false)                          \
+		? (void)0                                                                                  \
+		: loguru::Voidify() & loguru::StreamLogger(verbosity, __FILE__, __LINE__)
+#define LOG_IF_S(verbosity_name, cond) VLOG_IF_S(loguru::Verbosity_ ## verbosity_name, cond)
+#define VLOG_S(verbosity)              VLOG_IF_S(verbosity, true)
+#define LOG_S(verbosity_name)          VLOG_S(loguru::Verbosity_ ## verbosity_name)
+
+// -----------------------------------------------
+// ABORT_S macro. Usage:  ABORT_S() << "Causo of error: " << details;
+
+#define ABORT_S() loguru::Voidify() & loguru::AbortLogger("ABORT: ", __FILE__, __LINE__)
+
+// -----------------------------------------------
+// CHECK_S macros:
+
+#define CHECK_WITH_INFO_S(cond, info)                                                              \
+	LOGURU_PREDICT_TRUE((cond) == true)                                                            \
+		? (void)0                                                                                  \
+		: loguru::Voidify() & loguru::AbortLogger("CHECK FAILED:  " info "  ", __FILE__, __LINE__)
+
+#define CHECK_S(cond) CHECK_WITH_INFO_S(cond, #cond)
+#define CHECK_NOTNULL_S(x) CHECK_WITH_INFO_S((x) != nullptr, #x " != nullptr")
+
+#define CHECK_OP_S(function_name, expr1, op, expr2)                                                \
+	while (auto error_string = loguru::function_name(#expr1 " " #op " " #expr2,                    \
+													 loguru::referenceable_value(expr1), #op,      \
+													 loguru::referenceable_value(expr2)))          \
+		loguru::AbortLogger(error_string->c_str(), __FILE__, __LINE__)
+
+#define CHECK_EQ_S(expr1, expr2) CHECK_OP_S(check_EQ_impl, expr1, ==, expr2)
+#define CHECK_NE_S(expr1, expr2) CHECK_OP_S(check_NE_impl, expr1, !=, expr2)
+#define CHECK_LE_S(expr1, expr2) CHECK_OP_S(check_LE_impl, expr1, <=, expr2)
+#define CHECK_LT_S(expr1, expr2) CHECK_OP_S(check_LT_impl, expr1, < , expr2)
+#define CHECK_GE_S(expr1, expr2) CHECK_OP_S(check_GE_impl, expr1, >=, expr2)
+#define CHECK_GT_S(expr1, expr2) CHECK_OP_S(check_GT_impl, expr1, > , expr2)
+
+#if LOGURU_DEBUG_LOGGING
+	// Debug logging enabled:
+	#define DVLOG_IF_S(verbosity, cond)     VLOG_IF_S(verbosity, cond)
+	#define DLOG_IF_S(verbosity_name, cond) LOG_IF_S(verbosity_name, cond)
+	#define DVLOG_S(verbosity)              VLOG_S(verbosity)
+	#define DLOG_S(verbosity_name)          LOG_S(verbosity_name)
+#else
+	// Debug logging disabled:
+	#define DVLOG_IF_S(verbosity, cond)                                                     \
+		(true || (verbosity) > loguru::current_verbosity_cutoff() || (cond) == false)       \
+			? (void)0                                                                       \
+			: loguru::Voidify() & loguru::StreamLogger(verbosity, __FILE__, __LINE__)
+
+	#define DLOG_IF_S(verbosity_name, cond) DVLOG_IF_S(loguru::Verbosity_ ## verbosity_name, cond)
+	#define DVLOG_S(verbosity)              DVLOG_IF_S(verbosity, true)
+	#define DLOG_S(verbosity_name)          DVLOG_S(loguru::Verbosity_ ## verbosity_name)
+#endif
+
+#if LOGURU_DEBUG_CHECKS
+	// Debug checks enabled:
+	#define DCHECK_S(cond)                  CHECK_S(cond)
+	#define DCHECK_NOTNULL_S(x)             CHECK_NOTNULL_S(x)
+	#define DCHECK_EQ_S(a, b)               CHECK_EQ_S(a, b)
+	#define DCHECK_NE_S(a, b)               CHECK_NE_S(a, b)
+	#define DCHECK_LT_S(a, b)               CHECK_LT_S(a, b)
+	#define DCHECK_LE_S(a, b)               CHECK_LE_S(a, b)
+	#define DCHECK_GT_S(a, b)               CHECK_GT_S(a, b)
+	#define DCHECK_GE_S(a, b)               CHECK_GE_S(a, b)
+#else
+// Debug checks disabled:
+	#define DCHECK_S(cond)                  CHECK_S(true || (cond))
+	#define DCHECK_NOTNULL_S(x)             CHECK_S(true || (x) != nullptr)
+	#define DCHECK_EQ_S(a, b)               CHECK_S(true || (a) == (b))
+	#define DCHECK_NE_S(a, b)               CHECK_S(true || (a) != (b))
+	#define DCHECK_LT_S(a, b)               CHECK_S(true || (a) <  (b))
+	#define DCHECK_LE_S(a, b)               CHECK_S(true || (a) <= (b))
+	#define DCHECK_GT_S(a, b)               CHECK_S(true || (a) >  (b))
+	#define DCHECK_GE_S(a, b)               CHECK_S(true || (a) >= (b))
+#endif
+
+#if LOGURU_REPLACE_GLOG
+	#undef LOG
+	#undef VLOG
+	#undef LOG_IF
+	#undef VLOG_IF
+	#undef CHECK
+	#undef CHECK_NOTNULL
+	#undef CHECK_EQ
+	#undef CHECK_NE
+	#undef CHECK_LT
+	#undef CHECK_LE
+	#undef CHECK_GT
+	#undef CHECK_GE
+	#undef DLOG
+	#undef DVLOG
+	#undef DLOG_IF
+	#undef DVLOG_IF
+	#undef DCHECK
+	#undef DCHECK_NOTNULL
+	#undef DCHECK_EQ
+	#undef DCHECK_NE
+	#undef DCHECK_LT
+	#undef DCHECK_LE
+	#undef DCHECK_GT
+	#undef DCHECK_GE
+	#undef VLOG_IS_ON
+
+	#define LOG            LOG_S
+	#define VLOG           VLOG_S
+	#define LOG_IF         LOG_IF_S
+	#define VLOG_IF        VLOG_IF_S
+	#define CHECK(cond)    CHECK_S(!!(cond))
+	#define CHECK_NOTNULL  CHECK_NOTNULL_S
+	#define CHECK_EQ       CHECK_EQ_S
+	#define CHECK_NE       CHECK_NE_S
+	#define CHECK_LT       CHECK_LT_S
+	#define CHECK_LE       CHECK_LE_S
+	#define CHECK_GT       CHECK_GT_S
+	#define CHECK_GE       CHECK_GE_S
+	#define DLOG           DLOG_S
+	#define DVLOG          DVLOG_S
+	#define DLOG_IF        DLOG_IF_S
+	#define DVLOG_IF       DVLOG_IF_S
+	#define DCHECK         DCHECK_S
+	#define DCHECK_NOTNULL DCHECK_NOTNULL_S
+	#define DCHECK_EQ      DCHECK_EQ_S
+	#define DCHECK_NE      DCHECK_NE_S
+	#define DCHECK_LT      DCHECK_LT_S
+	#define DCHECK_LE      DCHECK_LE_S
+	#define DCHECK_GT      DCHECK_GT_S
+	#define DCHECK_GE      DCHECK_GE_S
+	#define VLOG_IS_ON(verbosity) ((verbosity) <= loguru::current_verbosity_cutoff())
+
+#endif // LOGURU_REPLACE_GLOG
+
+#endif // LOGURU_WITH_STREAMS
+
+#endif // LOGURU_HAS_DECLARED_STREAMS_HEADER
+
+// ----------------------------------------------------------------------------
+// 88 8b    d8 88""Yb 88     888888 8b    d8 888888 88b 88 888888    db    888888 88  dP"Yb  88b 88
+// 88 88b  d88 88__dP 88     88__   88b  d88 88__   88Yb88   88     dPYb     88   88 dP   Yb 88Yb88
+// 88 88YbdP88 88"""  88  .o 88""   88YbdP88 88""   88 Y88   88    dP__Yb    88   88 Yb   dP 88 Y88
+// 88 88 YY 88 88     88ood8 888888 88 YY 88 888888 88  Y8   88   dP""""Yb   88   88  YbodP  88  Y8
+
+/* In one of your .cpp files you need to do the following:
+#define LOGURU_IMPLEMENTATION 1
+#include <loguru.hpp>
+
+This will define all the Loguru functions so that the linker may find them.
+*/
+
+#if defined(LOGURU_IMPLEMENTATION) && !defined(LOGURU_HAS_BEEN_IMPLEMENTED)
+#define LOGURU_HAS_BEEN_IMPLEMENTED
+
+#define LOGURU_PREAMBLE_WIDTH (53 + LOGURU_THREADNAME_WIDTH + LOGURU_FILENAME_WIDTH)
+
+#include <algorithm>
+#include <atomic>
+#include <chrono>
+#include <cstdarg>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <mutex>
+#include <regex>
+#include <string>
+#include <thread>
+#include <vector>
+
+#ifdef _WIN32
+	#include <direct.h>
+
+	#define localtime_r(a, b) localtime_s(b, a) // No localtime_r with MSVC, but arguments are swapped for localtime_s
+#else
+	#include <signal.h>
+	#include <sys/stat.h> // mkdir
+	#include <unistd.h>   // STDERR_FILENO
+#endif
+
+#ifdef __linux__
+	#include <linux/limits.h> // PATH_MAX
+#elif !defined(_WIN32)
+	#include <limits.h> // PATH_MAX
+#endif
+
+#ifndef PATH_MAX
+	#define PATH_MAX 1024
+#endif
+
+#ifdef __APPLE__
+	#include "TargetConditionals.h"
+#endif
+
+// TODO: use defined(_POSIX_VERSION) for some of these things?
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+	#define LOGURU_PTHREADS    0
+	#define LOGURU_WINTHREADS  1
+	#ifndef LOGURU_STACKTRACES
+		#define LOGURU_STACKTRACES 0
+	#endif
+#elif defined(__rtems__)
+	#define LOGURU_PTHREADS    1
+	#define LOGURU_WINTHREADS  0
+	#ifndef LOGURU_STACKTRACES
+		#define LOGURU_STACKTRACES 0
+	#endif
+#else
+	#define LOGURU_PTHREADS    1
+	#define LOGURU_WINTHREADS  0
+	#ifndef LOGURU_STACKTRACES
+		#define LOGURU_STACKTRACES 1
+	#endif
+#endif
+
+#if LOGURU_STACKTRACES
+	#include <cxxabi.h>    // for __cxa_demangle
+	#include <dlfcn.h>     // for dladdr
+	//#include <execinfo.h>  // for backtrace
+#endif // LOGURU_STACKTRACES
+
+#if LOGURU_PTHREADS
+	#include <pthread.h>
+	#if defined(__FreeBSD__)
+		#include <pthread_np.h>
+		#include <sys/thr.h>
+	#elif defined(__OpenBSD__)
+		#include <pthread_np.h>
+	#endif
+
+	#ifdef __linux__
+		/* On Linux, the default thread name is the same as the name of the binary.
+		   Additionally, all new threads inherit the name of the thread it got forked from.
+		   For this reason, Loguru use the pthread Thread Local Storage
+		   for storing thread names on Linux. */
+		#define LOGURU_PTLS_NAMES 1
+	#endif
+#endif
+
+#if LOGURU_WINTHREADS
+	#ifndef _WIN32_WINNT
+		#define _WIN32_WINNT 0x0502
+	#endif
+	#define WIN32_LEAN_AND_MEAN
+	#define NOMINMAX
+	#include <windows.h>
+#endif
+
+#ifndef LOGURU_PTLS_NAMES
+   #define LOGURU_PTLS_NAMES 0
+#endif
+
+namespace loguru
+{
+	using namespace std::chrono;
+
+#if LOGURU_WITH_FILEABS
+	struct FileAbs
+	{
+		char path[PATH_MAX];
+		char mode_str[4];
+		Verbosity verbosity;
+		struct stat st;
+		FILE* fp;
+		bool is_reopening = false; // to prevent recursive call in file_reopen.
+		decltype(steady_clock::now()) last_check_time = steady_clock::now();
+	};
+#else
+	typedef FILE* FileAbs;
+#endif
+
+	struct Callback
+	{
+		std::string     id;
+		log_handler_t   callback;
+		void*           user_data;
+		Verbosity       verbosity; // Does not change!
+		close_handler_t close;
+		flush_handler_t flush;
+		unsigned        indentation;
+	};
+
+	using CallbackVec = std::vector<Callback>;
+
+	using StringPair     = std::pair<std::string, std::string>;
+	using StringPairList = std::vector<StringPair>;
+
+	const auto SCOPE_TIME_PRECISION = 3; // 3=ms, 6≈us, 9=ns
+
+	const auto s_start_time = steady_clock::now();
+
+	Verbosity g_stderr_verbosity  = Verbosity_0;
+	bool      g_colorlogtostderr  = true;
+	unsigned  g_flush_interval_ms = 0;
+	bool      g_preamble          = true;
+
+	// Preamble details
+	bool      g_preamble_date     = true;
+	bool      g_preamble_time     = true;
+	bool      g_preamble_uptime   = true;
+	bool      g_preamble_thread   = true;
+	bool      g_preamble_file     = true;
+	bool      g_preamble_verbose  = true;
+	bool      g_preamble_pipe     = true;
+
+	static std::recursive_mutex  s_mutex;
+	static Verbosity             s_max_out_verbosity = Verbosity_OFF;
+	static std::string           s_argv0_filename;
+	static std::string           s_arguments;
+	static char                  s_current_dir[PATH_MAX];
+	static CallbackVec           s_callbacks;
+	static fatal_handler_t       s_fatal_handler   = nullptr;
+	static StringPairList        s_user_stack_cleanups;
+	static bool                  s_strip_file_path = true;
+	static std::atomic<unsigned> s_stderr_indentation { 0 };
+
+	// For periodic flushing:
+	static std::thread* s_flush_thread   = nullptr;
+	static bool         s_needs_flushing = false;
+
+	static const bool s_terminal_has_color = [](){
+		#ifdef _WIN32
+			#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
+			#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
+			#endif
+
+			HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
+			if (hOut != INVALID_HANDLE_VALUE) {
+				DWORD dwMode = 0;
+				GetConsoleMode(hOut, &dwMode);
+				dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+				return SetConsoleMode(hOut, dwMode) != 0;
+			}
+			return false;
+		#else
+			if (const char* term = getenv("TERM")) {
+				return 0 == strcmp(term, "cygwin")
+					|| 0 == strcmp(term, "linux")
+					|| 0 == strcmp(term, "rxvt-unicode-256color")
+					|| 0 == strcmp(term, "screen")
+					|| 0 == strcmp(term, "screen-256color")
+					|| 0 == strcmp(term, "tmux-256color")
+					|| 0 == strcmp(term, "xterm")
+					|| 0 == strcmp(term, "xterm-256color")
+					|| 0 == strcmp(term, "xterm-termite")
+					|| 0 == strcmp(term, "xterm-color");
+			} else {
+				return false;
+			}
+		#endif
+	}();
+
+	static void print_preamble_header(char* out_buff, size_t out_buff_size);
+
+	#if LOGURU_PTLS_NAMES
+		static pthread_once_t s_pthread_key_once = PTHREAD_ONCE_INIT;
+		static pthread_key_t  s_pthread_key_name;
+
+		void make_pthread_key_name()
+		{
+			(void)pthread_key_create(&s_pthread_key_name, free);
+		}
+	#endif
+
+	// ------------------------------------------------------------------------------
+	// Colors
+
+	bool terminal_has_color() { return s_terminal_has_color; }
+
+	// Colors
+
+#ifdef _WIN32
+#define VTSEQ(ID) ("\x1b[1;" #ID "m")
+#else
+#define VTSEQ(ID) ("\e[" #ID "m")
+#endif
+
+	const char* terminal_black()      { return s_terminal_has_color ? VTSEQ(30) : ""; }
+	const char* terminal_red()        { return s_terminal_has_color ? VTSEQ(31) : ""; }
+	const char* terminal_green()      { return s_terminal_has_color ? VTSEQ(32) : ""; }
+	const char* terminal_yellow()     { return s_terminal_has_color ? VTSEQ(33) : ""; }
+	const char* terminal_blue()       { return s_terminal_has_color ? VTSEQ(34) : ""; }
+	const char* terminal_purple()     { return s_terminal_has_color ? VTSEQ(35) : ""; }
+	const char* terminal_cyan()       { return s_terminal_has_color ? VTSEQ(36) : ""; }
+	const char* terminal_light_gray() { return s_terminal_has_color ? VTSEQ(37) : ""; }
+	const char* terminal_white()      { return s_terminal_has_color ? VTSEQ(37) : ""; }
+	const char* terminal_light_red()  { return s_terminal_has_color ? VTSEQ(91) : ""; }
+	const char* terminal_dim()        { return s_terminal_has_color ? VTSEQ(2)  : ""; }
+
+	// Formating
+	const char* terminal_bold()       { return s_terminal_has_color ? VTSEQ(1) : ""; }
+	const char* terminal_underline()  { return s_terminal_has_color ? VTSEQ(4) : ""; }
+
+	// You should end each line with this!
+	const char* terminal_reset()      { return s_terminal_has_color ? VTSEQ(0) : ""; }
+
+	// ------------------------------------------------------------------------------
+#if LOGURU_WITH_FILEABS
+	void file_reopen(void* user_data);
+	inline FILE* to_file(void* user_data) { return reinterpret_cast<FileAbs*>(user_data)->fp; }
+#else
+	inline FILE* to_file(void* user_data) { return reinterpret_cast<FILE*>(user_data); }
+#endif
+
+	void file_log(void* user_data, const Message& message)
+	{
+#if LOGURU_WITH_FILEABS
+		FileAbs* file_abs = reinterpret_cast<FileAbs*>(user_data);
+		if (file_abs->is_reopening) {
+			return;
+		}
+		// It is better checking file change every minute/hour/day,
+		// instead of doing this every time we log.
+		// Here check_interval is set to zero to enable checking every time;
+		const auto check_interval = seconds(0);
+		if (duration_cast<seconds>(steady_clock::now() - file_abs->last_check_time) > check_interval) {
+			file_abs->last_check_time = steady_clock::now();
+			file_reopen(user_data);
+		}
+		FILE* file = to_file(user_data);
+		if (!file) {
+			return;
+		}
+#else
+		FILE* file = to_file(user_data);
+#endif
+		fprintf(file, "%s%s%s%s\n",
+			message.preamble, message.indentation, message.prefix, message.message);
+		if (g_flush_interval_ms == 0) {
+			fflush(file);
+		}
+	}
+
+	void file_close(void* user_data)
+	{
+		FILE* file = to_file(user_data);
+		if (file) {
+			fclose(file);
+		}
+#if LOGURU_WITH_FILEABS
+		delete reinterpret_cast<FileAbs*>(user_data);
+#endif
+	}
+
+	void file_flush(void* user_data)
+	{
+		FILE* file = to_file(user_data);
+		fflush(file);
+	}
+
+#if LOGURU_WITH_FILEABS
+	void file_reopen(void* user_data)
+	{
+		FileAbs * file_abs = reinterpret_cast<FileAbs*>(user_data);
+		struct stat st;
+		int ret;
+		if (!file_abs->fp || (ret = stat(file_abs->path, &st)) == -1 || (st.st_ino != file_abs->st.st_ino)) {
+			file_abs->is_reopening = true;
+			if (file_abs->fp) {
+				fclose(file_abs->fp);
+			}
+			if (!file_abs->fp) {
+				LOG_F(INFO, "Reopening file '%s' due to previous error", file_abs->path);
+			}
+			else if (ret < 0) {
+				const auto why = errno_as_text();
+				LOG_F(INFO, "Reopening file '%s' due to '%s'", file_abs->path, why.c_str());
+			} else {
+				LOG_F(INFO, "Reopening file '%s' due to file changed", file_abs->path);
+			}
+			// try reopen current file.
+			if (!create_directories(file_abs->path)) {
+				LOG_F(ERROR, "Failed to create directories to '%s'", file_abs->path);
+			}
+			file_abs->fp = fopen(file_abs->path, file_abs->mode_str);
+			if (!file_abs->fp) {
+				LOG_F(ERROR, "Failed to open '%s'", file_abs->path);
+			} else {
+				stat(file_abs->path, &file_abs->st);
+			}
+			file_abs->is_reopening = false;
+		}
+	}
+#endif
+	// ------------------------------------------------------------------------------
+
+	// Helpers:
+
+	Text::~Text() { free(_str); }
+
+	LOGURU_PRINTF_LIKE(1, 0)
+	static Text vtextprintf(const char* format, va_list vlist)
+	{
+#ifdef _WIN32
+		int bytes_needed = _vscprintf(format, vlist);
+		CHECK_F(bytes_needed >= 0, "Bad string format: '%s'", format);
+		char* buff = (char*)malloc(bytes_needed+1);
+		vsnprintf(buff, bytes_needed+1, format, vlist);
+		return Text(buff);
+#else
+		char* buff = nullptr;
+		int result = vasprintf(&buff, format, vlist);
+		CHECK_F(result >= 0, "Bad string format: '%s'", format);
+		return Text(buff);
+#endif
+	}
+
+	Text textprintf(const char* format, ...)
+	{
+		va_list vlist;
+		va_start(vlist, format);
+		auto result = vtextprintf(format, vlist);
+		va_end(vlist);
+		return result;
+	}
+
+	// Overloaded for variadic template matching.
+	Text textprintf()
+	{
+		return Text(static_cast<char*>(calloc(1, 1)));
+	}
+
+	static const char* indentation(unsigned depth)
+	{
+		static const char buff[] =
+		".   .   .   .   .   .   .   .   .   .   " ".   .   .   .   .   .   .   .   .   .   "
+		".   .   .   .   .   .   .   .   .   .   " ".   .   .   .   .   .   .   .   .   .   "
+		".   .   .   .   .   .   .   .   .   .   " ".   .   .   .   .   .   .   .   .   .   "
+		".   .   .   .   .   .   .   .   .   .   " ".   .   .   .   .   .   .   .   .   .   "
+		".   .   .   .   .   .   .   .   .   .   " ".   .   .   .   .   .   .   .   .   .   ";
+		static const size_t INDENTATION_WIDTH = 4;
+		static const size_t NUM_INDENTATIONS = (sizeof(buff) - 1) / INDENTATION_WIDTH;
+		depth = std::min<unsigned>(depth, NUM_INDENTATIONS);
+		return buff + INDENTATION_WIDTH * (NUM_INDENTATIONS - depth);
+	}
+
+	static void parse_args(int& argc, char* argv[], const char* verbosity_flag)
+	{
+		int arg_dest = 1;
+		int out_argc = argc;
+
+		for (int arg_it = 1; arg_it < argc; ++arg_it) {
+			auto cmd = argv[arg_it];
+			auto arg_len = strlen(verbosity_flag);
+			if (strncmp(cmd, verbosity_flag, arg_len) == 0 && !std::isalpha(cmd[arg_len], std::locale(""))) {
+				out_argc -= 1;
+				auto value_str = cmd + arg_len;
+				if (value_str[0] == '\0') {
+					// Value in separate argument
+					arg_it += 1;
+					CHECK_LT_F(arg_it, argc, "Missing verbosiy level after %s", verbosity_flag);
+					value_str = argv[arg_it];
+					out_argc -= 1;
+				}
+				if (*value_str == '=') { value_str += 1; }
+
+				if (strcmp(value_str, "OFF") == 0) {
+					g_stderr_verbosity = Verbosity_OFF;
+				} else if (strcmp(value_str, "INFO") == 0) {
+					g_stderr_verbosity = Verbosity_INFO;
+				} else if (strcmp(value_str, "WARNING") == 0) {
+					g_stderr_verbosity = Verbosity_WARNING;
+				} else if (strcmp(value_str, "ERROR") == 0) {
+					g_stderr_verbosity = Verbosity_ERROR;
+				} else if (strcmp(value_str, "FATAL") == 0) {
+					g_stderr_verbosity = Verbosity_FATAL;
+				} else {
+					char* end = 0;
+					g_stderr_verbosity = static_cast<int>(strtol(value_str, &end, 10));
+					CHECK_F(end && *end == '\0',
+						"Invalid verbosity. Expected integer, INFO, WARNING, ERROR or OFF, got '%s'", value_str);
+				}
+			} else {
+				argv[arg_dest++] = argv[arg_it];
+			}
+		}
+
+		argc = out_argc;
+		argv[argc] = nullptr;
+	}
+
+	static long long now_ns()
+	{
+		return duration_cast<nanoseconds>(high_resolution_clock::now().time_since_epoch()).count();
+	}
+
+	// Returns the part of the path after the last / or \ (if any).
+	const char* filename(const char* path)
+	{
+		for (auto ptr = path; *ptr; ++ptr) {
+			if (*ptr == '/' || *ptr == '\\') {
+				path = ptr + 1;
+			}
+		}
+		return path;
+	}
+
+	// ------------------------------------------------------------------------------
+
+	static void on_atexit()
+	{
+		LOG_F(INFO, "atexit");
+		flush();
+	}
+
+	static void install_signal_handlers();
+
+	static void write_hex_digit(std::string& out, unsigned num)
+	{
+		DCHECK_LT_F(num, 16u);
+		if (num < 10u) { out.push_back(char('0' + num)); }
+		else { out.push_back(char('A' + num - 10)); }
+	}
+
+	static void write_hex_byte(std::string& out, uint8_t n)
+	{
+		write_hex_digit(out, n >> 4u);
+		write_hex_digit(out, n & 0x0f);
+	}
+
+	static void escape(std::string& out, const std::string& str)
+	{
+		for (char c : str) {
+			/**/ if (c == '\a') { out += "\\a";  }
+			else if (c == '\b') { out += "\\b";  }
+			else if (c == '\f') { out += "\\f";  }
+			else if (c == '\n') { out += "\\n";  }
+			else if (c == '\r') { out += "\\r";  }
+			else if (c == '\t') { out += "\\t";  }
+			else if (c == '\v') { out += "\\v";  }
+			else if (c == '\\') { out += "\\\\"; }
+			else if (c == '\'') { out += "\\\'"; }
+			else if (c == '\"') { out += "\\\""; }
+			else if (c == ' ')  { out += "\\ ";  }
+			else if (0 <= c && c < 0x20) { // ASCI control character:
+			// else if (c < 0x20 || c != (c & 127)) { // ASCII control character or UTF-8:
+				out += "\\x";
+				write_hex_byte(out, static_cast<uint8_t>(c));
+			} else { out += c; }
+		}
+	}
+
+	Text errno_as_text()
+	{
+		char buff[256];
+	#if defined(__GLIBC__) && defined(_GNU_SOURCE)
+		// GNU Version
+		return Text(strdup(strerror_r(errno, buff, sizeof(buff))));
+	#elif defined(__APPLE__) || _POSIX_C_SOURCE >= 200112L
+		// XSI Version
+		strerror_r(errno, buff, sizeof(buff));
+		return Text(strdup(buff));
+	#elif defined(_WIN32)
+		strerror_s(buff, sizeof(buff), errno);
+		return Text(strdup(buff));
+	#else
+		// Not thread-safe.
+		return Text(strdup(strerror(errno)));
+	#endif
+	}
+
+	void init(int& argc, char* argv[], const char* verbosity_flag)
+	{
+		CHECK_GT_F(argc,       0,       "Expected proper argc/argv");
+		CHECK_EQ_F(argv[argc], nullptr, "Expected proper argc/argv");
+
+		s_argv0_filename = filename(argv[0]);
+
+		#ifdef _WIN32
+			#define getcwd _getcwd
+		#endif
+
+		if (!getcwd(s_current_dir, sizeof(s_current_dir)))
+		{
+			const auto error_text = errno_as_text();
+			LOG_F(WARNING, "Failed to get current working directory: %s", error_text.c_str());
+		}
+
+		s_arguments = "";
+		for (int i = 0; i < argc; ++i) {
+			escape(s_arguments, argv[i]);
+			if (i + 1 < argc) {
+				s_arguments += " ";
+			}
+		}
+
+		if (verbosity_flag) {
+			parse_args(argc, argv, verbosity_flag);
+		}
+
+		#if LOGURU_PTLS_NAMES || LOGURU_WINTHREADS
+			set_thread_name("main thread");
+		#elif LOGURU_PTHREADS
+			char old_thread_name[16] = {0};
+			auto this_thread = pthread_self();
+			#if defined(__APPLE__) || defined(__linux__)
+				pthread_getname_np(this_thread, old_thread_name, sizeof(old_thread_name));
+			#endif
+			if (old_thread_name[0] == 0) {
+				#ifdef __APPLE__
+					pthread_setname_np("main thread");
+				#elif defined(__FreeBSD__) || defined(__OpenBSD__)
+					pthread_set_name_np(this_thread, "main thread");
+				#elif defined(__linux__)
+					pthread_setname_np(this_thread, "main thread");
+				#endif
+			}
+		#endif // LOGURU_PTHREADS
+
+		if (g_stderr_verbosity >= Verbosity_INFO) {
+			if (g_preamble) {
+				char preamble_explain[LOGURU_PREAMBLE_WIDTH];
+				print_preamble_header(preamble_explain, sizeof(preamble_explain));
+				if (g_colorlogtostderr && s_terminal_has_color) {
+					fprintf(stderr, "%s%s%s\n", terminal_reset(), terminal_dim(), preamble_explain);
+				} else {
+					fprintf(stderr, "%s\n", preamble_explain);
+				}
+			}
+			fflush(stderr);
+		}
+		LOG_F(INFO, "arguments: %s", s_arguments.c_str());
+		if (strlen(s_current_dir) != 0)
+		{
+			LOG_F(INFO, "Current dir: %s", s_current_dir);
+		}
+		LOG_F(INFO, "stderr verbosity: %d", g_stderr_verbosity);
+		LOG_F(INFO, "-----------------------------------");
+
+		install_signal_handlers();
+
+		atexit(on_atexit);
+	}
+
+	void shutdown()
+	{
+		LOG_F(INFO, "loguru::shutdown()");
+		remove_all_callbacks();
+		set_fatal_handler(nullptr);
+	}
+
+	void write_date_time(char* buff, size_t buff_size)
+	{
+		auto now = system_clock::now();
+		long long ms_since_epoch = duration_cast<milliseconds>(now.time_since_epoch()).count();
+		time_t sec_since_epoch = time_t(ms_since_epoch / 1000);
+		tm time_info;
+		localtime_r(&sec_since_epoch, &time_info);
+		snprintf(buff, buff_size, "%04d%02d%02d_%02d%02d%02d.%03lld",
+			1900 + time_info.tm_year, 1 + time_info.tm_mon, time_info.tm_mday,
+			time_info.tm_hour, time_info.tm_min, time_info.tm_sec, ms_since_epoch % 1000);
+	}
+
+	const char* argv0_filename()
+	{
+		return s_argv0_filename.c_str();
+	}
+
+	const char* arguments()
+	{
+		return s_arguments.c_str();
+	}
+
+	const char* current_dir()
+	{
+		return s_current_dir;
+	}
+
+	const char* home_dir()
+	{
+		#ifdef _WIN32
+			auto user_profile = getenv("USERPROFILE");
+			CHECK_F(user_profile != nullptr, "Missing USERPROFILE");
+			return user_profile;
+		#else // _WIN32
+			auto home = getenv("HOME");
+			CHECK_F(home != nullptr, "Missing HOME");
+			return home;
+		#endif // _WIN32
+	}
+
+	void suggest_log_path(const char* prefix, char* buff, unsigned buff_size)
+	{
+		if (prefix[0] == '~') {
+			snprintf(buff, buff_size - 1, "%s%s", home_dir(), prefix + 1);
+		} else {
+			snprintf(buff, buff_size - 1, "%s", prefix);
+		}
+
+		// Check for terminating /
+		size_t n = strlen(buff);
+		if (n != 0) {
+			if (buff[n - 1] != '/') {
+				CHECK_F(n + 2 < buff_size, "Filename buffer too small");
+				buff[n] = '/';
+				buff[n + 1] = '\0';
+			}
+		}
+
+		strncat(buff, s_argv0_filename.c_str(), buff_size - strlen(buff) - 1);
+		strncat(buff, "/",                      buff_size - strlen(buff) - 1);
+		write_date_time(buff + strlen(buff),    buff_size - strlen(buff));
+		strncat(buff, ".log",                   buff_size - strlen(buff) - 1);
+	}
+
+	bool create_directories(const char* file_path_const)
+	{
+		CHECK_F(file_path_const && *file_path_const);
+		char* file_path = strdup(file_path_const);
+		for (char* p = strchr(file_path + 1, '/'); p; p = strchr(p + 1, '/')) {
+			*p = '\0';
+
+	#ifdef _WIN32
+			if (_mkdir(file_path) == -1) {
+	#else
+			if (mkdir(file_path, 0755) == -1) {
+	#endif
+				if (errno != EEXIST) {
+					LOG_F(ERROR, "Failed to create directory '%s'", file_path);
+					LOG_IF_F(ERROR, errno == EACCES,       "EACCES");
+					LOG_IF_F(ERROR, errno == ENAMETOOLONG, "ENAMETOOLONG");
+					LOG_IF_F(ERROR, errno == ENOENT,       "ENOENT");
+					LOG_IF_F(ERROR, errno == ENOTDIR,      "ENOTDIR");
+					LOG_IF_F(ERROR, errno == ELOOP,        "ELOOP");
+
+					*p = '/';
+					free(file_path);
+					return false;
+				}
+			}
+			*p = '/';
+		}
+		free(file_path);
+		return true;
+	}
+	bool add_file(const char* path_in, FileMode mode, Verbosity verbosity)
+	{
+		char path[PATH_MAX];
+		if (path_in[0] == '~') {
+			snprintf(path, sizeof(path) - 1, "%s%s", home_dir(), path_in + 1);
+		} else {
+			snprintf(path, sizeof(path) - 1, "%s", path_in);
+		}
+
+		if (!create_directories(path)) {
+			LOG_F(ERROR, "Failed to create directories to '%s'", path);
+		}
+
+		const char* mode_str = (mode == FileMode::Truncate ? "w" : "a");
+		auto file = fopen(path, mode_str);
+		if (!file) {
+			LOG_F(ERROR, "Failed to open '%s'", path);
+			return false;
+		}
+#if LOGURU_WITH_FILEABS
+		FileAbs* file_abs = new FileAbs(); // this is deleted in file_close;
+		snprintf(file_abs->path, sizeof(file_abs->path) - 1, "%s", path);
+		snprintf(file_abs->mode_str, sizeof(file_abs->mode_str) - 1, "%s", mode_str);
+		stat(file_abs->path, &file_abs->st);
+		file_abs->fp = file;
+		file_abs->verbosity = verbosity;
+		add_callback(path_in, file_log, file_abs, verbosity, file_close, file_flush);
+#else
+		add_callback(path_in, file_log, file, verbosity, file_close, file_flush);
+#endif
+
+		if (mode == FileMode::Append) {
+			fprintf(file, "\n\n\n\n\n");
+		}
+		if (!s_arguments.empty()) {
+			fprintf(file, "arguments: %s\n", s_arguments.c_str());
+		}
+		if (strlen(s_current_dir) != 0) {
+			fprintf(file, "Current dir: %s\n", s_current_dir);
+		}
+		fprintf(file, "File verbosity level: %d\n", verbosity);
+		if (g_preamble) {
+			char preamble_explain[LOGURU_PREAMBLE_WIDTH];
+			print_preamble_header(preamble_explain, sizeof(preamble_explain));
+			fprintf(file, "%s\n", preamble_explain);
+		}
+		fflush(file);
+
+		LOG_F(INFO, "Logging to '%s', mode: '%s', verbosity: %d", path, mode_str, verbosity);
+		return true;
+	}
+
+	// Will be called right before abort().
+	void set_fatal_handler(fatal_handler_t handler)
+	{
+		s_fatal_handler = handler;
+	}
+
+	fatal_handler_t get_fatal_handler()
+	{
+		return s_fatal_handler;
+	}
+
+	void add_stack_cleanup(const char* find_this, const char* replace_with_this)
+	{
+		if (strlen(find_this) <= strlen(replace_with_this)) {
+			LOG_F(WARNING, "add_stack_cleanup: the replacement should be shorter than the pattern!");
+			return;
+		}
+
+		s_user_stack_cleanups.push_back(StringPair(find_this, replace_with_this));
+	}
+
+	static void on_callback_change()
+	{
+		s_max_out_verbosity = Verbosity_OFF;
+		for (const auto& callback : s_callbacks) {
+			s_max_out_verbosity = std::max(s_max_out_verbosity, callback.verbosity);
+		}
+	}
+
+	void add_callback(
+		const char*     id,
+		log_handler_t   callback,
+		void*           user_data,
+		Verbosity       verbosity,
+		close_handler_t on_close,
+		flush_handler_t on_flush)
+	{
+		std::lock_guard<std::recursive_mutex> lock(s_mutex);
+		s_callbacks.push_back(Callback{id, callback, user_data, verbosity, on_close, on_flush, 0});
+		on_callback_change();
+	}
+
+	bool remove_callback(const char* id)
+	{
+		std::lock_guard<std::recursive_mutex> lock(s_mutex);
+		auto it = std::find_if(begin(s_callbacks), end(s_callbacks), [&](const Callback& c) { return c.id == id; });
+		if (it != s_callbacks.end()) {
+			if (it->close) { it->close(it->user_data); }
+			s_callbacks.erase(it);
+			on_callback_change();
+			return true;
+		} else {
+			LOG_F(ERROR, "Failed to locate callback with id '%s'", id);
+			return false;
+		}
+	}
+
+	void remove_all_callbacks()
+	{
+		std::lock_guard<std::recursive_mutex> lock(s_mutex);
+		for (auto& callback : s_callbacks) {
+			if (callback.close) {
+				callback.close(callback.user_data);
+			}
+		}
+		s_callbacks.clear();
+		on_callback_change();
+	}
+
+	// Returns the maximum of g_stderr_verbosity and all file/custom outputs.
+	Verbosity current_verbosity_cutoff()
+	{
+		return g_stderr_verbosity > s_max_out_verbosity ?
+			   g_stderr_verbosity : s_max_out_verbosity;
+	}
+
+#if LOGURU_WINTHREADS
+	char* get_thread_name_win32()
+	{
+		__declspec( thread ) static char thread_name[LOGURU_THREADNAME_WIDTH + 1] = {0};
+		return &thread_name[0];
+	}
+#endif // LOGURU_WINTHREADS
+
+	void set_thread_name(const char* name)
+	{
+		#if LOGURU_PTLS_NAMES
+			(void)pthread_once(&s_pthread_key_once, make_pthread_key_name);
+			(void)pthread_setspecific(s_pthread_key_name, strdup(name));
+
+		#elif LOGURU_PTHREADS
+			#ifdef __APPLE__
+				pthread_setname_np(name);
+			#elif defined(__FreeBSD__) || defined(__OpenBSD__)
+				pthread_set_name_np(pthread_self(), name);
+			#elif defined(__linux__)
+				pthread_setname_np(pthread_self(), name);
+			#endif
+		#elif LOGURU_WINTHREADS
+			strncpy_s(get_thread_name_win32(), LOGURU_THREADNAME_WIDTH + 1, name, _TRUNCATE);
+		#else // LOGURU_PTHREADS
+			(void)name;
+		#endif // LOGURU_PTHREADS
+	}
+
+#if LOGURU_PTLS_NAMES
+	const char* get_thread_name_ptls()
+	{
+		(void)pthread_once(&s_pthread_key_once, make_pthread_key_name);
+		return static_cast<const char*>(pthread_getspecific(s_pthread_key_name));
+	}
+#endif // LOGURU_PTLS_NAMES
+
+	void get_thread_name(char* buffer, unsigned long long length, bool right_align_hext_id)
+	{
+		CHECK_NE_F(length, 0u, "Zero length buffer in get_thread_name");
+		CHECK_NOTNULL_F(buffer, "nullptr in get_thread_name");
+#if LOGURU_PTHREADS
+		auto thread = pthread_self();
+		#if LOGURU_PTLS_NAMES
+			if (const char* name = get_thread_name_ptls()) {
+				snprintf(buffer, length, "%s", name);
+			} else {
+				buffer[0] = 0;
+			}
+		#elif defined(__APPLE__) || defined(__linux__)
+			pthread_getname_np(thread, buffer, length);
+		#else
+			buffer[0] = 0;
+		#endif
+
+		if (buffer[0] == 0) {
+			#ifdef __APPLE__
+				uint64_t thread_id;
+				pthread_threadid_np(thread, &thread_id);
+			#elif defined(__FreeBSD__)
+				long thread_id;
+				(void)thr_self(&thread_id);
+			#elif defined(__OpenBSD__)
+				unsigned thread_id = -1;
+			#else
+				uint64_t thread_id = thread;
+			#endif
+			if (right_align_hext_id) {
+				snprintf(buffer, length, "%*X", length - 1, static_cast<unsigned>(thread_id));
+			} else {
+				snprintf(buffer, length, "%X", static_cast<unsigned>(thread_id));
+			}
+		}
+#elif LOGURU_WINTHREADS
+		if (const char* name = get_thread_name_win32()) {
+			snprintf(buffer, (size_t)length, "%s", name);
+		} else {
+			buffer[0] = 0;
+		}
+#else // !LOGURU_WINTHREADS && !LOGURU_WINTHREADS
+		buffer[0] = 0;
+#endif
+
+	}
+
+	// ------------------------------------------------------------------------
+	// Stack traces
+
+#if LOGURU_STACKTRACES
+	Text demangle(const char* name)
+	{
+		int status = -1;
+		char* demangled = abi::__cxa_demangle(name, 0, 0, &status);
+		Text result{status == 0 ? demangled : strdup(name)};
+		return result;
+	}
+
+	#if LOGURU_RTTI
+		template <class T>
+		std::string type_name()
+		{
+			auto demangled = demangle(typeid(T).name());
+			return demangled.c_str();
+		}
+	#endif // LOGURU_RTTI
+
+	static const StringPairList REPLACE_LIST = {
+		#if LOGURU_RTTI
+			{ type_name<std::string>(),    "std::string"    },
+			{ type_name<std::wstring>(),   "std::wstring"   },
+			{ type_name<std::u16string>(), "std::u16string" },
+			{ type_name<std::u32string>(), "std::u32string" },
+		#endif // LOGURU_RTTI
+		{ "std::__1::",                "std::"          },
+		{ "__thiscall ",               ""               },
+		{ "__cdecl ",                  ""               },
+	};
+
+	void do_replacements(const StringPairList& replacements, std::string& str)
+	{
+		for (auto&& p : replacements) {
+			if (p.first.size() <= p.second.size()) {
+				// On gcc, "type_name<std::string>()" is "std::string"
+				continue;
+			}
+
+			size_t it;
+			while ((it=str.find(p.first)) != std::string::npos) {
+				str.replace(it, p.first.size(), p.second);
+			}
+		}
+	}
+
+	std::string prettify_stacktrace(const std::string& input)
+	{
+		std::string output = input;
+
+		do_replacements(s_user_stack_cleanups, output);
+		do_replacements(REPLACE_LIST, output);
+
+		try {
+			std::regex std_allocator_re(R"(,\s*std::allocator<[^<>]+>)");
+			output = std::regex_replace(output, std_allocator_re, std::string(""));
+
+			std::regex template_spaces_re(R"(<\s*([^<> ]+)\s*>)");
+			output = std::regex_replace(output, template_spaces_re, std::string("<$1>"));
+		} catch (std::regex_error&) {
+			// Probably old GCC.
+		}
+
+		return output;
+	}
+
+	std::string stacktrace_as_stdstring(int skip)
+	{
+        return "";
+/*
+		// From https://gist.github.com/fmela/591333
+		void* callstack[128];
+		const auto max_frames = sizeof(callstack) / sizeof(callstack[0]);
+		int num_frames = backtrace(callstack, max_frames);
+		char** symbols = backtrace_symbols(callstack, num_frames);
+
+		std::string result;
+		// Print stack traces so the most relevant ones are written last
+		// Rationale: http://yellerapp.com/posts/2015-01-22-upside-down-stacktraces.html
+		for (int i = num_frames - 1; i >= skip; --i) {
+			char buf[1024];
+			Dl_info info;
+			if (dladdr(callstack[i], &info) && info.dli_sname) {
+				char* demangled = NULL;
+				int status = -1;
+				if (info.dli_sname[0] == '_') {
+					demangled = abi::__cxa_demangle(info.dli_sname, 0, 0, &status);
+				}
+				snprintf(buf, sizeof(buf), "%-3d %*p %s + %zd\n",
+						 i - skip, int(2 + sizeof(void*) * 2), callstack[i],
+						 status == 0 ? demangled :
+						 info.dli_sname == 0 ? symbols[i] : info.dli_sname,
+						 static_cast<char*>(callstack[i]) - static_cast<char*>(info.dli_saddr));
+				free(demangled);
+			} else {
+				snprintf(buf, sizeof(buf), "%-3d %*p %s\n",
+						 i - skip, int(2 + sizeof(void*) * 2), callstack[i], symbols[i]);
+			}
+			result += buf;
+		}
+		free(symbols);
+
+		if (num_frames == max_frames) {
+			result = "[truncated]\n" + result;
+		}
+
+		if (!result.empty() && result[result.size() - 1] == '\n') {
+			result.resize(result.size() - 1);
+		}
+
+		return prettify_stacktrace(result);*/
+	}
+
+#else // LOGURU_STACKTRACES
+	Text demangle(const char* name)
+	{
+		return Text(strdup(name));
+	}
+
+	std::string stacktrace_as_stdstring(int)
+	{
+		// No stacktraces available on this platform"
+		return "";
+	}
+
+#endif // LOGURU_STACKTRACES
+
+	Text stacktrace(int skip)
+	{
+		auto str = stacktrace_as_stdstring(skip + 1);
+		return Text(strdup(str.c_str()));
+	}
+
+	// ------------------------------------------------------------------------
+
+	static void print_preamble_header(char* out_buff, size_t out_buff_size)
+	{
+		long pos = 0;
+		snprintf(out_buff, out_buff_size, ""); // Make sure there is a '\0' and handle out_buff_size==0
+		if (g_preamble_date && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "date       ");
+		}
+		if (g_preamble_time && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "time         ");
+		}
+		if (g_preamble_uptime && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "( uptime  ) ");
+		}
+		if (g_preamble_thread && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "[%-*s]", LOGURU_THREADNAME_WIDTH, " thread name/id");
+		}
+		if (g_preamble_file && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "%*s:line  ", LOGURU_FILENAME_WIDTH, "file");
+		}
+		if (g_preamble_verbose && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "   v");
+		}
+		if (g_preamble_pipe && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "| ");
+		}
+	}
+
+	static void print_preamble(char* out_buff, size_t out_buff_size, Verbosity verbosity, const char* file, unsigned line)
+	{
+		if (!g_preamble) {
+			out_buff[0] = '\0';
+			return;
+		}
+		long long ms_since_epoch = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
+		time_t sec_since_epoch = time_t(ms_since_epoch / 1000);
+		tm time_info;
+		localtime_r(&sec_since_epoch, &time_info);
+
+		auto uptime_ms = duration_cast<milliseconds>(steady_clock::now() - s_start_time).count();
+		auto uptime_sec = uptime_ms / 1000.0;
+
+		char thread_name[LOGURU_THREADNAME_WIDTH + 1] = {0};
+		get_thread_name(thread_name, LOGURU_THREADNAME_WIDTH + 1, true);
+
+		if (s_strip_file_path) {
+			file = filename(file);
+		}
+
+		char level_buff[6];
+		if (verbosity <= Verbosity_FATAL) {
+			snprintf(level_buff, sizeof(level_buff) - 1, "FATL");
+		} else if (verbosity == Verbosity_ERROR) {
+			snprintf(level_buff, sizeof(level_buff) - 1, "ERR");
+		} else if (verbosity == Verbosity_WARNING) {
+			snprintf(level_buff, sizeof(level_buff) - 1, "WARN");
+		} else {
+			snprintf(level_buff, sizeof(level_buff) - 1, "% 4d", verbosity);
+		}
+
+		long pos = 0;
+
+		snprintf(out_buff, out_buff_size, ""); // Make sure there is a '\0' and handle out_buff_size==0
+		if (g_preamble_date && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "%04d-%02d-%02d ",
+				             1900 + time_info.tm_year, 1 + time_info.tm_mon, time_info.tm_mday);
+		}
+		if (g_preamble_time && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "%02d:%02d:%02d.%03lld ",
+			               time_info.tm_hour, time_info.tm_min, time_info.tm_sec, ms_since_epoch % 1000);
+		}
+		if (g_preamble_uptime && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "(%8.3fs) ",
+			               uptime_sec);
+		}
+		if (g_preamble_thread && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "[%-*s]",
+			               LOGURU_THREADNAME_WIDTH, thread_name);
+		}
+		if (g_preamble_file && pos < out_buff_size) {
+			char shortened_filename[LOGURU_FILENAME_WIDTH + 1];
+			snprintf(shortened_filename, LOGURU_FILENAME_WIDTH + 1, "%s", file);
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "%*s:%-5u ",
+			               LOGURU_FILENAME_WIDTH, shortened_filename, line);
+		}
+		if (g_preamble_verbose && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "%4s",
+			               level_buff);
+		}
+		if (g_preamble_pipe && pos < out_buff_size) {
+			pos += snprintf(out_buff + pos, out_buff_size - pos, "| ");
+		}
+	}
+
+	// stack_trace_skip is just if verbosity == FATAL.
+	static void log_message(int stack_trace_skip, Message& message, bool with_indentation, bool abort_if_fatal)
+	{
+		const auto verbosity = message.verbosity;
+		std::lock_guard<std::recursive_mutex> lock(s_mutex);
+
+		if (message.verbosity == Verbosity_FATAL) {
+			auto st = loguru::stacktrace(stack_trace_skip + 2);
+			if (!st.empty()) {
+				RAW_LOG_F(ERROR, "Stack trace:\n%s", st.c_str());
+			}
+
+			auto ec = loguru::get_error_context();
+			if (!ec.empty()) {
+				RAW_LOG_F(ERROR, "%s", ec.c_str());
+			}
+		}
+
+		if (with_indentation) {
+			message.indentation = indentation(s_stderr_indentation);
+		}
+
+		if (verbosity <= g_stderr_verbosity) {
+			if (g_colorlogtostderr && s_terminal_has_color) {
+				if (verbosity > Verbosity_WARNING) {
+					fprintf(stderr, "%s%s%s%s%s%s%s%s%s\n",
+						terminal_reset(),
+						terminal_dim(),
+						message.preamble,
+						message.indentation,
+						terminal_reset(),
+						verbosity == Verbosity_INFO ? terminal_bold() : terminal_light_gray(),
+						message.prefix,
+						message.message,
+						terminal_reset());
+				} else {
+					fprintf(stderr, "%s%s%s%s%s%s%s%s\n",
+						terminal_reset(),
+						terminal_bold(),
+						verbosity == Verbosity_WARNING ? terminal_red() : terminal_light_red(),
+						message.preamble,
+						message.indentation,
+						message.prefix,
+						message.message,
+						terminal_reset());
+				}
+			} else {
+				fprintf(stderr, "%s%s%s%s\n",
+					message.preamble, message.indentation, message.prefix, message.message);
+			}
+
+			if (g_flush_interval_ms == 0) {
+				fflush(stderr);
+			} else {
+				s_needs_flushing = true;
+			}
+		}
+
+		for (auto& p : s_callbacks) {
+			if (verbosity <= p.verbosity) {
+				if (with_indentation) {
+					message.indentation = indentation(p.indentation);
+				}
+				p.callback(p.user_data, message);
+				if (g_flush_interval_ms == 0) {
+					if (p.flush) { p.flush(p.user_data); }
+				} else {
+					s_needs_flushing = true;
+				}
+			}
+		}
+
+		if (g_flush_interval_ms > 0 && !s_flush_thread) {
+			s_flush_thread = new std::thread([](){
+				for (;;) {
+					if (s_needs_flushing) {
+						flush();
+					}
+					std::this_thread::sleep_for(std::chrono::milliseconds(g_flush_interval_ms));
+				}
+			});
+		}
+
+		if (message.verbosity == Verbosity_FATAL) {
+			flush();
+
+			if (s_fatal_handler) {
+				s_fatal_handler(message);
+				flush();
+			}
+
+			if (abort_if_fatal) {
+#if LOGURU_CATCH_SIGABRT && !defined(_WIN32)
+				// Make sure we don't catch our own abort:
+				signal(SIGABRT, SIG_DFL);
+#endif
+				abort();
+			}
+		}
+	}
+
+	// stack_trace_skip is just if verbosity == FATAL.
+	void log_to_everywhere(int stack_trace_skip, Verbosity verbosity,
+	                       const char* file, unsigned line,
+	                       const char* prefix, const char* buff)
+	{
+		char preamble_buff[LOGURU_PREAMBLE_WIDTH];
+		print_preamble(preamble_buff, sizeof(preamble_buff), verbosity, file, line);
+		auto message = Message{verbosity, file, line, preamble_buff, "", prefix, buff};
+		log_message(stack_trace_skip + 1, message, true, true);
+	}
+
+#if LOGURU_USE_FMTLIB
+	void log(Verbosity verbosity, const char* file, unsigned line, const char* format, fmt::ArgList args)
+	{
+		auto formatted = fmt::format(format, args);
+		log_to_everywhere(1, verbosity, file, line, "", formatted.c_str());
+	}
+
+	void raw_log(Verbosity verbosity, const char* file, unsigned line, const char* format, fmt::ArgList args)
+	{
+		auto formatted = fmt::format(format, args);
+		auto message = Message{verbosity, file, line, "", "", "", formatted.c_str()};
+		log_message(1, message, false, true);
+	}
+
+#else
+	void log(Verbosity verbosity, const char* file, unsigned line, const char* format, ...)
+	{
+		va_list vlist;
+		va_start(vlist, format);
+		auto buff = vtextprintf(format, vlist);
+		log_to_everywhere(1, verbosity, file, line, "", buff.c_str());
+		va_end(vlist);
+	}
+
+	void raw_log(Verbosity verbosity, const char* file, unsigned line, const char* format, ...)
+	{
+		va_list vlist;
+		va_start(vlist, format);
+		auto buff = vtextprintf(format, vlist);
+		auto message = Message{verbosity, file, line, "", "", "", buff.c_str()};
+		log_message(1, message, false, true);
+		va_end(vlist);
+	}
+#endif
+
+	void flush()
+	{
+		std::lock_guard<std::recursive_mutex> lock(s_mutex);
+		fflush(stderr);
+		for (const auto& callback : s_callbacks)
+		{
+			if (callback.flush) {
+				callback.flush(callback.user_data);
+			}
+		}
+		s_needs_flushing = false;
+	}
+
+	LogScopeRAII::LogScopeRAII(Verbosity verbosity, const char* file, unsigned line, const char* format, ...)
+		: _verbosity(verbosity), _file(file), _line(line)
+	{
+		if (verbosity <= current_verbosity_cutoff()) {
+			std::lock_guard<std::recursive_mutex> lock(s_mutex);
+			_indent_stderr = (verbosity <= g_stderr_verbosity);
+			_start_time_ns = now_ns();
+			va_list vlist;
+			va_start(vlist, format);
+			vsnprintf(_name, sizeof(_name), format, vlist);
+			log_to_everywhere(1, _verbosity, file, line, "{ ", _name);
+			va_end(vlist);
+
+			if (_indent_stderr) {
+				++s_stderr_indentation;
+			}
+
+			for (auto& p : s_callbacks) {
+				if (verbosity <= p.verbosity) {
+					++p.indentation;
+				}
+			}
+		} else {
+			_file = nullptr;
+		}
+	}
+
+	LogScopeRAII::~LogScopeRAII()
+	{
+		if (_file) {
+			std::lock_guard<std::recursive_mutex> lock(s_mutex);
+			if (_indent_stderr && s_stderr_indentation > 0) {
+				--s_stderr_indentation;
+			}
+			for (auto& p : s_callbacks) {
+				// Note: Callback indentation cannot change!
+				if (_verbosity <= p.verbosity) {
+					// in unlikely case this callback is new
+					if (p.indentation > 0) {
+						--p.indentation;
+					}
+				}
+			}
+			auto duration_sec = (now_ns() - _start_time_ns) / 1e9;
+			auto buff = textprintf("%.*f s: %s", SCOPE_TIME_PRECISION, duration_sec, _name);
+			log_to_everywhere(1, _verbosity, _file, _line, "} ", buff.c_str());
+		}
+	}
+
+	void log_and_abort(int stack_trace_skip, const char* expr, const char* file, unsigned line, const char* format, ...)
+	{
+		va_list vlist;
+		va_start(vlist, format);
+		auto buff = vtextprintf(format, vlist);
+		log_to_everywhere(stack_trace_skip + 1, Verbosity_FATAL, file, line, expr, buff.c_str());
+		va_end(vlist);
+		abort(); // log_to_everywhere already does this, but this makes the analyzer happy.
+	}
+
+	void log_and_abort(int stack_trace_skip, const char* expr, const char* file, unsigned line)
+	{
+		log_and_abort(stack_trace_skip + 1, expr, file, line, " ");
+	}
+
+	// ----------------------------------------------------------------------------
+	// Streams:
+
+	std::string vstrprintf(const char* format, va_list vlist)
+	{
+		auto text = vtextprintf(format, vlist);
+		std::string result = text.c_str();
+		return result;
+	}
+
+	std::string strprintf(const char* format, ...)
+	{
+		va_list vlist;
+		va_start(vlist, format);
+		auto result = vstrprintf(format, vlist);
+		va_end(vlist);
+		return result;
+	}
+
+	#if LOGURU_WITH_STREAMS
+
+	StreamLogger::~StreamLogger() noexcept(false)
+	{
+		auto message = _ss.str();
+		log(_verbosity, _file, _line, "%s", message.c_str());
+	}
+
+	AbortLogger::~AbortLogger() noexcept(false)
+	{
+		auto message = _ss.str();
+		loguru::log_and_abort(1, _expr, _file, _line, "%s", message.c_str());
+	}
+
+	#endif // LOGURU_WITH_STREAMS
+
+	// ----------------------------------------------------------------------------
+	// 888888 88""Yb 88""Yb  dP"Yb  88""Yb      dP""b8  dP"Yb  88b 88 888888 888888 Yb  dP 888888
+	// 88__   88__dP 88__dP dP   Yb 88__dP     dP   `" dP   Yb 88Yb88   88   88__    YbdP    88
+	// 88""   88"Yb  88"Yb  Yb   dP 88"Yb      Yb      Yb   dP 88 Y88   88   88""    dPYb    88
+	// 888888 88  Yb 88  Yb  YbodP  88  Yb      YboodP  YbodP  88  Y8   88   888888 dP  Yb   88
+	// ----------------------------------------------------------------------------
+
+	struct StringStream
+	{
+		std::string str;
+	};
+
+	// Use this in your EcPrinter implementations.
+	void stream_print(StringStream& out_string_stream, const char* text)
+	{
+		out_string_stream.str += text;
+	}
+
+	// ----------------------------------------------------------------------------
+
+	using ECPtr = EcEntryBase*;
+
+#if defined(_WIN32) || (defined(__APPLE__) && !TARGET_OS_IPHONE)
+	#ifdef __APPLE__
+		#define LOGURU_THREAD_LOCAL __thread
+	#else
+		#define LOGURU_THREAD_LOCAL thread_local
+	#endif
+	static LOGURU_THREAD_LOCAL ECPtr thread_ec_ptr = nullptr;
+
+	ECPtr& get_thread_ec_head_ref()
+	{
+		return thread_ec_ptr;
+	}
+#else // !thread_local
+	static pthread_once_t s_ec_pthread_once = PTHREAD_ONCE_INIT;
+	static pthread_key_t  s_ec_pthread_key;
+
+	void free_ec_head_ref(void* io_error_context)
+	{
+		delete reinterpret_cast<ECPtr*>(io_error_context);
+	}
+
+	void ec_make_pthread_key()
+	{
+		(void)pthread_key_create(&s_ec_pthread_key, free_ec_head_ref);
+	}
+
+	ECPtr& get_thread_ec_head_ref()
+	{
+		(void)pthread_once(&s_ec_pthread_once, ec_make_pthread_key);
+		auto ec = reinterpret_cast<ECPtr*>(pthread_getspecific(s_ec_pthread_key));
+		if (ec == nullptr) {
+			ec = new ECPtr(nullptr);
+			(void)pthread_setspecific(s_ec_pthread_key, ec);
+		}
+		return *ec;
+	}
+#endif // !thread_local
+
+	// ----------------------------------------------------------------------------
+
+	EcHandle get_thread_ec_handle()
+	{
+		return get_thread_ec_head_ref();
+	}
+
+	Text get_error_context()
+	{
+		return get_error_context_for(get_thread_ec_head_ref());
+	}
+
+	Text get_error_context_for(const EcEntryBase* ec_head)
+	{
+		std::vector<const EcEntryBase*> stack;
+		while (ec_head) {
+			stack.push_back(ec_head);
+			ec_head = ec_head->_previous;
+		}
+		std::reverse(stack.begin(), stack.end());
+
+		StringStream result;
+		if (!stack.empty()) {
+			result.str += "------------------------------------------------\n";
+			for (auto entry : stack) {
+				const auto description = std::string(entry->_descr) + ":";
+				auto prefix = textprintf("[ErrorContext] %*s:%-5u %-20s ",
+					LOGURU_FILENAME_WIDTH, filename(entry->_file), entry->_line, description.c_str());
+				result.str += prefix.c_str();
+				entry->print_value(result);
+				result.str += "\n";
+			}
+			result.str += "------------------------------------------------";
+		}
+		return Text(strdup(result.str.c_str()));
+	}
+
+	EcEntryBase::EcEntryBase(const char* file, unsigned line, const char* descr)
+		: _file(file), _line(line), _descr(descr)
+	{
+		EcEntryBase*& ec_head = get_thread_ec_head_ref();
+		_previous = ec_head;
+		ec_head = this;
+	}
+
+	EcEntryBase::~EcEntryBase()
+	{
+		get_thread_ec_head_ref() = _previous;
+	}
+
+	// ------------------------------------------------------------------------
+
+	Text ec_to_text(const char* value)
+	{
+		// Add quotes around the string to make it obvious where it begin and ends.
+		// This is great for detecting erroneous leading or trailing spaces in e.g. an identifier.
+		auto str = "\"" + std::string(value) + "\"";
+		return Text{strdup(str.c_str())};
+	}
+
+	Text ec_to_text(char c)
+	{
+		// Add quotes around the character to make it obvious where it begin and ends.
+		std::string str = "'";
+
+		auto write_hex_digit = [&](unsigned num)
+		{
+			if (num < 10u) { str += char('0' + num); }
+			else           { str += char('a' + num - 10); }
+		};
+
+		auto write_hex_16 = [&](uint16_t n)
+		{
+			write_hex_digit((n >> 12u) & 0x0f);
+			write_hex_digit((n >>  8u) & 0x0f);
+			write_hex_digit((n >>  4u) & 0x0f);
+			write_hex_digit((n >>  0u) & 0x0f);
+		};
+
+		if      (c == '\\') { str += "\\\\"; }
+		else if (c == '\"') { str += "\\\""; }
+		else if (c == '\'') { str += "\\\'"; }
+		else if (c == '\0') { str += "\\0";  }
+		else if (c == '\b') { str += "\\b";  }
+		else if (c == '\f') { str += "\\f";  }
+		else if (c == '\n') { str += "\\n";  }
+		else if (c == '\r') { str += "\\r";  }
+		else if (c == '\t') { str += "\\t";  }
+		else if (0 <= c && c < 0x20) {
+			str += "\\u";
+			write_hex_16(static_cast<uint16_t>(c));
+		} else { str += c; }
+
+		str += "'";
+
+		return Text{strdup(str.c_str())};
+	}
+
+	#define DEFINE_EC(Type)                        \
+		Text ec_to_text(Type value)                \
+		{                                          \
+			auto str = std::to_string(value);      \
+			return Text{strdup(str.c_str())};      \
+		}
+
+	DEFINE_EC(int)
+	DEFINE_EC(unsigned int)
+	DEFINE_EC(long)
+	DEFINE_EC(unsigned long)
+	DEFINE_EC(long long)
+	DEFINE_EC(unsigned long long)
+	DEFINE_EC(float)
+	DEFINE_EC(double)
+	DEFINE_EC(long double)
+
+	#undef DEFINE_EC
+
+	Text ec_to_text(EcHandle ec_handle)
+	{
+		Text parent_ec = get_error_context_for(ec_handle);
+		char* with_newline = (char*)malloc(strlen(parent_ec.c_str()) + 2);
+		with_newline[0] = '\n';
+		strcpy(with_newline + 1, parent_ec.c_str());
+		return Text(with_newline);
+	}
+
+	// ----------------------------------------------------------------------------
+
+} // namespace loguru
+
+// ----------------------------------------------------------------------------
+// .dP"Y8 88  dP""b8 88b 88    db    88     .dP"Y8
+// `Ybo." 88 dP   `" 88Yb88   dPYb   88     `Ybo."
+// o.`Y8b 88 Yb  "88 88 Y88  dP__Yb  88  .o o.`Y8b
+// 8bodP' 88  YboodP 88  Y8 dP""""Yb 88ood8 8bodP'
+// ----------------------------------------------------------------------------
+
+#ifdef _WIN32
+namespace loguru {
+	void install_signal_handlers()
+	{
+		#if defined(_MSC_VER)
+		#pragma message ( "No signal handlers on Win32" )
+		#else
+		#warning "No signal handlers on Win32"
+		#endif
+	}
+} // namespace loguru
+
+#else // _WIN32
+
+namespace loguru
+{
+	struct Signal
+	{
+		int         number;
+		const char* name;
+	};
+	const Signal ALL_SIGNALS[] = {
+#if LOGURU_CATCH_SIGABRT
+		{ SIGABRT, "SIGABRT" },
+#endif
+		{ SIGBUS,  "SIGBUS"  },
+		{ SIGFPE,  "SIGFPE"  },
+		{ SIGILL,  "SIGILL"  },
+		{ SIGINT,  "SIGINT"  },
+		{ SIGSEGV, "SIGSEGV" },
+		{ SIGTERM, "SIGTERM" },
+	};
+
+	void write_to_stderr(const char* data, size_t size)
+	{
+		auto result = write(STDERR_FILENO, data, size);
+		(void)result; // Ignore errors.
+	}
+
+	void write_to_stderr(const char* data)
+	{
+		write_to_stderr(data, strlen(data));
+	}
+
+	void call_default_signal_handler(int signal_number)
+	{
+		struct sigaction sig_action;
+		memset(&sig_action, 0, sizeof(sig_action));
+		sigemptyset(&sig_action.sa_mask);
+		sig_action.sa_handler = SIG_DFL;
+		sigaction(signal_number, &sig_action, NULL);
+		kill(getpid(), signal_number);
+	}
+
+	void signal_handler(int signal_number, siginfo_t*, void*)
+	{
+		const char* signal_name = "UNKNOWN SIGNAL";
+
+		for (const auto& s : ALL_SIGNALS) {
+			if (s.number == signal_number) {
+				signal_name = s.name;
+				break;
+			}
+		}
+
+		// --------------------------------------------------------------------
+		/* There are few things that are safe to do in a signal handler,
+		   but writing to stderr is one of them.
+		   So we first print out what happened to stderr so we're sure that gets out,
+		   then we do the unsafe things, like logging the stack trace.
+		*/
+
+		if (g_colorlogtostderr && s_terminal_has_color) {
+			write_to_stderr(terminal_reset());
+			write_to_stderr(terminal_bold());
+			write_to_stderr(terminal_light_red());
+		}
+		write_to_stderr("\n");
+		write_to_stderr("Loguru caught a signal: ");
+		write_to_stderr(signal_name);
+		write_to_stderr("\n");
+		if (g_colorlogtostderr && s_terminal_has_color) {
+			write_to_stderr(terminal_reset());
+		}
+
+		// --------------------------------------------------------------------
+
+#if LOGURU_UNSAFE_SIGNAL_HANDLER
+		// --------------------------------------------------------------------
+		/* Now we do unsafe things. This can for example lead to deadlocks if
+		   the signal was triggered from the system's memory management functions
+		   and the code below tries to do allocations.
+		*/
+
+		flush();
+		char preamble_buff[LOGURU_PREAMBLE_WIDTH];
+		print_preamble(preamble_buff, sizeof(preamble_buff), Verbosity_FATAL, "", 0);
+		auto message = Message{Verbosity_FATAL, "", 0, preamble_buff, "", "Signal: ", signal_name};
+		try {
+			log_message(1, message, false, false);
+		} catch (...) {
+			// This can happed due to s_fatal_handler.
+			write_to_stderr("Exception caught and ignored by Loguru signal handler.\n");
+		}
+		flush();
+
+		// --------------------------------------------------------------------
+#endif // LOGURU_UNSAFE_SIGNAL_HANDLER
+
+		call_default_signal_handler(signal_number);
+	}
+
+	void install_signal_handlers()
+	{
+		struct sigaction sig_action;
+		memset(&sig_action, 0, sizeof(sig_action));
+		sigemptyset(&sig_action.sa_mask);
+		sig_action.sa_flags |= SA_SIGINFO;
+		sig_action.sa_sigaction = &signal_handler;
+		for (const auto& s : ALL_SIGNALS) {
+			CHECK_F(sigaction(s.number, &sig_action, NULL) != -1,
+				"Failed to install handler for %s", s.name);
+		}
+	}
+} // namespace loguru
+
+#endif // _WIN32
+
+#endif // LOGURU_IMPLEMENTATION
+
diff -Nura v4l2rtspserver_imp_tools/inc/MemoryBufferSink.h v4l2rtspserver-master/inc/MemoryBufferSink.h
--- v4l2rtspserver_imp_tools/inc/MemoryBufferSink.h	2019-02-01 20:08:29.560626000 +0100
+++ v4l2rtspserver-master/inc/MemoryBufferSink.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/* ---------------------------------------------------------------------------
-** This software is in the public domain, furnished "as is", without technical
-** support, and with no warranty, express or implied, as to its usefulness for
-** any purpose.
-**
-** MemoryBufferSink.h
-** 
-** Implement a live555 Sink that store time slices in memory
-**
-** -------------------------------------------------------------------------*/
-
-#pragma once
-
-#include <string>
-#include <map>
-
-#include "MediaSink.hh"
-
-class MemoryBufferSink : public MediaSink
-{
-	public:
-		static MemoryBufferSink* createNew(UsageEnvironment& env, unsigned int bufferSize, unsigned int sliceDuration) 
-		{
-			return new MemoryBufferSink(env, bufferSize, sliceDuration);
-		}
-		
-	protected:
-		MemoryBufferSink(UsageEnvironment& env, unsigned bufferSize, unsigned int sliceDuration);
-		virtual ~MemoryBufferSink(); 
-		
-		virtual Boolean continuePlaying();
-	
-		static void afterGettingFrame(void* clientData, unsigned frameSize,
-						 unsigned numTruncatedBytes,
-						 struct timeval presentationTime,
-						 unsigned durationInMicroseconds) {
-			MemoryBufferSink* sink = (MemoryBufferSink*)clientData;
-			sink->afterGettingFrame(frameSize, numTruncatedBytes, presentationTime);
-		}
-
-		void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime);
-		
-	public:
-		unsigned int getBufferSize(unsigned int slice);
-		std::string  getBuffer(unsigned int slice);			
-		unsigned int firstTime();
-		unsigned int duration();
-		unsigned int getSliceDuration() 	{ return m_sliceDuration; }
-		
-	private:
-		unsigned char *                    m_buffer;
-		unsigned int                       m_bufferSize;
-		std::map<unsigned int,std::string> m_outputBuffers;
-		unsigned int                       m_refTime;
-		unsigned int                       m_sliceDuration;
-};
-	
diff -Nura v4l2rtspserver_imp_tools/inc/OSD.hpp v4l2rtspserver-master/inc/OSD.hpp
--- v4l2rtspserver_imp_tools/inc/OSD.hpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/OSD.hpp	2019-02-03 20:24:23.643172000 +0100
@@ -0,0 +1,114 @@
+#ifndef OSD_HPP
+#define OSD_HPP
+
+#include <tuple>
+#include <utility>
+
+#include <cstdint>
+
+#include "../inc/imp/imp_osd.h"
+#include "../tools/sharedmem.h"
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+#include FT_MODULE_H
+#include FT_CFF_DRIVER_H
+
+constexpr uint32_t make_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
+    return (r << 24) | (g << 16) | (b << 8) | (a << 0);
+}
+
+/*
+
+*/
+
+
+enum RGBAColor:uint32_t {
+    TRANSPARENT = make_rgba(0, 0, 0, 0),
+
+    WHITE = make_rgba(255, 255, 255, 255),
+    BLACK = make_rgba(0, 0, 0, 255),
+    RED = make_rgba(255, 0, 0, 255),
+    GREEN = make_rgba(0, 255, 0, 255),
+    BLUE = make_rgba(0, 0, 255, 255),
+
+    CYAN = GREEN | BLUE,
+    YELLOW = RED | GREEN,
+    MAGENTA = BLUE | RED
+};
+
+
+const uint32_t DETECTION_CIRCLE_SIZE = 32;
+const uint32_t DETECTION_CIRCLE_ALPHA[] = {
+      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9, 20, 20, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11, 70,142,192,219,233,234,221,197,148, 77, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,  0, 17,119,215,255,255,255,255,255,255,255,255,255,255,222,131, 24,  0,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0, 82,217,255,255,255,255,255,255,255,255,255,255,255,255,255,255,226, 97,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  2,132,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,150,  7,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  2,155,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,174,  8,  0,  0,  0,  0,
+      0,  0,  0,  0,132,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,154,  0,  0,  0,  0,
+      0,  0,  0, 82,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,104,  0,  0,  0,
+      0,  0, 17,223,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,237, 30,  0,  0,
+      0,  0,122,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,147,  0,  0,
+      0, 13,221,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,236, 25,  0,
+      0, 74,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255, 98,  0,
+      0,147,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,171,  0,
+      1,196,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,216,  7,
+      9,221,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,237, 22,
+     20,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,247, 37,
+     20,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,247, 37,
+     11,222,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,238, 24,
+      1,200,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,219,  8,
+      0,154,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,178,  0,
+      0, 81,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,106,  0,
+      0, 18,228,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,241, 31,  0,
+      0,  0,134,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,159,  0,  0,
+      0,  0, 24,231,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,243, 39,  0,  0,
+      0,  0,  0, 97,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,120,  0,  0,  0,
+      0,  0,  0,  0,151,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,172,  4,  0,  0,  0,
+      0,  0,  0,  0,  7,174,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,192, 15,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  8,153,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,171, 16,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,104,232,255,255,255,255,255,255,255,255,255,255,255,255,255,255,239,119,  4,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,  0, 30,143,231,255,255,255,255,255,255,255,255,255,255,237,155, 39,  0,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 93,166,212,235,246,247,236,216,173,101, 30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6, 21, 35, 36, 23,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
+};
+
+class OSD {
+    private:
+        int _x, _y, _width, _height, _layer;
+
+        IMPRgnHandle region;
+
+        uint32_t *image;
+
+    public:
+        OSD(int x, int y, int width, int height, int layer);
+        ~OSD();
+
+        int getX();
+        int getY();
+        int getWidth();
+        int getHeight();
+
+        void setBounds(int x, int y, int width, int height);
+
+        void clear();
+        void update();
+
+        void show(bool flag);
+
+        void drawBitmap(int x, int y, int width, int height, uint32_t *pixels);
+        void setPixel(int x, int y, uint32_t value);
+        uint32_t getPixel(int x, int y);
+};
+
+std::pair<int, int> get_vertical_font_dimensions(FT_Face &face);
+
+uint32_t mix_rgba_with_grayscale(uint32_t rgba_color, uint8_t value);
+
+void osd_draw_timestamp(OSD &timestamp_osd, FT_Face &face, int baseline_offset, shared_conf &currentConfig);
+void osd_draw_detection_circle(OSD &motion_osd, bool isDetecting, shared_conf &currentConfig);
+
+#endif
diff -Nura v4l2rtspserver_imp_tools/inc/SegmentServerMediaSubsession.h v4l2rtspserver-master/inc/SegmentServerMediaSubsession.h
--- v4l2rtspserver_imp_tools/inc/SegmentServerMediaSubsession.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/SegmentServerMediaSubsession.h	2019-02-03 20:24:23.643172000 +0100
@@ -0,0 +1,79 @@
+/* ---------------------------------------------------------------------------
+** This software is in the public domain, furnished "as is", without technical
+** support, and with no warranty, express or implied, as to its usefulness for
+** any purpose.
+**
+** ServerMediaSubsession.h
+** 
+** -------------------------------------------------------------------------*/
+
+#pragma once
+
+#include <map>
+#include "UnicastServerMediaSubsession.h"
+
+// -----------------------------------------
+//    ServerMediaSubsession for HLS
+// -----------------------------------------
+class HLSServerMediaSubsession : public UnicastServerMediaSubsession
+{
+	class HLSSink : public MediaSink
+	{
+		public:
+			static HLSSink* createNew(UsageEnvironment& env, unsigned int bufferSize, unsigned int sliceDuration) 
+			{
+				return new HLSSink(env, bufferSize, sliceDuration);
+			}
+			
+		protected:
+			HLSSink(UsageEnvironment& env, unsigned bufferSize, unsigned int sliceDuration);
+			virtual ~HLSSink(); 
+			
+			virtual Boolean continuePlaying();
+		
+			static void afterGettingFrame(void* clientData, unsigned frameSize,
+							 unsigned numTruncatedBytes,
+							 struct timeval presentationTime,
+							 unsigned durationInMicroseconds) {
+				HLSSink* sink = (HLSSink*)clientData;
+				sink->afterGettingFrame(frameSize, numTruncatedBytes, presentationTime);
+			}
+
+			void afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime);
+			
+		public:
+			unsigned int getHLSBufferSize(unsigned int slice);
+			const char*  getHLSBuffer(unsigned int slice);			
+			unsigned int firstTime();
+			unsigned int duration();
+			unsigned int getSliceDuration() 	{ return m_sliceDuration; }
+			
+		private:
+			unsigned char *                    m_buffer;
+			unsigned int                       m_bufferSize;
+			std::map<unsigned int,std::string> m_outputBuffers;
+			unsigned int                       m_refTime;
+			unsigned int                       m_sliceDuration;
+	};
+	
+	public:
+		static HLSServerMediaSubsession* createNew(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration)
+		{
+			return new HLSServerMediaSubsession(env, replicator, format, sliceDuration);
+		}
+		
+	protected:
+		HLSServerMediaSubsession(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration); 
+		virtual ~HLSServerMediaSubsession();
+			
+		virtual float         getCurrentNPT(void* streamToken);
+		virtual float         duration() const ;
+		virtual void          seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes);
+		virtual FramedSource* getStreamSource(void* streamToken);
+					
+	protected:
+		unsigned int      m_slice;
+		HLSSink *         m_hlsSink;
+};
+
+
diff -Nura v4l2rtspserver_imp_tools/inc/ServerMediaSubsession.h v4l2rtspserver-master/inc/ServerMediaSubsession.h
--- v4l2rtspserver_imp_tools/inc/ServerMediaSubsession.h	2019-02-01 20:08:29.562626000 +0100
+++ v4l2rtspserver-master/inc/ServerMediaSubsession.h	2019-02-03 20:24:23.643172000 +0100
@@ -32,7 +32,7 @@
 	
 	public:
 		static FramedSource* createSource(UsageEnvironment& env, FramedSource * videoES, const std::string& format);
-		static RTPSink* createSink(UsageEnvironment& env, Groupsock * rtpGroupsock, unsigned char rtpPayloadTypeIfDynamic, const std::string& format, V4L2DeviceSource* source);
+		static RTPSink* createSink(UsageEnvironment& env, Groupsock * rtpGroupsock, unsigned char rtpPayloadTypeIfDynamic, const std::string& format);
 		char const* getAuxLine(V4L2DeviceSource* source,unsigned char rtpPayloadType);
 		
 	protected:
diff -Nura v4l2rtspserver_imp_tools/inc/soundcard.h v4l2rtspserver-master/inc/soundcard.h
--- v4l2rtspserver_imp_tools/inc/soundcard.h	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/inc/soundcard.h	2019-02-03 20:24:23.647172000 +0100
@@ -0,0 +1,2148 @@
+/*
+ * Purpose: The C/C++ header file that defines the OSS API.
+ * Description:
+ * This header file contains all the declarations required to compile OSS
+ * programs. The latest version is always installed together with OSS
+ * use of the latest version is strongly recommended.
+ *
+ * {!notice This header file contains many obsolete definitions
+ * (for compatibility with older applications that still ned them).
+ * Do not use this file as a reference manual of OSS.
+ * Please check the OSS Programmer's guide for descriptions
+ * of the supported API details (http://manuals.opensound.com/developer).} 
+ */
+
+#ifndef SOUNDCARD_H
+#define SOUNDCARD_H
+
+/*
+ *
+ * This file is part of Open Sound System.
+ *
+ * Copyright (C) 4Front Technologies 1996-2008.
+ *
+ * This this source file is released under GPL v2 license (no other versions).
+ * See the COPYING file included in the main directory of this source
+ * distribution for the license terms and conditions.
+ *
+ */
+
+#if defined(__cplusplus)
+#define EXTERNC extern "C"
+#else
+#define EXTERNC extern
+#endif /* EXTERN_C_WRAPPERS */
+
+#define OSS_VERSION	0x040100 /* 4.1 */
+
+#define SOUND_VERSION	OSS_VERSION
+#define OPEN_SOUND_SYSTEM
+
+#if defined(__hpux) && !defined(_HPUX_SOURCE)
+#	error "-D_HPUX_SOURCE must be used when compiling OSS applications"
+#endif
+
+#ifdef __hpux
+#include <sys/ioctl.h>
+#endif
+
+#ifdef linux
+/* In Linux we need to be prepared for cross compiling */
+#include <linux/ioctl.h>
+#else
+# ifdef __FreeBSD__
+#    include <sys/ioccom.h>
+# else
+#    include <sys/ioctl.h>
+# endif
+#endif
+
+#ifndef __SIOWR
+#if defined(__hpux) || (defined(_IOWR) && (defined(_AIX) || (!defined(sun) && !defined(sparc) && !defined(__INCioctlh) && !defined(__Lynx__))))
+
+/* 
+ * Make sure the ioctl macros are compatible with the ones already used
+ * by this operating system.
+ */
+#define	SIOCPARM_MASK	IOCPARM_MASK
+#define	SIOC_VOID	IOC_VOID
+#define	SIOC_OUT	IOC_OUT
+#define	SIOC_IN		IOC_IN
+#define	SIOC_INOUT	IOC_INOUT
+#define __SIOC_SIZE	_IOC_SIZE
+#define __SIOC_DIR	_IOC_DIR
+#define __SIOC_NONE	_IOC_NONE
+#define __SIOC_READ	_IOC_READ
+#define __SIOC_WRITE	_IOC_WRITE
+#define	__SIO		_IO
+#define	__SIOR		_IOR
+#define	__SIOW		_IOW
+#define	__SIOWR		_IOWR
+#else
+
+/* #define	SIOCTYPE		(0xff<<8) */
+#define	SIOCPARM_MASK	0x1fff	/* parameters must be < 8192 bytes */
+#define	SIOC_VOID	0x00000000	/* no parameters */
+#define	SIOC_OUT	0x20000000	/* copy out parameters */
+#define	SIOC_IN		0x40000000	/* copy in parameters */
+#define	SIOC_INOUT	(SIOC_IN|SIOC_OUT)
+
+#define	__SIO(x,y)	((int)(SIOC_VOID|(x<<8)|y))
+#define	__SIOR(x,y,t)	((int)(SIOC_OUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+#define	__SIOW(x,y,t)	((int)(SIOC_IN|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+#define	__SIOWR(x,y,t)	((int)(SIOC_INOUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))
+#define __SIOC_SIZE(x)	((x>>16)&SIOCPARM_MASK)
+#define __SIOC_DIR(x)	(x & 0xf0000000)
+#define __SIOC_NONE	SIOC_VOID
+#define __SIOC_READ	SIOC_OUT
+#define __SIOC_WRITE	SIOC_IN
+#  endif /* _IOWR */
+#endif /* !__SIOWR */
+
+#define OSS_LONGNAME_SIZE	64
+#define OSS_LABEL_SIZE		16
+#define OSS_DEVNODE_SIZE	32
+#define OSS_DEVNAME_SIZE	64
+#define OSS_CMD_SIZE		64
+#define OSS_ID_SIZE		16
+#define OSS_HANDLE_SIZE		32
+typedef char oss_longname_t[OSS_LONGNAME_SIZE];
+typedef char oss_label_t[OSS_LABEL_SIZE];
+typedef char oss_devnode_t[OSS_DEVNODE_SIZE];
+typedef char oss_devname_t[OSS_DEVNAME_SIZE];
+typedef char oss_cmd_t[OSS_CMD_SIZE];
+typedef char oss_id_t[OSS_ID_SIZE];
+typedef char oss_handle_t[OSS_HANDLE_SIZE];
+
+#ifndef DISABLE_SEQUENCER
+/*
+ ****************************************************************************
+ * IOCTL Commands for /dev/sequencer and /dev/music (AKA /dev/sequencer2)
+ *
+ * Note that this interface is obsolete and no longer developed. New
+ * applications should use /dev/midi instead.
+ ****************************************************************************/
+#define SNDCTL_SEQ_RESET		__SIO  ('Q', 0)
+#define SNDCTL_SEQ_SYNC			__SIO  ('Q', 1)
+#define SNDCTL_SYNTH_INFO		__SIOWR('Q', 2, struct synth_info)
+#define SNDCTL_SEQ_CTRLRATE		__SIOWR('Q', 3, int)	/* Set/get timer resolution (HZ) */
+#define SNDCTL_SEQ_GETOUTCOUNT		__SIOR ('Q', 4, int)
+#define SNDCTL_SEQ_GETINCOUNT		__SIOR ('Q', 5, int)
+#define SNDCTL_SEQ_PERCMODE		__SIOW ('Q', 6, int)
+#define SNDCTL_FM_LOAD_INSTR		__SIOW ('Q', 7, struct sbi_instrument)	/* Obsolete. Don't use!!!!!! */
+#define SNDCTL_SEQ_TESTMIDI		__SIOW ('Q', 8, int)
+#define SNDCTL_SEQ_RESETSAMPLES		__SIOW ('Q', 9, int)
+#define SNDCTL_SEQ_NRSYNTHS		__SIOR ('Q',10, int)
+#define SNDCTL_SEQ_NRMIDIS		__SIOR ('Q',11, int)
+#define SNDCTL_MIDI_INFO		__SIOWR('Q',12, struct midi_info)	/* OBSOLETE - use SNDCTL_MIDIINFO instead */
+#define SNDCTL_SEQ_THRESHOLD		__SIOW ('Q',13, int)
+#define SNDCTL_SYNTH_MEMAVL		__SIOWR('Q',14, int)	/* in=dev#, out=memsize */
+#define SNDCTL_FM_4OP_ENABLE		__SIOW ('Q',15, int)	/* in=dev# */
+#define SNDCTL_SEQ_PANIC		__SIO  ('Q',17)
+#define SNDCTL_SEQ_OUTOFBAND		__SIOW ('Q',18, struct seq_event_rec)
+#define SNDCTL_SEQ_GETTIME		__SIOR ('Q',19, int)
+#define SNDCTL_SYNTH_ID			__SIOWR('Q',20, struct synth_info)
+#define SNDCTL_SYNTH_CONTROL		__SIOWR('Q',21, struct synth_control)
+#define SNDCTL_SYNTH_REMOVESAMPLE	__SIOWR('Q',22, struct remove_sample)	/* Reserved for future use */
+#define SNDCTL_SEQ_TIMING_ENABLE	__SIO  ('Q', 23)	/* Enable incoming MIDI timing messages */
+#define SNDCTL_SEQ_ACTSENSE_ENABLE	__SIO  ('Q', 24)	/* Enable incoming active sensing messages */
+#define SNDCTL_SEQ_RT_ENABLE		__SIO  ('Q', 25)	/* Enable other incoming realtime messages */
+#define SNDCTL_EXT_SET_RECORD_VOLUME       __SIOR ('P', 103, int)
+
+typedef struct synth_control
+{
+  int devno;			/* Synthesizer # */
+  char data[4000];		/* Device spesific command/data record */
+} synth_control;
+
+typedef struct remove_sample
+{
+  int devno;			/* Synthesizer # */
+  int bankno;			/* MIDI bank # (0=General MIDI) */
+  int instrno;			/* MIDI instrument number */
+} remove_sample;
+
+typedef struct seq_event_rec
+{
+  unsigned char arr[8];
+} seq_event_rec;
+
+#define SNDCTL_TMR_TIMEBASE		__SIOWR('T', 1, int)
+#define SNDCTL_TMR_START		__SIO  ('T', 2)
+#define SNDCTL_TMR_STOP			__SIO  ('T', 3)
+#define SNDCTL_TMR_CONTINUE		__SIO  ('T', 4)
+#define SNDCTL_TMR_TEMPO		__SIOWR('T', 5, int)
+#define SNDCTL_TMR_SOURCE		__SIOWR('T', 6, int)
+#	define TMR_INTERNAL		0x00000001
+#	define TMR_EXTERNAL		0x00000002
+#		define TMR_MODE_MIDI	0x00000010
+#		define TMR_MODE_FSK	0x00000020
+#		define TMR_MODE_CLS	0x00000040
+#		define TMR_MODE_SMPTE	0x00000080
+#define SNDCTL_TMR_METRONOME		__SIOW ('T', 7, int)
+#define SNDCTL_TMR_SELECT		__SIOW ('T', 8, int)
+
+/*
+ * Sample loading mechanism for internal synthesizers (/dev/sequencer)
+ * (for the .PAT format).
+ */
+
+struct patch_info
+{
+  unsigned short key;		/* Use WAVE_PATCH here */
+#define WAVE_PATCH	_PATCHKEY(0x04)
+#define GUS_PATCH	WAVE_PATCH
+#define WAVEFRONT_PATCH _PATCHKEY(0x06)
+
+  short device_no;		/* Synthesizer number */
+  short instr_no;		/* Midi pgm# */
+
+  unsigned int mode;
+/*
+ * The least significant byte has the same format than the GUS .PAT
+ * files
+ */
+#define WAVE_16_BITS	0x01	/* bit 0 = 8 or 16 bit wave data. */
+#define WAVE_UNSIGNED	0x02	/* bit 1 = Signed - Unsigned data. */
+#define WAVE_LOOPING	0x04	/* bit 2 = looping enabled-1. */
+#define WAVE_BIDIR_LOOP	0x08	/* bit 3 = Set is bidirectional looping. */
+#define WAVE_LOOP_BACK	0x10	/* bit 4 = Set is looping backward. */
+#define WAVE_SUSTAIN_ON	0x20	/* bit 5 = Turn sustaining on. (Env. pts. 3) */
+#define WAVE_ENVELOPES	0x40	/* bit 6 = Enable envelopes - 1 */
+#define WAVE_FAST_RELEASE 0x80	/* bit 7 = Shut off immediately after note off */
+  /*  (use the env_rate/env_offs fields). */
+/* Linux specific bits */
+#define WAVE_VIBRATO	0x00010000	/* The vibrato info is valid */
+#define WAVE_TREMOLO	0x00020000	/* The tremolo info is valid */
+#define WAVE_SCALE	0x00040000	/* The scaling info is valid */
+#define WAVE_FRACTIONS	0x00080000	/* Fraction information is valid */
+/* Reserved bits */
+#define WAVE_ROM	0x40000000	/* For future use */
+#define WAVE_MULAW	0x20000000	/* For future use */
+/* Other bits must be zeroed */
+
+  int len;			/* Size of the wave data in bytes */
+  int loop_start, loop_end;	/* Byte offsets from the beginning */
+
+/* 
+ * The base_freq and base_note fields are used when computing the
+ * playback speed for a note. The base_note defines the tone frequency
+ * which is heard if the sample is played using the base_freq as the
+ * playback speed.
+ *
+ * The low_note and high_note fields define the minimum and maximum note
+ * frequencies for which this sample is valid. It is possible to define
+ * more than one samples for an instrument number at the same time. The
+ * low_note and high_note fields are used to select the most suitable one.
+ *
+ * The fields base_note, high_note and low_note should contain
+ * the note frequency multiplied by 1000. For example value for the
+ * middle A is 440*1000.
+ */
+
+  unsigned int base_freq;
+  unsigned int base_note;
+  unsigned int high_note;
+  unsigned int low_note;
+  int panning;			/* -128=left, 127=right */
+  int detuning;
+
+  /* Envelope. Enabled by mode bit WAVE_ENVELOPES  */
+  unsigned char env_rate[6];	/* GUS HW ramping rate */
+  unsigned char env_offset[6];	/* 255 == 100% */
+
+  /* 
+   * The tremolo, vibrato and scale info are not supported yet.
+   * Enable by setting the mode bits WAVE_TREMOLO, WAVE_VIBRATO or
+   * WAVE_SCALE
+   */
+
+  unsigned char tremolo_sweep;
+  unsigned char tremolo_rate;
+  unsigned char tremolo_depth;
+
+  unsigned char vibrato_sweep;
+  unsigned char vibrato_rate;
+  unsigned char vibrato_depth;
+
+  int scale_frequency;
+  unsigned int scale_factor;	/* from 0 to 2048 or 0 to 2 */
+
+  int volume;
+  int fractions;
+  int reserved1;
+  int spare[2];
+  char data[1];			/* The waveform data starts here */
+};
+
+struct sysex_info
+{
+  short key;			/* Use SYSEX_PATCH or MAUI_PATCH here */
+#define SYSEX_PATCH	_PATCHKEY(0x05)
+#define MAUI_PATCH	_PATCHKEY(0x06)
+  short device_no;		/* Synthesizer number */
+  int len;			/* Size of the sysex data in bytes */
+  unsigned char data[1];	/* Sysex data starts here */
+};
+
+/*
+ * /dev/sequencer input events.
+ *
+ * The data written to the /dev/sequencer is a stream of events. Events
+ * are records of 4 or 8 bytes. The first byte defines the size. 
+ * Any number of events can be written with a write call. There
+ * is a set of macros for sending these events. Use these macros if you
+ * want to maximize portability of your program.
+ *
+ * Events SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO. Are also input events.
+ * (All input events are currently 4 bytes long. Be prepared to support
+ * 8 byte events also. If you receive any event having first byte >= 128,
+ * it's a 8 byte event.
+ *
+ * The events are documented at the end of this file.
+ *
+ * Normal events (4 bytes)
+ * There is also a 8 byte version of most of the 4 byte events. The
+ * 8 byte one is recommended.
+ *
+ * NOTE! All 4 byte events are now obsolete. Applications should not write
+ *       them. However 4 byte events are still used as inputs from
+ *       /dev/sequencer (/dev/music uses only 8 byte ones).
+ */
+#define SEQ_NOTEOFF		0
+#define SEQ_FMNOTEOFF		SEQ_NOTEOFF	/* Just old name */
+#define SEQ_NOTEON		1
+#define	SEQ_FMNOTEON		SEQ_NOTEON
+#define SEQ_WAIT		TMR_WAIT_ABS
+#define SEQ_PGMCHANGE		3
+#define SEQ_FMPGMCHANGE		SEQ_PGMCHANGE
+#define SEQ_SYNCTIMER		TMR_START
+#define SEQ_MIDIPUTC		5
+#define SEQ_DRUMON		6		/*** OBSOLETE ***/
+#define SEQ_DRUMOFF		7		/*** OBSOLETE ***/
+#define SEQ_ECHO		TMR_ECHO	/* For synching programs with output */
+#define SEQ_AFTERTOUCH		9
+#define SEQ_CONTROLLER		10
+#define SEQ_BALANCE		11
+#define SEQ_VOLMODE             12
+
+/************************************
+ *	Midi controller numbers	    *
+ ************************************/
+/*
+ * Controllers 0 to 31 (0x00 to 0x1f) and
+ * 32 to 63 (0x20 to 0x3f) are continuous
+ * controllers.
+ * In the MIDI 1.0 these controllers are sent using
+ * two messages. Controller numbers 0 to 31 are used
+ * to send the MSB and the controller numbers 32 to 63
+ * are for the LSB. Note that just 7 bits are used in MIDI bytes.
+ */
+
+#define	   CTL_BANK_SELECT		0x00
+#define	   CTL_MODWHEEL			0x01
+#define    CTL_BREATH			0x02
+/*		undefined		0x03 */
+#define    CTL_FOOT			0x04
+#define    CTL_PORTAMENTO_TIME		0x05
+#define    CTL_DATA_ENTRY		0x06
+#define    CTL_MAIN_VOLUME		0x07
+#define    CTL_BALANCE			0x08
+/*		undefined		0x09 */
+#define    CTL_PAN			0x0a
+#define    CTL_EXPRESSION		0x0b
+/*		undefined		0x0c */
+/*		undefined		0x0d */
+/*		undefined		0x0e */
+/*		undefined		0x0f */
+#define    CTL_GENERAL_PURPOSE1		0x10
+#define    CTL_GENERAL_PURPOSE2		0x11
+#define    CTL_GENERAL_PURPOSE3		0x12
+#define    CTL_GENERAL_PURPOSE4		0x13
+/*		undefined		0x14 - 0x1f */
+
+/*		undefined		0x20 */
+/* The controller numbers 0x21 to 0x3f are reserved for the */
+/* least significant bytes of the controllers 0x00 to 0x1f. */
+/* These controllers are not recognised by the driver. */
+
+/* Controllers 64 to 69 (0x40 to 0x45) are on/off switches. */
+/* 0=OFF and 127=ON (intermediate values are possible) */
+#define    CTL_DAMPER_PEDAL		0x40
+#define    CTL_SUSTAIN			0x40	/* Alias */
+#define    CTL_HOLD			0x40	/* Alias */
+#define    CTL_PORTAMENTO		0x41
+#define    CTL_SOSTENUTO		0x42
+#define    CTL_SOFT_PEDAL		0x43
+/*		undefined		0x44 */
+#define    CTL_HOLD2			0x45
+/*		undefined		0x46 - 0x4f */
+
+#define    CTL_GENERAL_PURPOSE5		0x50
+#define    CTL_GENERAL_PURPOSE6		0x51
+#define    CTL_GENERAL_PURPOSE7		0x52
+#define    CTL_GENERAL_PURPOSE8		0x53
+/*		undefined		0x54 - 0x5a */
+#define    CTL_EXT_EFF_DEPTH		0x5b
+#define    CTL_TREMOLO_DEPTH		0x5c
+#define    CTL_CHORUS_DEPTH		0x5d
+#define    CTL_DETUNE_DEPTH		0x5e
+#define    CTL_CELESTE_DEPTH		0x5e	/* Alias for the above one */
+#define    CTL_PHASER_DEPTH		0x5f
+#define    CTL_DATA_INCREMENT		0x60
+#define    CTL_DATA_DECREMENT		0x61
+#define    CTL_NONREG_PARM_NUM_LSB	0x62
+#define    CTL_NONREG_PARM_NUM_MSB	0x63
+#define    CTL_REGIST_PARM_NUM_LSB	0x64
+#define    CTL_REGIST_PARM_NUM_MSB	0x65
+/*		undefined		0x66 - 0x78 */
+/*		reserved		0x79 - 0x7f */
+
+/* Pseudo controllers (not midi compatible) */
+#define    CTRL_PITCH_BENDER		255
+#define    CTRL_PITCH_BENDER_RANGE	254
+#define    CTRL_EXPRESSION		253	/* Obsolete */
+#define    CTRL_MAIN_VOLUME		252	/* Obsolete */
+
+/*
+ * Volume mode defines how volumes are used
+ */
+
+#define VOL_METHOD_ADAGIO	1
+#define VOL_METHOD_LINEAR	2
+
+/*
+ * Note! SEQ_WAIT, SEQ_MIDIPUTC and SEQ_ECHO are used also as
+ *	 input events.
+ */
+
+/*
+ * Event codes 0xf0 to 0xfc are reserved for future extensions.
+ */
+
+#define SEQ_FULLSIZE		0xfd	/* Long events */
+/*
+ * SEQ_FULLSIZE events are used for loading patches/samples to the
+ * synthesizer devices. These events are passed directly to the driver
+ * of the associated synthesizer device. There is no limit to the size
+ * of the extended events. These events are not queued but executed
+ * immediately when the write() is called (execution can take several
+ * seconds of time). 
+ *
+ * When a SEQ_FULLSIZE message is written to the device, it must
+ * be written using exactly one write() call. Other events cannot
+ * be mixed to the same write.
+ *	
+ * For FM synths (YM3812/OPL3) use struct sbi_instrument and write it to the 
+ * /dev/sequencer. Don't write other data together with the instrument structure
+ * Set the key field of the structure to FM_PATCH. The device field is used to
+ * route the patch to the corresponding device.
+ *
+ * For wave table use struct patch_info. Initialize the key field
+ * to WAVE_PATCH.
+ */
+#define SEQ_PRIVATE		0xfe	/* Low level HW dependent events (8 bytes) */
+#define SEQ_EXTENDED		0xff	/* Extended events (8 bytes) OBSOLETE */
+
+/*
+ * Record for FM patches
+ */
+
+typedef unsigned char sbi_instr_data[32];
+
+struct sbi_instrument
+{
+  unsigned short key;		/* FM_PATCH or OPL3_PATCH */
+#define FM_PATCH	_PATCHKEY(0x01)
+#define OPL3_PATCH	_PATCHKEY(0x03)
+  short device;			/*  Synth# (0-4)    */
+  int channel;			/*  Program# to be initialized  */
+  sbi_instr_data operators;	/*  Register settings for operator cells (.SBI format)  */
+};
+
+struct synth_info
+{				/* Read only */
+  char name[30];
+  int device;			/* 0-N. INITIALIZE BEFORE CALLING */
+  int synth_type;
+#define SYNTH_TYPE_FM			0
+#define SYNTH_TYPE_SAMPLE		1
+#define SYNTH_TYPE_MIDI			2	/* Midi interface */
+
+  int synth_subtype;
+#define FM_TYPE_ADLIB			0x00
+#define FM_TYPE_OPL3			0x01
+#define MIDI_TYPE_MPU401		0x401
+
+#define SAMPLE_TYPE_BASIC		0x10
+#define SAMPLE_TYPE_GUS			SAMPLE_TYPE_BASIC
+#define SAMPLE_TYPE_WAVEFRONT   	0x11
+
+  int perc_mode;		/* No longer supported */
+  int nr_voices;
+  int nr_drums;			/* Obsolete field */
+  int instr_bank_size;
+  unsigned int capabilities;
+#define SYNTH_CAP_PERCMODE	0x00000001	/* No longer used */
+#define SYNTH_CAP_OPL3		0x00000002	/* Set if OPL3 supported */
+#define SYNTH_CAP_INPUT		0x00000004	/* Input (MIDI) device */
+  int dummies[19];		/* Reserve space */
+};
+
+struct sound_timer_info
+{
+  char name[32];
+  int caps;
+};
+
+struct midi_info		/* OBSOLETE */
+{
+  char name[30];
+  int device;			/* 0-N. INITIALIZE BEFORE CALLING */
+  unsigned int capabilities;	/* To be defined later */
+  int dev_type;
+  int dummies[18];		/* Reserve space */
+};
+
+/*
+ * Level 2 event types for /dev/sequencer
+ */
+
+/*
+ * The 4 most significant bits of byte 0 specify the class of
+ * the event: 
+ *
+ *	0x8X = system level events,
+ *	0x9X = device/port specific events, event[1] = device/port,
+ *		The last 4 bits give the subtype:
+ *			0x02	= Channel event (event[3] = chn).
+ *			0x01	= note event (event[4] = note).
+ *			(0x01 is not used alone but always with bit 0x02).
+ *	       event[2] = MIDI message code (0x80=note off etc.)
+ *
+ */
+
+#define EV_SEQ_LOCAL		0x80
+#define EV_TIMING		0x81
+#define EV_CHN_COMMON		0x92
+#define EV_CHN_VOICE		0x93
+#define EV_SYSEX		0x94
+#define EV_SYSTEM		0x95	/* MIDI system and real time messages (input only) */
+/*
+ * Event types 200 to 220 are reserved for application use.
+ * These numbers will not be used by the driver.
+ */
+
+/*
+ * Events for event type EV_CHN_VOICE
+ */
+
+#define MIDI_NOTEOFF		0x80
+#define MIDI_NOTEON		0x90
+#define MIDI_KEY_PRESSURE	0xA0
+
+/*
+ * Events for event type EV_CHN_COMMON
+ */
+
+#define MIDI_CTL_CHANGE		0xB0
+#define MIDI_PGM_CHANGE		0xC0
+#define MIDI_CHN_PRESSURE	0xD0
+#define MIDI_PITCH_BEND		0xE0
+
+#define MIDI_SYSTEM_PREFIX	0xF0
+
+/*
+ * Timer event types
+ */
+#define TMR_WAIT_REL		1	/* Time relative to the prev time */
+#define TMR_WAIT_ABS		2	/* Absolute time since TMR_START */
+#define TMR_STOP		3
+#define TMR_START		4
+#define TMR_CONTINUE		5
+#define TMR_TEMPO		6
+#define TMR_ECHO		8
+#define TMR_CLOCK		9	/* MIDI clock */
+#define TMR_SPP			10	/* Song position pointer */
+#define TMR_TIMESIG		11	/* Time signature */
+
+/*
+ *	Local event types
+ */
+#define LOCL_STARTAUDIO		1
+#define LOCL_STARTAUDIO2	2
+#define LOCL_STARTAUDIO3	3
+#define LOCL_STARTAUDIO4	4
+
+#if (!defined(__KERNEL__) && !defined(KERNEL) && !defined(INKERNEL) && !defined(_KERNEL)) || defined(USE_SEQ_MACROS)
+/*
+ * Some convenience macros to simplify programming of the
+ * /dev/sequencer interface
+ *
+ * These macros define the API which should be used when possible.
+ */
+#define SEQ_DECLAREBUF()		SEQ_USE_EXTBUF()
+
+void seqbuf_dump (void);	/* This function must be provided by programs */
+
+EXTERNC int OSS_init (int seqfd, int buflen);
+EXTERNC void OSS_seqbuf_dump (int fd, unsigned char *buf, int buflen);
+EXTERNC void OSS_seq_advbuf (int len, int fd, unsigned char *buf, int buflen);
+EXTERNC void OSS_seq_needbuf (int len, int fd, unsigned char *buf,
+			      int buflen);
+EXTERNC void OSS_patch_caching (int dev, int chn, int patch, int fd,
+				unsigned char *buf, int buflen);
+EXTERNC void OSS_drum_caching (int dev, int chn, int patch, int fd,
+			       unsigned char *buf, int buflen);
+EXTERNC void OSS_write_patch (int fd, unsigned char *buf, int len);
+EXTERNC int OSS_write_patch2 (int fd, unsigned char *buf, int len);
+
+#define SEQ_PM_DEFINES int __foo_bar___
+#ifdef OSSLIB
+#  define SEQ_USE_EXTBUF() \
+		EXTERNC unsigned char *_seqbuf; \
+		EXTERNC int _seqbuflen;EXTERNC int _seqbufptr
+#  define SEQ_DEFINEBUF(len) SEQ_USE_EXTBUF();static int _requested_seqbuflen=len
+#  define _SEQ_ADVBUF(len) OSS_seq_advbuf(len, seqfd, _seqbuf, _seqbuflen)
+#  define _SEQ_NEEDBUF(len) OSS_seq_needbuf(len, seqfd, _seqbuf, _seqbuflen)
+#  define SEQ_DUMPBUF() OSS_seqbuf_dump(seqfd, _seqbuf, _seqbuflen)
+
+#  define SEQ_LOAD_GMINSTR(dev, instr) \
+		OSS_patch_caching(dev, -1, instr, seqfd, _seqbuf, _seqbuflen)
+#  define SEQ_LOAD_GMDRUM(dev, drum) \
+		OSS_drum_caching(dev, -1, drum, seqfd, _seqbuf, _seqbuflen)
+#else /* !OSSLIB */
+
+#  define SEQ_LOAD_GMINSTR(dev, instr)
+#  define SEQ_LOAD_GMDRUM(dev, drum)
+
+#  define SEQ_USE_EXTBUF() \
+		EXTERNC unsigned char _seqbuf[]; \
+		EXTERNC int _seqbuflen;EXTERNC int _seqbufptr
+
+#ifndef USE_SIMPLE_MACROS
+/* Sample seqbuf_dump() implementation:
+ *
+ *	SEQ_DEFINEBUF (2048);	-- Defines a buffer for 2048 bytes
+ *
+ *	int seqfd;		-- The file descriptor for /dev/sequencer.
+ *
+ *	void
+ *	seqbuf_dump ()
+ *	{
+ *	  if (_seqbufptr)
+ *	    if (write (seqfd, _seqbuf, _seqbufptr) == -1)
+ *	      {
+ *		perror ("write /dev/sequencer");
+ *		exit (-1);
+ *	      }
+ *	  _seqbufptr = 0;
+ *	}
+ */
+
+#define SEQ_DEFINEBUF(len) \
+	unsigned char _seqbuf[len]; int _seqbuflen = len;int _seqbufptr = 0
+#define _SEQ_NEEDBUF(len) \
+	if ((_seqbufptr+(len)) > _seqbuflen) seqbuf_dump()
+#define _SEQ_ADVBUF(len) _seqbufptr += len
+#define SEQ_DUMPBUF seqbuf_dump
+#else
+/*
+ * This variation of the sequencer macros is used just to format one event
+ * using fixed buffer.
+ * 
+ * The program using the macro library must define the following macros before
+ * using this library.
+ *
+ * #define _seqbuf 		 name of the buffer (unsigned char[]) 
+ * #define _SEQ_ADVBUF(len)	 If the applic needs to know the exact
+ *				 size of the event, this macro can be used.
+ *				 Otherwise this must be defined as empty.
+ * #define _seqbufptr		 Define the name of index variable or 0 if
+ *				 not required. 
+ */
+#define _SEQ_NEEDBUF(len)	/* empty */
+#endif
+#endif /* !OSSLIB */
+
+#define SEQ_VOLUME_MODE(dev, mode) \
+				{_SEQ_NEEDBUF(8);\
+				_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
+				_seqbuf[_seqbufptr+1] = SEQ_VOLMODE;\
+				_seqbuf[_seqbufptr+2] = (dev);\
+				_seqbuf[_seqbufptr+3] = (mode);\
+				_seqbuf[_seqbufptr+4] = 0;\
+				_seqbuf[_seqbufptr+5] = 0;\
+				_seqbuf[_seqbufptr+6] = 0;\
+				_seqbuf[_seqbufptr+7] = 0;\
+				_SEQ_ADVBUF(8);}
+
+/*
+ * Midi voice messages
+ */
+
+#define _CHN_VOICE(dev, event, chn, note, parm) \
+				{_SEQ_NEEDBUF(8);\
+				_seqbuf[_seqbufptr] = EV_CHN_VOICE;\
+				_seqbuf[_seqbufptr+1] = (dev);\
+				_seqbuf[_seqbufptr+2] = (event);\
+				_seqbuf[_seqbufptr+3] = (chn);\
+				_seqbuf[_seqbufptr+4] = (note);\
+				_seqbuf[_seqbufptr+5] = (parm);\
+				_seqbuf[_seqbufptr+6] = (0);\
+				_seqbuf[_seqbufptr+7] = 0;\
+				_SEQ_ADVBUF(8);}
+
+#define SEQ_START_NOTE(dev, chn, note, vol) \
+			_CHN_VOICE(dev, MIDI_NOTEON, chn, note, vol)
+
+#define SEQ_STOP_NOTE(dev, chn, note, vol) \
+			_CHN_VOICE(dev, MIDI_NOTEOFF, chn, note, vol)
+
+#define SEQ_KEY_PRESSURE(dev, chn, note, pressure) \
+			_CHN_VOICE(dev, MIDI_KEY_PRESSURE, chn, note, pressure)
+
+/*
+ * Midi channel messages
+ */
+
+#define _CHN_COMMON(dev, event, chn, p1, p2, w14) \
+				{_SEQ_NEEDBUF(8);\
+				_seqbuf[_seqbufptr] = EV_CHN_COMMON;\
+				_seqbuf[_seqbufptr+1] = (dev);\
+				_seqbuf[_seqbufptr+2] = (event);\
+				_seqbuf[_seqbufptr+3] = (chn);\
+				_seqbuf[_seqbufptr+4] = (p1);\
+				_seqbuf[_seqbufptr+5] = (p2);\
+				*(short *)&_seqbuf[_seqbufptr+6] = (w14);\
+				_SEQ_ADVBUF(8);}
+/*
+ * SEQ_SYSEX permits sending of sysex messages. (It may look that it permits
+ * sending any MIDI bytes but it's absolutely not possible. Trying to do
+ * so _will_ cause problems with MPU401 intelligent mode).
+ *
+ * Sysex messages are sent in blocks of 1 to 6 bytes. Longer messages must be 
+ * sent by calling SEQ_SYSEX() several times (there must be no other events
+ * between them). First sysex fragment must have 0xf0 in the first byte
+ * and the last byte (buf[len-1] of the last fragment must be 0xf7. No byte
+ * between these sysex start and end markers cannot be larger than 0x7f. Also
+ * lengths of each fragments (except the last one) must be 6.
+ *
+ * Breaking the above rules may work with some MIDI ports but is likely to
+ * cause fatal problems with some other devices (such as MPU401).
+ */
+#define SEQ_SYSEX(dev, buf, len) \
+				{int ii, ll=(len); \
+				 unsigned char *bufp=buf;\
+				 if (ll>6)ll=6;\
+				_SEQ_NEEDBUF(8);\
+				_seqbuf[_seqbufptr] = EV_SYSEX;\
+				_seqbuf[_seqbufptr+1] = (dev);\
+				for(ii=0;ii<ll;ii++)\
+				   _seqbuf[_seqbufptr+ii+2] = bufp[ii];\
+				for(ii=ll;ii<6;ii++)\
+				   _seqbuf[_seqbufptr+ii+2] = 0xff;\
+				_SEQ_ADVBUF(8);}
+
+#define SEQ_CHN_PRESSURE(dev, chn, pressure) \
+		_CHN_COMMON(dev, MIDI_CHN_PRESSURE, chn, pressure, 0, 0)
+
+#define SEQ_SET_PATCH SEQ_PGM_CHANGE
+#ifdef OSSLIB
+#   define SEQ_PGM_CHANGE(dev, chn, patch) \
+		{OSS_patch_caching(dev, chn, patch, seqfd, _seqbuf, _seqbuflen); \
+		 _CHN_COMMON(dev, MIDI_PGM_CHANGE, chn, patch, 0, 0);}
+#else
+#   define SEQ_PGM_CHANGE(dev, chn, patch) \
+		_CHN_COMMON(dev, MIDI_PGM_CHANGE, chn, patch, 0, 0)
+#endif
+
+#define SEQ_CONTROL(dev, chn, controller, value) \
+		_CHN_COMMON(dev, MIDI_CTL_CHANGE, chn, controller, 0, value)
+
+#define SEQ_BENDER(dev, chn, value) \
+		_CHN_COMMON(dev, MIDI_PITCH_BEND, chn, 0, 0, value)
+
+#define SEQ_V2_X_CONTROL(dev, voice, controller, value)	\
+				{_SEQ_NEEDBUF(8);\
+				_seqbuf[_seqbufptr] = SEQ_EXTENDED;\
+				_seqbuf[_seqbufptr+1] = SEQ_CONTROLLER;\
+				_seqbuf[_seqbufptr+2] = (dev);\
+				_seqbuf[_seqbufptr+3] = (voice);\
+				_seqbuf[_seqbufptr+4] = (controller);\
+				_seqbuf[_seqbufptr+5] = ((value)&0xff);\
+				_seqbuf[_seqbufptr+6] = ((value>>8)&0xff);\
+				_seqbuf[_seqbufptr+7] = 0;\
+				_SEQ_ADVBUF(8);}
+/*
+ * The following 5 macros are incorrectly implemented and obsolete.
+ * Use SEQ_BENDER and SEQ_CONTROL (with proper controller) instead.
+ */
+#define SEQ_PITCHBEND(dev, voice, value) \
+	SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER, value)
+#define SEQ_BENDER_RANGE(dev, voice, value) \
+	SEQ_V2_X_CONTROL(dev, voice, CTRL_PITCH_BENDER_RANGE, value)
+#define SEQ_EXPRESSION(dev, voice, value) \
+	SEQ_CONTROL(dev, voice, CTL_EXPRESSION, value*128)
+#define SEQ_MAIN_VOLUME(dev, voice, value) \
+	SEQ_CONTROL(dev, voice, CTL_MAIN_VOLUME, (value*16383)/100)
+#define SEQ_PANNING(dev, voice, pos) \
+	SEQ_CONTROL(dev, voice, CTL_PAN, (pos+128) / 2)
+
+/*
+ * Timing and syncronization macros
+ */
+
+#define _TIMER_EVENT(ev, parm)	{_SEQ_NEEDBUF(8);\
+			 	_seqbuf[_seqbufptr+0] = EV_TIMING; \
+			 	_seqbuf[_seqbufptr+1] = (ev); \
+				_seqbuf[_seqbufptr+2] = 0;\
+				_seqbuf[_seqbufptr+3] = 0;\
+			 	*(unsigned int *)&_seqbuf[_seqbufptr+4] = (parm); \
+				_SEQ_ADVBUF(8);}
+
+#define SEQ_START_TIMER()		_TIMER_EVENT(TMR_START, 0)
+#define SEQ_STOP_TIMER()		_TIMER_EVENT(TMR_STOP, 0)
+#define SEQ_CONTINUE_TIMER()		_TIMER_EVENT(TMR_CONTINUE, 0)
+#define SEQ_WAIT_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_ABS, ticks)
+#define SEQ_DELTA_TIME(ticks)		_TIMER_EVENT(TMR_WAIT_REL, ticks)
+#define SEQ_ECHO_BACK(key)		_TIMER_EVENT(TMR_ECHO, key)
+#define SEQ_SET_TEMPO(value)		_TIMER_EVENT(TMR_TEMPO, value)
+#define SEQ_SONGPOS(pos)		_TIMER_EVENT(TMR_SPP, pos)
+#define SEQ_TIME_SIGNATURE(sig)		_TIMER_EVENT(TMR_TIMESIG, sig)
+
+/*
+ * Local control events
+ */
+
+#define _LOCAL_EVENT(ev, parm)		{_SEQ_NEEDBUF(8);\
+				 	_seqbuf[_seqbufptr+0] = EV_SEQ_LOCAL; \
+				 	_seqbuf[_seqbufptr+1] = (ev); \
+					_seqbuf[_seqbufptr+2] = 0;\
+					_seqbuf[_seqbufptr+3] = 0;\
+				 	*(unsigned int *)&_seqbuf[_seqbufptr+4] = (parm); \
+					_SEQ_ADVBUF(8);}
+
+#define SEQ_PLAYAUDIO(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO, devmask)
+#define SEQ_PLAYAUDIO2(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO2, devmask)
+#define SEQ_PLAYAUDIO3(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO3, devmask)
+#define SEQ_PLAYAUDIO4(devmask)		_LOCAL_EVENT(LOCL_STARTAUDIO4, devmask)
+/*
+ * Events for the level 1 interface only 
+ */
+
+#define SEQ_MIDIOUT(device, byte)	{_SEQ_NEEDBUF(4);\
+					_seqbuf[_seqbufptr] = SEQ_MIDIPUTC;\
+					_seqbuf[_seqbufptr+1] = (byte);\
+					_seqbuf[_seqbufptr+2] = (device);\
+					_seqbuf[_seqbufptr+3] = 0;\
+					_SEQ_ADVBUF(4);}
+
+/*
+ * Patch loading.
+ */
+#ifdef OSSLIB
+#   define SEQ_WRPATCH(patchx, len) \
+		OSS_write_patch(seqfd, (char*)(patchx), len)
+#   define SEQ_WRPATCH2(patchx, len) \
+		OSS_write_patch2(seqfd, (char*)(patchx), len)
+#else
+#   define SEQ_WRPATCH(patchx, len) \
+		{if (_seqbufptr) SEQ_DUMPBUF();\
+		 if (write(seqfd, (char*)(patchx), len)==-1) \
+		    perror("Write patch: /dev/sequencer");}
+#   define SEQ_WRPATCH2(patchx, len) \
+		(SEQ_DUMPBUF(), write(seqfd, (char*)(patchx), len))
+#endif
+
+#endif
+#endif /* ifndef DISABLE_SEQUENCER */
+
+/*
+ ****************************************************************************
+ * ioctl commands for the /dev/midi## 
+ ****************************************************************************/
+#define SNDCTL_MIDI_PRETIME	__SIOWR('m', 0, int)
+
+#if 0
+/*
+ * The SNDCTL_MIDI_MPUMODE and SNDCTL_MIDI_MPUCMD calls
+ * are completely obsolete. The hardware device (MPU-401 "intelligent mode"
+ * and compatibles) has disappeared from the market 10 years ago so there 
+ * is no need for this stuff. The MPU-401 "UART" mode devices don't support
+ * this stuff.
+ */
+typedef struct
+{
+  unsigned char cmd;
+  char nr_args, nr_returns;
+  unsigned char data[30];
+} mpu_command_rec;
+
+#define SNDCTL_MIDI_MPUMODE	__SIOWR('m', 1, int)
+#define SNDCTL_MIDI_MPUCMD	__SIOWR('m', 2, mpu_command_rec)
+#endif
+
+/*
+ * SNDCTL_MIDI_MTCINPUT turns on a mode where OSS automatically inserts
+ * MTC quarter frame messages (F1 xx) to the input.
+ * The argument is the MTC mode:
+ *
+ * 	-1 = Turn MTC messages OFF (default)
+ *	24 = 24 FPS 
+ *	25 = 25 FPS 
+ *	29 = 30 FPS drop frame
+ *	30 = 30 FPS 
+ *
+ * Note that 25 FPS mode is probably the only mode that is supported. Other
+ * modes may be supported in the future versions of OSS, 25 FPS is handy 
+ * because it generates 25*4=100 quarter frame messages per second which
+ * matches the usual 100 HZ system timer rate).
+ *
+ * The quarter frame timer will be reset to 0:00:00:00.0 at the moment this
+ * ioctl is made.
+ */
+#define SNDCTL_MIDI_MTCINPUT	__SIOWR('m', 3, int)
+
+/*
+ * MTC/SMPTE time code record (for future use)
+ */
+typedef struct
+{
+  unsigned char hours, minutes, seconds, frames, qframes;
+  char direction;
+#define MTC_DIR_STOPPED		 0
+#define MTC_DIR_FORWARD		 1
+#define MTC_DIR_BACKWARD	-1
+  unsigned char time_code_type;
+  unsigned int flags;
+} oss_mtc_data_t;
+
+#define SNDCTL_MIDI_SETMODE	__SIOWR('m', 6, int)
+#	define MIDI_MODE_TRADITIONAL	0
+#	define MIDI_MODE_TIMED		1	/* Input times are in MIDI ticks */
+#	define MIDI_MODE_TIMED_ABS  	2	/* Input times are absolute (usecs) */
+
+/*
+ * Packet header for MIDI_MODE_TIMED and MIDI_MODE_TIMED_ABS
+ */
+#ifdef OSS_NO_LONG_LONG
+  typedef unsigned long oss_midi_time_t;	/* This will not be enough but anyway */
+#else
+  typedef unsigned long long oss_midi_time_t;	/* Variable type for MIDI time (clock ticks) */
+#endif
+
+typedef struct
+{
+  int magic;			/* Initialize to MIDI_HDR_MAGIC */
+#define MIDI_HDR_MAGIC	-1
+  unsigned short event_type;
+#define MIDI_EV_WRITE			0	/* Write or read (with payload) */
+#define MIDI_EV_TEMPO			1
+#define MIDI_EV_ECHO			2
+#define MIDI_EV_START			3
+#define MIDI_EV_STOP			4
+#define MIDI_EV_CONTINUE		5
+#define MIDI_EV_XPRESSWRITE		6
+#define MIDI_EV_TIMEBASE		7
+#define MIDI_EV_DEVCTL			8	/* Device control read/write */
+  unsigned short options;
+#define MIDI_OPT_NONE			0x0000
+#define MIDI_OPT_TIMED			0x0001
+#define MIDI_OPT_CONTINUATION		0x0002
+#define MIDI_OPT_USECTIME		0x0004	/* Time is absolute (in usecs) */
+#define MIDI_OPT_BUSY			0x0008	/* Reserved for internal use */
+  oss_midi_time_t time;
+#ifdef OSS_NO_LONG_LONG
+  /* oss_midi_time_t is just 32 bits instead of 64. Use a padding word to compensate this */
+  int budding;
+#endif
+  int parm;
+  int filler[3];		/* Fur future expansion - init to zeros */
+} midi_packet_header_t;
+/* 
+ * MIDI_PAYLOAD_SIZE is the maximum size of one MIDI input chunk. It must be
+ * less (or equal) than 1024 which is the read size recommended in the 
+ * documentation. TODO: Explain this better.
+ */
+#define MIDI_PAYLOAD_SIZE		1000
+
+typedef struct
+{
+  midi_packet_header_t hdr;
+  unsigned char payload[MIDI_PAYLOAD_SIZE];
+} midi_packet_t;
+
+#define SNDCTL_MIDI_TIMEBASE		__SIOWR('m', 7, int)
+#define SNDCTL_MIDI_TEMPO		__SIOWR('m', 8, int)
+/*
+ * User land MIDI servers (synths) can use SNDCTL_MIDI_SET_LATENCY
+ * to request MIDI events to be sent to them in advance. The parameter
+ * (in microseconds) tells how much before the events are submitted.
+ *
+ * This feature is only valid for loopback devices and possibly some other
+ * types of virtual devices.
+ */
+#define SNDCTL_MIDI_SET_LATENCY		__SIOW ('m', 9, int)
+/*
+ ****************************************************************************
+ * IOCTL commands for /dev/dsp
+ ****************************************************************************/
+
+#define SNDCTL_DSP_HALT			__SIO  ('P', 0)
+#define SNDCTL_DSP_RESET		SNDCTL_DSP_HALT	/* Old name */
+#define SNDCTL_DSP_SYNC			__SIO  ('P', 1)
+#define SNDCTL_DSP_SPEED		__SIOWR('P', 2, int)
+
+/* SNDCTL_DSP_STEREO is obsolete - use SNDCTL_DSP_CHANNELS instead */
+#define SNDCTL_DSP_STEREO		__SIOWR('P', 3, int)
+/* SNDCTL_DSP_STEREO is obsolete - use SNDCTL_DSP_CHANNELS instead */
+
+#define SNDCTL_DSP_GETBLKSIZE		__SIOWR('P', 4, int)
+#define SNDCTL_DSP_SAMPLESIZE		SNDCTL_DSP_SETFMT
+#define SNDCTL_DSP_CHANNELS		__SIOWR('P', 6, int)
+#define SNDCTL_DSP_POST			__SIO  ('P', 8)
+#define SNDCTL_DSP_SUBDIVIDE		__SIOWR('P', 9, int)
+#define SNDCTL_DSP_SETFRAGMENT		__SIOWR('P',10, int)
+
+/* Audio data formats (Note! U8=8 and S16_LE=16 for compatibility) */
+#define SNDCTL_DSP_GETFMTS		__SIOR ('P',11, int)	/* Returns a mask */
+#define SNDCTL_DSP_SETFMT		__SIOWR('P',5, int)	/* Selects ONE fmt */
+#	define AFMT_QUERY	0x00000000	/* Return current fmt */
+#	define AFMT_MU_LAW	0x00000001
+#	define AFMT_A_LAW	0x00000002
+#	define AFMT_IMA_ADPCM	0x00000004
+#	define AFMT_U8		0x00000008
+#	define AFMT_S16_LE	0x00000010	/* Little endian signed 16 */
+#	define AFMT_S16_BE	0x00000020	/* Big endian signed 16 */
+#	define AFMT_S8		0x00000040
+#	define AFMT_U16_LE	0x00000080	/* Little endian U16 */
+#	define AFMT_U16_BE	0x00000100	/* Big endian U16 */
+#	define AFMT_MPEG	0x00000200	/* MPEG (2) audio */
+
+/* AC3 _compressed_ bitstreams (See Programmer's Guide for details). */
+#	define AFMT_AC3		0x00000400
+/* Ogg Vorbis _compressed_ bit streams */
+#	define AFMT_VORBIS	0x00000800
+
+/* 32 bit formats (MSB aligned) formats */
+#	define AFMT_S32_LE	0x00001000
+#	define AFMT_S32_BE	0x00002000
+
+/* Reserved for _native_ endian double precision IEEE floating point */
+#	define AFMT_FLOAT	0x00004000
+
+/* 24 bit formats (LSB aligned in 32 bit word) formats */
+#	define AFMT_S24_LE	0x00008000
+#	define AFMT_S24_BE	0x00010000
+
+/*
+ * S/PDIF raw format. In this format the S/PDIF frames (including all
+ * control and user bits) are included in the data stream. Each sample
+ * is stored in a 32 bit frame (see IEC-958 for more info). This format
+ * is supported by very few devices and it's only usable for purposes
+ * where full access to the control/user bits is required (real time control).
+ */
+#	define AFMT_SPDIF_RAW	0x00020000
+
+/* 24 bit packed (3 byte) little endian format (USB compatibility) */
+#	define AFMT_S24_PACKED	0x00040000
+
+
+/*
+ * Some big endian/little endian handling macros (native endian and opposite
+ * endian formats). The usage of these macros is described in the OSS
+ * Programmer's Manual.
+ */
+
+#if defined(_AIX) || defined(AIX) || defined(sparc) || defined(__hppa) || defined(PPC) || defined(__powerpc__) && !defined(i386) && !defined(__i386) && !defined(__i386__)
+
+/* Big endian machines */
+#  define _PATCHKEY(id) (0xfd00|id)
+#  define AFMT_S16_NE AFMT_S16_BE
+#  define AFMT_U16_NE AFMT_U16_BE
+#  define AFMT_S32_NE AFMT_S32_BE
+#  define AFMT_S24_NE AFMT_S24_BE
+#  define AFMT_S16_OE AFMT_S16_LE
+#  define AFMT_S32_OE AFMT_S32_LE
+#  define AFMT_S24_OE AFMT_S24_LE
+#else
+#  define _PATCHKEY(id) ((id<<8)|0xfd)
+#  define AFMT_S16_NE AFMT_S16_LE
+#  define AFMT_U16_NE AFMT_U16_LE
+#  define AFMT_S32_NE AFMT_S32_LE
+#  define AFMT_S24_NE AFMT_S24_LE
+#  define AFMT_S16_OE AFMT_S16_BE
+#  define AFMT_S32_OE AFMT_S32_BE
+#  define AFMT_S24_OE AFMT_S24_BE
+#endif
+/*
+ * Buffer status queries.
+ */
+typedef struct audio_buf_info
+{
+  int fragments;		/* # of available fragments (partially usend ones not counted) */
+  int fragstotal;		/* Total # of fragments allocated */
+  int fragsize;			/* Size of a fragment in bytes */
+  int bytes;			/* Available space in bytes (includes partially used fragments) */
+  /* Note! 'bytes' could be more than fragments*fragsize */
+} audio_buf_info;
+
+#define SNDCTL_DSP_GETOSPACE		__SIOR ('P',12, audio_buf_info)
+#define SNDCTL_DSP_GETISPACE		__SIOR ('P',13, audio_buf_info)
+#define SNDCTL_DSP_GETCAPS		__SIOR ('P',15, int)
+#	define PCM_CAP_REVISION		0x000000ff	/* Bits for revision level (0 to 255) */
+#	define PCM_CAP_DUPLEX		0x00000100	/* Full duplex record/playback */
+#	define PCM_CAP_REALTIME		0x00000200	/* Not in use */
+#	define PCM_CAP_BATCH		0x00000400	/* Device has some kind of */
+							/* internal buffers which may */
+							/* cause some delays and */
+							/* decrease precision of timing */
+#	define PCM_CAP_COPROC		0x00000800	/* Has a coprocessor */
+							/* Sometimes it's a DSP */
+							/* but usually not */
+#	define PCM_CAP_TRIGGER		0x00001000	/* Supports SETTRIGGER */
+#	define PCM_CAP_MMAP		0x00002000	/* Supports mmap() */
+#	define PCM_CAP_MULTI		0x00004000	/* Supports multiple open */
+#	define PCM_CAP_BIND		0x00008000	/* Supports binding to front/rear/center/lfe */
+#   	define PCM_CAP_INPUT		0x00010000	/* Supports recording */
+#   	define PCM_CAP_OUTPUT		0x00020000	/* Supports playback */
+#	define PCM_CAP_VIRTUAL		0x00040000	/* Virtual device */
+/* 0x00040000 and 0x00080000 reserved for future use */
+
+/* Analog/digital control capabilities */
+#	define PCM_CAP_ANALOGOUT	0x00100000
+#	define PCM_CAP_ANALOGIN		0x00200000
+#	define PCM_CAP_DIGITALOUT	0x00400000
+#	define PCM_CAP_DIGITALIN	0x00800000
+#	define PCM_CAP_ADMASK		0x00f00000
+/*
+ * NOTE! (capabilities & PCM_CAP_ADMASK)==0 means just that the
+ * digital/analog interface control features are not supported by the 
+ * device/driver. However the device still supports analog, digital or
+ * both inputs/outputs (depending on the device). See the OSS Programmer's
+ * Guide for full details.
+ */
+#	define PCM_CAP_SPECIAL		0x01000000	/* Not for ordinary "multimedia" use */
+#	define PCM_CAP_SHADOW		0x00000000	/* OBSOLETE */
+
+/*
+ * Preferred channel usage. These bits can be used to
+ * give recommendations to the application. Used by few drivers.
+ * For example if ((caps & DSP_CH_MASK) == DSP_CH_MONO) means that
+ * the device works best in mono mode. However it doesn't necessarily mean
+ * that the device cannot be used in stereo. These bits should only be used
+ * by special applications such as multi track hard disk recorders to find
+ * out the initial setup. However the user should be able to override this
+ * selection.
+ *
+ * To find out which modes are actually supported the application should 
+ * try to select them using SNDCTL_DSP_CHANNELS.
+ */
+#	define DSP_CH_MASK		0x06000000	/* Mask */
+#	define DSP_CH_ANY		0x00000000	/* No preferred mode */
+#	define DSP_CH_MONO		0x02000000
+#	define DSP_CH_STEREO		0x04000000
+#	define DSP_CH_MULTI		0x06000000	/* More than two channels */
+
+#	define PCM_CAP_HIDDEN		0x08000000	/* Hidden device */
+#	define PCM_CAP_FREERATE		0x10000000
+#	define PCM_CAP_MODEM		0x20000000	/* Modem device */
+#	define PCM_CAP_DEFAULT		0x40000000	/* "Default" device */
+
+/*
+ * The PCM_CAP_* capability names were known as DSP_CAP_* prior OSS 4.0
+ * so it's necessary to define the older names too.
+ */
+#define DSP_CAP_ADMASK		PCM_CAP_ADMASK
+#define DSP_CAP_ANALOGIN	PCM_CAP_ANALOGIN
+#define DSP_CAP_ANALOGOUT	PCM_CAP_ANALOGOUT
+#define DSP_CAP_BATCH		PCM_CAP_BATCH
+#define DSP_CAP_BIND		PCM_CAP_BIND
+#define DSP_CAP_COPROC		PCM_CAP_COPROC
+#define DSP_CAP_DEFAULT		PCM_CAP_DEFAULT
+#define DSP_CAP_DIGITALIN	PCM_CAP_DIGITALIN
+#define DSP_CAP_DIGITALOUT	PCM_CAP_DIGITALOUT
+#define DSP_CAP_DUPLEX		PCM_CAP_DUPLEX
+#define DSP_CAP_FREERATE	PCM_CAP_FREERATE
+#define DSP_CAP_HIDDEN		PCM_CAP_HIDDEN
+#define DSP_CAP_INPUT		PCM_CAP_INPUT
+#define DSP_CAP_MMAP		PCM_CAP_MMAP
+#define DSP_CAP_MODEM		PCM_CAP_MODEM
+#define DSP_CAP_MULTI		PCM_CAP_MULTI
+#define DSP_CAP_OUTPUT		PCM_CAP_OUTPUT
+#define DSP_CAP_REALTIME	PCM_CAP_REALTIME
+#define DSP_CAP_REVISION	PCM_CAP_REVISION
+#define DSP_CAP_SHADOW		PCM_CAP_SHADOW
+#define DSP_CAP_TRIGGER		PCM_CAP_TRIGGER
+#define DSP_CAP_VIRTUAL		PCM_CAP_VIRTUAL
+
+#define SNDCTL_DSP_GETTRIGGER		__SIOR ('P',16, int)
+#define SNDCTL_DSP_SETTRIGGER		__SIOW ('P',16, int)
+#	define PCM_ENABLE_INPUT		0x00000001
+#	define PCM_ENABLE_OUTPUT	0x00000002
+
+typedef struct count_info
+{
+  unsigned int bytes;		/* Total # of bytes processed */
+  int blocks;			/* # of fragment transitions since last time */
+  int ptr;			/* Current DMA pointer value */
+} count_info;
+
+#define SNDCTL_DSP_GETIPTR		__SIOR ('P',17, count_info)
+#define SNDCTL_DSP_GETOPTR		__SIOR ('P',18, count_info)
+
+typedef struct buffmem_desc
+{
+  unsigned *buffer;
+  int size;
+} buffmem_desc;
+#define SNDCTL_DSP_SETSYNCRO		__SIO  ('P', 21)
+#define SNDCTL_DSP_SETDUPLEX		__SIO  ('P', 22)
+
+#define SNDCTL_DSP_PROFILE		__SIOW ('P', 23, int)	/* OBSOLETE */
+#define	  APF_NORMAL	0	/* Normal applications */
+#define	  APF_NETWORK	1	/* Underruns probably caused by an "external" delay */
+#define   APF_CPUINTENS 2	/* Underruns probably caused by "overheating" the CPU */
+
+#define SNDCTL_DSP_GETODELAY		__SIOR ('P', 23, int)
+
+typedef struct audio_errinfo
+{
+  int play_underruns;
+  int rec_overruns;
+  unsigned int play_ptradjust;
+  unsigned int rec_ptradjust;
+  int play_errorcount;
+  int rec_errorcount;
+  int play_lasterror;
+  int rec_lasterror;
+  int play_errorparm;
+  int rec_errorparm;
+  int filler[16];
+} audio_errinfo;
+
+#define SNDCTL_DSP_GETPLAYVOL		__SIOR ('P', 24, int)
+#define SNDCTL_DSP_SETPLAYVOL		__SIOWR('P', 24, int)
+#define SNDCTL_DSP_GETERROR		__SIOR ('P', 25, audio_errinfo)
+/*
+ ****************************************************************************
+ * Digital interface (S/PDIF) control interface
+ */
+
+typedef struct oss_digital_control
+{
+  unsigned int caps;
+#define DIG_CBITIN_NONE			0x00000000
+#define DIG_CBITIN_LIMITED		0x00000001
+#define DIG_CBITIN_DATA 		0x00000002
+#define DIG_CBITIN_BYTE0		0x00000004
+#define DIG_CBITIN_FULL 		0x00000008
+#define DIG_CBITIN_MASK 		0x0000000f
+#define DIG_CBITOUT_NONE		0x00000000
+#define DIG_CBITOUT_LIMITED		0x00000010
+#define DIG_CBITOUT_BYTE0		0x00000020
+#define DIG_CBITOUT_FULL 		0x00000040
+#define DIG_CBITOUT_DATA 		0x00000080
+#define DIG_CBITOUT_MASK 		0x000000f0
+#define DIG_UBITIN			0x00000100
+#define DIG_UBITOUT			0x00000200
+#define DIG_VBITOUT			0x00000400
+#define DIG_OUTRATE			0x00000800
+#define DIG_INRATE			0x00001000
+#define DIG_INBITS			0x00002000
+#define DIG_OUTBITS			0x00004000
+#define DIG_EXACT			0x00010000
+#define DIG_PRO				0x00020000
+#define DIG_CONSUMER			0x00040000
+#define DIG_PASSTHROUGH			0x00080000
+#define DIG_OUTSEL			0x00100000
+
+  unsigned int valid;
+#define VAL_CBITIN			0x00000001
+#define VAL_UBITIN			0x00000002
+#define VAL_CBITOUT			0x00000004
+#define VAL_UBITOUT			0x00000008
+#define VAL_ISTATUS			0x00000010
+#define VAL_IRATE			0x00000020
+#define VAL_ORATE			0x00000040
+#define VAL_INBITS			0x00000080
+#define VAL_OUTBITS			0x00000100
+#define VAL_REQUEST			0x00000200
+#define VAL_OUTSEL			0x00000400
+
+#define VAL_OUTMASK (VAL_CBITOUT|VAL_UBITOUT|VAL_ORATE|VAL_OUTBITS|VAL_OUTSEL)
+
+  unsigned int request, param;
+#define SPD_RQ_PASSTHROUGH				1
+
+  unsigned char cbitin[24];
+  unsigned char ubitin[24];
+  unsigned char cbitout[24];
+  unsigned char ubitout[24];
+
+  unsigned int outsel;
+#define OUTSEL_DIGITAL		1
+#define OUTSEL_ANALOG		2
+#define OUTSEL_BOTH		(OUTSEL_DIGITAL|OUTSEL_ANALOG)
+
+  int in_data;			/* Audio/data if autodetectable by the receiver */
+#define IND_UNKNOWN		0
+#define IND_AUDIO		1
+#define IND_DATA		2
+
+  int in_locked;		/* Receiver locked */
+#define LOCK_NOT_INDICATED	0
+#define LOCK_UNLOCKED		1
+#define LOCK_LOCKED		2
+
+  int in_quality;		/* Input signal quality */
+#define IN_QUAL_NOT_INDICATED	0
+#define IN_QUAL_POOR		1
+#define IN_QUAL_GOOD		2
+
+  int in_vbit, out_vbit;	/* V bits */
+#define VBIT_NOT_INDICATED	0
+#define VBIT_OFF		1
+#define VBIT_ON			2
+
+  unsigned int in_errors;	/* Various input error conditions */
+#define INERR_CRC		0x0001
+#define INERR_QCODE_CRC		0x0002
+#define INERR_PARITY		0x0004
+#define INERR_BIPHASE		0x0008
+
+  int srate_in, srate_out;
+  int bits_in, bits_out;
+
+  int filler[32];
+} oss_digital_control;
+
+#define SNDCTL_DSP_READCTL		__SIOWR('P', 26, oss_digital_control)
+#define SNDCTL_DSP_WRITECTL		__SIOWR('P', 27, oss_digital_control)
+
+/*
+ ****************************************************************************
+ * Sync groups for audio devices
+ */
+typedef struct oss_syncgroup
+{
+  int id;
+  int mode;
+  int filler[16];
+} oss_syncgroup;
+
+#define SNDCTL_DSP_SYNCGROUP		__SIOWR('P', 28, oss_syncgroup)
+#define SNDCTL_DSP_SYNCSTART		__SIOW ('P', 29, int)
+
+/*
+ **************************************************************************
+ * "cooked" mode enables software based conversions for sample rate, sample
+ * format (bits) and number of channels (mono/stereo). These conversions are
+ * required with some devices that support only one sample rate or just stereo
+ * to let the applications to use other formats. The cooked mode is enabled by
+ * default. However it's necessary to disable this mode when mmap() is used or
+ * when very deterministic timing is required. SNDCTL_DSP_COOKEDMODE is an
+ * optional call introduced in OSS 3.9.6f. It's _error return must be ignored_
+ * since normally this call will return erno=EINVAL.
+ *
+ * SNDCTL_DSP_COOKEDMODE must be called immediately after open before doing
+ * anything else. Otherwise the call will not have any effect.
+ */
+#define SNDCTL_DSP_COOKEDMODE		__SIOW ('P', 30, int)
+
+/*
+ **************************************************************************
+ * SNDCTL_DSP_SILENCE and SNDCTL_DSP_SKIP are new calls in OSS 3.99.0
+ * that can be used to implement pause/continue during playback (no effect
+ * on recording).
+ */
+#define SNDCTL_DSP_SILENCE		__SIO  ('P', 31)
+#define SNDCTL_DSP_SKIP			__SIO  ('P', 32)
+/*
+ ****************************************************************************
+ * Abort transfer (reset) functions for input and output
+ */
+#define SNDCTL_DSP_HALT_INPUT		__SIO  ('P', 33)
+#define SNDCTL_DSP_RESET_INPUT	SNDCTL_DSP_HALT_INPUT	/* Old name */
+#define SNDCTL_DSP_HALT_OUTPUT		__SIO  ('P', 34)
+#define SNDCTL_DSP_RESET_OUTPUT	SNDCTL_DSP_HALT_OUTPUT	/* Old name */
+/*
+ ****************************************************************************
+ * Low water level control
+ */
+#define SNDCTL_DSP_LOW_WATER		__SIOW ('P', 34, int)
+
+/*
+ ****************************************************************************
+ * 64 bit pointer support. Only available in environments that support
+ * the 64 bit (long long) integer type.
+ */
+#ifndef OSS_NO_LONG_LONG
+typedef struct
+{
+  long long samples;
+  int fifo_samples;
+  int filler[32];		/* For future use */
+} oss_count_t;
+
+#define SNDCTL_DSP_CURRENT_IPTR		__SIOR ('P', 35, oss_count_t)
+#define SNDCTL_DSP_CURRENT_OPTR		__SIOR ('P', 36, oss_count_t)
+#endif
+
+/*
+ ****************************************************************************
+ * Interface for selecting recording sources and playback output routings.
+ */
+#define SNDCTL_DSP_GET_RECSRC_NAMES	__SIOR ('P', 37, oss_mixer_enuminfo)
+#define SNDCTL_DSP_GET_RECSRC		__SIOR ('P', 38, int)
+#define SNDCTL_DSP_SET_RECSRC		__SIOWR('P', 38, int)
+
+#define SNDCTL_DSP_GET_PLAYTGT_NAMES	__SIOR ('P', 39, oss_mixer_enuminfo)
+#define SNDCTL_DSP_GET_PLAYTGT		__SIOR ('P', 40, int)
+#define SNDCTL_DSP_SET_PLAYTGT		__SIOWR('P', 40, int)
+#define SNDCTL_DSP_GETRECVOL		__SIOR ('P', 41, int)
+#define SNDCTL_DSP_SETRECVOL		__SIOWR('P', 41, int)
+
+/*
+ ***************************************************************************
+ * Some calls for setting the channel assignment with multi channel devices
+ * (see the manual for details).
+ */
+#ifndef OSS_NO_LONG_LONG
+#define SNDCTL_DSP_GET_CHNORDER		__SIOR ('P', 42, unsigned long long)
+#define SNDCTL_DSP_SET_CHNORDER		__SIOWR('P', 42, unsigned long long)
+#	define CHID_UNDEF	0
+#	define CHID_L		1
+#	define CHID_R		2
+#	define CHID_C		3
+#	define CHID_LFE		4
+#	define CHID_LS		5
+#	define CHID_RS		6
+#	define CHID_LR		7
+#	define CHID_RR		8
+#define CHNORDER_UNDEF		0x0000000000000000ULL
+#define CHNORDER_NORMAL		0x0000000087654321ULL
+#endif
+
+#define MAX_PEAK_CHANNELS	128
+typedef unsigned short oss_peaks_t[MAX_PEAK_CHANNELS];
+#define SNDCTL_DSP_GETIPEAKS		__SIOR('P', 43, oss_peaks_t)
+#define SNDCTL_DSP_GETOPEAKS		__SIOR('P', 44, oss_peaks_t)
+
+#define SNDCTL_DSP_POLICY		__SIOW('P', 45, int)	/* See the manual */
+
+/*
+ ****************************************************************************
+ * Few ioctl calls that are not official parts of OSS. They have been used
+ * by few freeware implementations of OSS.
+ */
+#define SNDCTL_DSP_GETCHANNELMASK	__SIOWR('P', 64, int)
+#define SNDCTL_DSP_BIND_CHANNEL		__SIOWR('P', 65, int)
+#     define DSP_BIND_QUERY           0x00000000
+#     define DSP_BIND_FRONT           0x00000001
+#     define DSP_BIND_SURR            0x00000002
+#     define DSP_BIND_CENTER_LFE      0x00000004
+#     define DSP_BIND_HANDSET         0x00000008
+#     define DSP_BIND_MIC             0x00000010
+#     define DSP_BIND_MODEM1          0x00000020
+#     define DSP_BIND_MODEM2          0x00000040
+#     define DSP_BIND_I2S             0x00000080
+#     define DSP_BIND_SPDIF           0x00000100
+#     define DSP_BIND_REAR            0x00000200
+
+#ifdef sun
+/* Not part of OSS. Reserved for internal use by Solaris */
+#define X_SADA_GET_PLAYTGT_MASK	__SIOR ('P', 66, int)
+#define X_SADA_GET_PLAYTGT	__SIOR ('P', 67, int)
+#define X_SADA_SET_PLAYTGT	__SIOWR('P', 68, int)
+#endif
+
+/*
+ ****************************************************************************
+ * Modem interface
+ */
+#define SNDCTL_DSP_MODEM_OFFHOOK        __SIOWR('P', 69, int)
+
+#ifndef NO_LEGACY_MIXER
+/*
+ ****************************************************************************
+ * IOCTL commands for the "legacy " /dev/mixer API (obsolete)
+ *
+ * Mixer controls
+ *
+ * There can be up to 20 different analog mixer channels. The
+ * SOUND_MIXER_NRDEVICES gives the currently supported maximum. 
+ * The SOUND_MIXER_READ_DEVMASK returns a bitmask which tells
+ * the devices supported by the particular mixer.
+ *
+ * {!notice This "legacy" mixer API is obsolete. It has been superceded
+ * by a new one (see below).
+ */
+
+#define SOUND_MIXER_NRDEVICES	28
+#define SOUND_MIXER_VOLUME	0
+#define SOUND_MIXER_BASS	1
+#define SOUND_MIXER_TREBLE	2
+#define SOUND_MIXER_SYNTH	3
+#define SOUND_MIXER_PCM		4
+#define SOUND_MIXER_SPEAKER	5
+#define SOUND_MIXER_LINE	6
+#define SOUND_MIXER_MIC		7
+#define SOUND_MIXER_CD		8
+#define SOUND_MIXER_IMIX	9	/*  Recording monitor  */
+#define SOUND_MIXER_ALTPCM	10
+#define SOUND_MIXER_RECLEV	11	/* Recording level */
+#define SOUND_MIXER_IGAIN	12	/* Input gain */
+#define SOUND_MIXER_OGAIN	13	/* Output gain */
+/* 
+ * Some soundcards have three line level inputs (line, aux1 and aux2). 
+ * Since each card manufacturer has assigned different meanings to 
+ * these inputs, it's impractical to assign specific meanings 
+ * (eg line, cd, synth etc.) to them.
+ */
+#define SOUND_MIXER_LINE1	14	/* Input source 1  (aux1) */
+#define SOUND_MIXER_LINE2	15	/* Input source 2  (aux2) */
+#define SOUND_MIXER_LINE3	16	/* Input source 3  (aux3) */
+#define SOUND_MIXER_DIGITAL1	17	/* Digital I/O 1 */
+#define SOUND_MIXER_DIGITAL2	18	/* Digital I/O 2 */
+#define SOUND_MIXER_DIGITAL3	19	/* Digital I/O 3 */
+#define SOUND_MIXER_PHONE	20	/* Phone */
+#define SOUND_MIXER_MONO	21	/* Mono Output */
+#define SOUND_MIXER_VIDEO	22	/* Video/TV (audio) in */
+#define SOUND_MIXER_RADIO	23	/* Radio in */
+#define SOUND_MIXER_DEPTH	24	/* Surround depth */
+#define SOUND_MIXER_REARVOL	25	/* Rear/Surround speaker vol */
+#define SOUND_MIXER_CENTERVOL	26	/* Center/LFE speaker vol */
+#define SOUND_MIXER_SIDEVOL	27	/* Side-Surround (8speaker) vol */
+
+/*
+ * Warning: SOUND_MIXER_SURRVOL is an old name of SOUND_MIXER_SIDEVOL.
+ *          They are both assigned to the same mixer control. Don't
+ *          use both control names in the same program/driver.
+ */
+#define SOUND_MIXER_SURRVOL	SOUND_MIXER_SIDEVOL
+
+/* Some on/off settings (SOUND_SPECIAL_MIN - SOUND_SPECIAL_MAX) */
+/* Not counted to SOUND_MIXER_NRDEVICES, but use the same number space */
+#define SOUND_ONOFF_MIN		28
+#define SOUND_ONOFF_MAX		30
+
+/* Note!	Number 31 cannot be used since the sign bit is reserved */
+#define SOUND_MIXER_NONE	31
+
+/*
+ * The following unsupported macros are no longer functional.
+ * Use SOUND_MIXER_PRIVATE# macros in future.
+ */
+#define SOUND_MIXER_ENHANCE	SOUND_MIXER_NONE
+#define SOUND_MIXER_MUTE	SOUND_MIXER_NONE
+#define SOUND_MIXER_LOUD	SOUND_MIXER_NONE
+
+#define SOUND_DEVICE_LABELS \
+	{"Vol  ", "Bass ", "Treble", "Synth", "Pcm  ", "Speaker ", "Line ", \
+	 "Mic  ", "CD   ", "Mix  ", "Pcm2 ", "Rec  ", "IGain", "OGain", \
+	 "Aux1", "Aux2", "Aux3", "Digital1", "Digital2", "Digital3", \
+	 "Phone", "Mono", "Video", "Radio", "Depth", \
+	 "Rear", "Center", "Side"}
+
+#define SOUND_DEVICE_NAMES \
+	{"vol", "bass", "treble", "synth", "pcm", "speaker", "line", \
+	 "mic", "cd", "mix", "pcm2", "rec", "igain", "ogain", \
+	 "aux1", "aux2", "aux3", "dig1", "dig2", "dig3", \
+	 "phone", "mono", "video", "radio", "depth", \
+	 "rear", "center", "side"}
+
+/*	Device bitmask identifiers	*/
+
+#define SOUND_MIXER_RECSRC	0xff	/* Arg contains a bit for each recording source */
+#define SOUND_MIXER_DEVMASK	0xfe	/* Arg contains a bit for each supported device */
+#define SOUND_MIXER_RECMASK	0xfd	/* Arg contains a bit for each supported recording source */
+#define SOUND_MIXER_CAPS	0xfc
+#	define SOUND_CAP_EXCL_INPUT	0x00000001	/* Only one recording source at a time */
+#	define SOUND_CAP_NOLEGACY	0x00000004	/* For internal use only */
+#	define SOUND_CAP_NORECSRC	0x00000008
+#define SOUND_MIXER_STEREODEVS	0xfb	/* Mixer channels supporting stereo */
+
+/* OSS/Free ONLY */
+#define SOUND_MIXER_OUTSRC    0xfa	/* Arg contains a bit for each input source to output */
+#define SOUND_MIXER_OUTMASK   0xf9	/* Arg contains a bit for each supported input source to output */
+/* OSS/Free ONLY */
+
+/*	Device mask bits	*/
+
+#define SOUND_MASK_VOLUME	(1 << SOUND_MIXER_VOLUME)
+#define SOUND_MASK_BASS		(1 << SOUND_MIXER_BASS)
+#define SOUND_MASK_TREBLE	(1 << SOUND_MIXER_TREBLE)
+#define SOUND_MASK_SYNTH	(1 << SOUND_MIXER_SYNTH)
+#define SOUND_MASK_PCM		(1 << SOUND_MIXER_PCM)
+#define SOUND_MASK_SPEAKER	(1 << SOUND_MIXER_SPEAKER)
+#define SOUND_MASK_LINE		(1 << SOUND_MIXER_LINE)
+#define SOUND_MASK_MIC		(1 << SOUND_MIXER_MIC)
+#define SOUND_MASK_CD		(1 << SOUND_MIXER_CD)
+#define SOUND_MASK_IMIX		(1 << SOUND_MIXER_IMIX)
+#define SOUND_MASK_ALTPCM	(1 << SOUND_MIXER_ALTPCM)
+#define SOUND_MASK_RECLEV	(1 << SOUND_MIXER_RECLEV)
+#define SOUND_MASK_IGAIN	(1 << SOUND_MIXER_IGAIN)
+#define SOUND_MASK_OGAIN	(1 << SOUND_MIXER_OGAIN)
+#define SOUND_MASK_LINE1	(1 << SOUND_MIXER_LINE1)
+#define SOUND_MASK_LINE2	(1 << SOUND_MIXER_LINE2)
+#define SOUND_MASK_LINE3	(1 << SOUND_MIXER_LINE3)
+#define SOUND_MASK_DIGITAL1	(1 << SOUND_MIXER_DIGITAL1)
+#define SOUND_MASK_DIGITAL2	(1 << SOUND_MIXER_DIGITAL2)
+#define SOUND_MASK_DIGITAL3	(1 << SOUND_MIXER_DIGITAL3)
+#define SOUND_MASK_MONO		(1 << SOUND_MIXER_MONO)
+#define SOUND_MASK_PHONE	(1 << SOUND_MIXER_PHONE)
+#define SOUND_MASK_RADIO	(1 << SOUND_MIXER_RADIO)
+#define SOUND_MASK_VIDEO	(1 << SOUND_MIXER_VIDEO)
+#define SOUND_MASK_DEPTH	(1 << SOUND_MIXER_DEPTH)
+#define SOUND_MASK_REARVOL	(1 << SOUND_MIXER_REARVOL)
+#define SOUND_MASK_CENTERVOL	(1 << SOUND_MIXER_CENTERVOL)
+#define SOUND_MASK_SIDEVOL	(1 << SOUND_MIXER_SIDEVOL)
+
+/* Note! SOUND_MASK_SURRVOL is alias of SOUND_MASK_SIDEVOL */
+#define SOUND_MASK_SURRVOL	(1 << SOUND_MIXER_SIDEVOL)
+
+/* Obsolete macros */
+#define SOUND_MASK_MUTE		(1 << SOUND_MIXER_MUTE)
+#define SOUND_MASK_ENHANCE	(1 << SOUND_MIXER_ENHANCE)
+#define SOUND_MASK_LOUD		(1 << SOUND_MIXER_LOUD)
+
+#define MIXER_READ(dev)			__SIOR('M', dev, int)
+#define SOUND_MIXER_READ_VOLUME		MIXER_READ(SOUND_MIXER_VOLUME)
+#define SOUND_MIXER_READ_BASS		MIXER_READ(SOUND_MIXER_BASS)
+#define SOUND_MIXER_READ_TREBLE		MIXER_READ(SOUND_MIXER_TREBLE)
+#define SOUND_MIXER_READ_SYNTH		MIXER_READ(SOUND_MIXER_SYNTH)
+#define SOUND_MIXER_READ_PCM		MIXER_READ(SOUND_MIXER_PCM)
+#define SOUND_MIXER_READ_SPEAKER	MIXER_READ(SOUND_MIXER_SPEAKER)
+#define SOUND_MIXER_READ_LINE		MIXER_READ(SOUND_MIXER_LINE)
+#define SOUND_MIXER_READ_MIC		MIXER_READ(SOUND_MIXER_MIC)
+#define SOUND_MIXER_READ_CD		MIXER_READ(SOUND_MIXER_CD)
+#define SOUND_MIXER_READ_IMIX		MIXER_READ(SOUND_MIXER_IMIX)
+#define SOUND_MIXER_READ_ALTPCM		MIXER_READ(SOUND_MIXER_ALTPCM)
+#define SOUND_MIXER_READ_RECLEV		MIXER_READ(SOUND_MIXER_RECLEV)
+#define SOUND_MIXER_READ_IGAIN		MIXER_READ(SOUND_MIXER_IGAIN)
+#define SOUND_MIXER_READ_OGAIN		MIXER_READ(SOUND_MIXER_OGAIN)
+#define SOUND_MIXER_READ_LINE1		MIXER_READ(SOUND_MIXER_LINE1)
+#define SOUND_MIXER_READ_LINE2		MIXER_READ(SOUND_MIXER_LINE2)
+#define SOUND_MIXER_READ_LINE3		MIXER_READ(SOUND_MIXER_LINE3)
+
+/* Obsolete macros */
+#define SOUND_MIXER_READ_MUTE		MIXER_READ(SOUND_MIXER_MUTE)
+#define SOUND_MIXER_READ_ENHANCE	MIXER_READ(SOUND_MIXER_ENHANCE)
+#define SOUND_MIXER_READ_LOUD		MIXER_READ(SOUND_MIXER_LOUD)
+
+#define SOUND_MIXER_READ_RECSRC		MIXER_READ(SOUND_MIXER_RECSRC)
+#define SOUND_MIXER_READ_DEVMASK	MIXER_READ(SOUND_MIXER_DEVMASK)
+#define SOUND_MIXER_READ_RECMASK	MIXER_READ(SOUND_MIXER_RECMASK)
+#define SOUND_MIXER_READ_STEREODEVS	MIXER_READ(SOUND_MIXER_STEREODEVS)
+#define SOUND_MIXER_READ_CAPS		MIXER_READ(SOUND_MIXER_CAPS)
+
+#define MIXER_WRITE(dev)		__SIOWR('M', dev, int)
+#define SOUND_MIXER_WRITE_VOLUME	MIXER_WRITE(SOUND_MIXER_VOLUME)
+#define SOUND_MIXER_WRITE_BASS		MIXER_WRITE(SOUND_MIXER_BASS)
+#define SOUND_MIXER_WRITE_TREBLE	MIXER_WRITE(SOUND_MIXER_TREBLE)
+#define SOUND_MIXER_WRITE_SYNTH		MIXER_WRITE(SOUND_MIXER_SYNTH)
+#define SOUND_MIXER_WRITE_PCM		MIXER_WRITE(SOUND_MIXER_PCM)
+#define SOUND_MIXER_WRITE_SPEAKER	MIXER_WRITE(SOUND_MIXER_SPEAKER)
+#define SOUND_MIXER_WRITE_LINE		MIXER_WRITE(SOUND_MIXER_LINE)
+#define SOUND_MIXER_WRITE_MIC		MIXER_WRITE(SOUND_MIXER_MIC)
+#define SOUND_MIXER_WRITE_CD		MIXER_WRITE(SOUND_MIXER_CD)
+#define SOUND_MIXER_WRITE_IMIX		MIXER_WRITE(SOUND_MIXER_IMIX)
+#define SOUND_MIXER_WRITE_ALTPCM	MIXER_WRITE(SOUND_MIXER_ALTPCM)
+#define SOUND_MIXER_WRITE_RECLEV	MIXER_WRITE(SOUND_MIXER_RECLEV)
+#define SOUND_MIXER_WRITE_IGAIN		MIXER_WRITE(SOUND_MIXER_IGAIN)
+#define SOUND_MIXER_WRITE_OGAIN		MIXER_WRITE(SOUND_MIXER_OGAIN)
+#define SOUND_MIXER_WRITE_LINE1		MIXER_WRITE(SOUND_MIXER_LINE1)
+#define SOUND_MIXER_WRITE_LINE2		MIXER_WRITE(SOUND_MIXER_LINE2)
+#define SOUND_MIXER_WRITE_LINE3		MIXER_WRITE(SOUND_MIXER_LINE3)
+
+/* Obsolete macros */
+#define SOUND_MIXER_WRITE_MUTE		MIXER_WRITE(SOUND_MIXER_MUTE)
+#define SOUND_MIXER_WRITE_ENHANCE	MIXER_WRITE(SOUND_MIXER_ENHANCE)
+#define SOUND_MIXER_WRITE_LOUD		MIXER_WRITE(SOUND_MIXER_LOUD)
+
+#define SOUND_MIXER_WRITE_RECSRC	MIXER_WRITE(SOUND_MIXER_RECSRC)
+
+typedef struct mixer_info	/* OBSOLETE */
+{
+  char id[16];
+  char name[32];
+  int modify_counter;
+  int fillers[10];
+} mixer_info;
+
+/* SOUND_MIXER_INFO is obsolete - use SNDCTL_MIXERINFO instead */
+#define SOUND_MIXER_INFO		__SIOR ('M', 101, mixer_info)
+
+/*
+ * Two ioctls for special souncard function (OSS/Free only)
+ */
+#define SOUND_MIXER_AGC  _SIOWR('M', 103, int)
+#define SOUND_MIXER_3DSE  _SIOWR('M', 104, int)
+/*
+ * The SOUND_MIXER_PRIVATE# commands can be redefined by low level drivers.
+ * These features can be used when accessing device specific features.
+ */
+#define SOUND_MIXER_PRIVATE1		__SIOWR('M', 111, int)
+#define SOUND_MIXER_PRIVATE2		__SIOWR('M', 112, int)
+#define SOUND_MIXER_PRIVATE3		__SIOWR('M', 113, int)
+#define SOUND_MIXER_PRIVATE4		__SIOWR('M', 114, int)
+#define SOUND_MIXER_PRIVATE5		__SIOWR('M', 115, int)
+
+/* The following two controls were never implemented and they should not be used. */
+#define SOUND_MIXER_READ_MAINVOL		__SIOR ('M', 116, int)
+#define SOUND_MIXER_WRITE_MAINVOL		__SIOWR('M', 116, int)
+
+/*
+ * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used
+ * for querying current mixer settings from the driver and for loading
+ * default volume settings _prior_ activating the mixer (loading
+ * doesn't affect current state of the mixer hardware). These calls
+ * are for internal use by the driver software only.
+ */
+
+typedef struct mixer_vol_table
+{
+  int num;			/* Index to volume table */
+  char name[32];
+  int levels[32];
+} mixer_vol_table;
+
+#define SOUND_MIXER_GETLEVELS		__SIOWR('M', 116, mixer_vol_table)
+#define SOUND_MIXER_SETLEVELS		__SIOWR('M', 117, mixer_vol_table)
+
+#define OSS_GETVERSION			__SIOR ('M', 118, int)
+
+/*
+ * Calls to set/get the recording gain for the currently active
+ * recording source. These calls automatically map to the right control.
+ * Note that these calls are not supported by all drivers. In this case
+ * the call will return -1 with errno set to EINVAL
+ *
+ * The _MONGAIN work in similar way but set/get the monitoring gain for
+ * the currently selected recording source.
+ */
+#define SOUND_MIXER_READ_RECGAIN	__SIOR ('M', 119, int)
+#define SOUND_MIXER_WRITE_RECGAIN	__SIOWR('M', 119, int)
+#define SOUND_MIXER_READ_MONGAIN	__SIOR ('M', 120, int)
+#define SOUND_MIXER_WRITE_MONGAIN	__SIOWR('M', 120, int)
+
+/* The following call is for driver development time purposes. It's not
+ * present in any released drivers.
+ */
+typedef unsigned char oss_reserved_t[512];
+#define SOUND_MIXER_RESERVED		__SIOWR('M', 121, oss_reserved_t)
+#endif /* ifndef NO_LEGACY_MIXER */
+
+/*
+ *************************************************************************
+ * The "new" mixer API of OSS 4.0 and later.
+ *
+ * This improved mixer API makes it possible to access every possible feature
+ * of every possible device. However you should read the mixer programming
+ * section of the OSS API Developer's Manual. There is no chance that you
+ * could use this interface correctly just by examining this header.
+ */
+
+typedef struct oss_sysinfo
+{
+  char product[32];		/* For example OSS/Free, OSS/Linux or OSS/Solaris */
+  char version[32];		/* For example 4.0a */
+  int versionnum;		/* See OSS_GETVERSION */
+  char options[128];		/* Reserved */
+
+  int numaudios;		/* # of audio/dsp devices */
+  int openedaudio[8];		/* Bit mask telling which audio devices are busy */
+
+  int numsynths;		/* # of availavle synth devices */
+  int nummidis;			/* # of available MIDI ports */
+  int numtimers;		/* # of available timer devices */
+  int nummixers;		/* # of mixer devices */
+
+  int openedmidi[8];		/* Bit mask telling which midi devices are busy */
+  int numcards;			/* Number of sound cards in the system */
+  int numaudioengines;		/* Number of audio engines in the system */
+  char license[16];		/* For example "GPL" or "CDDL" */
+  char revision_info[256];	/* For internal use */
+  int filler[172];		/* For future expansion */
+} oss_sysinfo;
+
+typedef struct oss_mixext
+{
+  int dev;			/* Mixer device number */
+  int ctrl;			/* Controller number */
+  int type;			/* Entry type */
+#	define MIXT_DEVROOT	 0	/* Device root entry */
+#	define MIXT_GROUP	 1	/* Controller group */
+#	define MIXT_ONOFF	 2	/* OFF (0) or ON (1) */
+#	define MIXT_ENUM	 3	/* Enumerated (0 to maxvalue) */
+#	define MIXT_MONOSLIDER	 4	/* Mono slider (0 to 255) */
+#	define MIXT_STEREOSLIDER 5	/* Stereo slider (dual 0 to 255) */
+#	define MIXT_MESSAGE	 6	/* (Readable) textual message */
+#	define MIXT_MONOVU	 7	/* VU meter value (mono) */
+#	define MIXT_STEREOVU	 8	/* VU meter value (stereo) */
+#	define MIXT_MONOPEAK	 9	/* VU meter peak value (mono) */
+#	define MIXT_STEREOPEAK	10	/* VU meter peak value (stereo) */
+#	define MIXT_RADIOGROUP	11	/* Radio button group */
+#	define MIXT_MARKER	12	/* Separator between normal and extension entries */
+#	define MIXT_VALUE	13	/* Decimal value entry */
+#	define MIXT_HEXVALUE	14	/* Hexadecimal value entry */
+#	define MIXT_MONODB	15	/* OBSOLETE */
+#	define MIXT_STEREODB	16	/* OBSOLETE */
+#	define MIXT_SLIDER	17	/* Slider (mono) with full (31 bit) postitive integer range */
+#	define MIXT_3D		18
+
+/*
+ * Sliders with range expanded to 15 bits per channel (0-32767)
+ */
+#	define MIXT_MONOSLIDER16	19
+#	define MIXT_STEREOSLIDER16	20
+#	define MIXT_MUTE	21	/* Mute=1, unmute=0 */
+
+/*
+ * MIXT_ENUM_MULTI is a multi choice variant of MIXT_ENUM. Bits 0 to 30
+ * of the value field are used as a bit mask (bit 31 is reserved and must be
+ * set to 0).
+ *
+ * This MIXT_ENUM_MULTI type is reserved for Sun's Boomer. The official OSS
+ * implementation will probably not use this feature. The same functionality
+ * can be implemented by using group of MIXT_ONOFF controls.
+ */
+#	define MIXT_ENUM_MULTI	22
+
+  /**************************************************************/
+
+  /* Possible value range (minvalue to maxvalue) */
+  /* Note that maxvalue may also be smaller than minvalue */
+  int maxvalue;
+  int minvalue;
+
+  int flags;
+#	define MIXF_READABLE	0x00000001	/* Has readable value */
+#	define MIXF_WRITEABLE	0x00000002	/* Has writeable value */
+#	define MIXF_POLL	0x00000004	/* May change itself */
+#	define MIXF_HZ		0x00000008	/* Herz scale */
+#	define MIXF_STRING	0x00000010	/* Use dynamic extensions for value */
+#	define MIXF_DYNAMIC	0x00000010	/* Supports dynamic extensions */
+#	define MIXF_OKFAIL	0x00000020	/* Interpret value as 1=OK, 0=FAIL */
+#	define MIXF_FLAT	0x00000040	/* Flat vertical space requirements */
+#	define MIXF_LEGACY	0x00000080	/* Legacy mixer control group */
+#	define MIXF_CENTIBEL	0x00000100	/* Centibel (0.1 dB) step size */
+#	define MIXF_DECIBEL	0x00000200	/* Step size of 1 dB */
+#	define MIXF_MAINVOL	0x00000400	/* Main volume control */
+#	define MIXF_PCMVOL	0x00000800	/* PCM output volume control */
+#	define MIXF_RECVOL	0x00001000	/* PCM recording volume control */
+#	define MIXF_MONVOL	0x00002000	/* Input->output monitor volume */
+#	define MIXF_WIDE	0x00004000	/* Enum control has wide labels */
+#	define MIXF_DESCR	0x00008000	/* Description (tooltip) available */
+#	define MIXF_DISABLED	0x00010000	/* Control is not active at this moment (grayed out) */
+  oss_id_t id;			/* Mnemonic ID (mainly for internal use) */
+  int parent;			/* Entry# of parent (group) node (-1 if root) */
+
+  int dummy;			/* Internal use */
+
+  int timestamp;
+
+  char data[64];		/* Misc data (entry type dependent) */
+  unsigned char enum_present[32];	/* Mask of allowed enum values */
+  int control_no;		/* SOUND_MIXER_VOLUME..SOUND_MIXER_MIDI */
+  /* (-1 means not indicated) */
+
+/*
+ * The desc field is reserved for internal purposes of OSS. It should not be 
+ * used by applications.
+ */
+  unsigned int desc;
+#define MIXEXT_SCOPE_MASK			0x0000003f
+#define MIXEXT_SCOPE_OTHER			0x00000000
+#define MIXEXT_SCOPE_INPUT			0x00000001
+#define MIXEXT_SCOPE_OUTPUT			0x00000002
+#define MIXEXT_SCOPE_MONITOR			0x00000003
+#define MIXEXT_SCOPE_RECSWITCH			0x00000004
+
+  char extname[32];
+  int update_counter;
+  int rgbcolor;		/* 0 means default color (not black) . Otherwise 24 bit RGB color */
+  int filler[6];
+} oss_mixext;
+
+/*
+ * Recommended colors to be used in the rgbcolor field. These match the
+ * colors used as the audio jack colors in HD audio motherboards.
+ */
+#define OSS_RGB_BLUE	0x7aabde		/* Light blue */
+#define OSS_RGB_GREEN	0xb3c98c		/* Lime green */
+#define OSS_RGB_PINK	0xe88c99
+#define OSS_RGB_GRAY	0xd1ccc4
+#define OSS_RGB_BLACK	0x2b2926		/* Light black */
+#define OSS_RGB_ORANGE	0xe89e47
+#define OSS_RGB_RED	0xff0000
+#define OSS_RGB_YELLOW	0xffff00
+#define OSS_RGB_PURPLE	0x800080
+#define OSS_RGB_WHITE	0xf8f8ff
+
+typedef struct oss_mixext_root
+{
+  oss_id_t id;
+  char name[48];
+} oss_mixext_root;
+
+typedef struct oss_mixer_value
+{
+  int dev;
+  int ctrl;
+  int value;
+  int flags;			/* Reserved for future use. Initialize to 0 */
+  int timestamp;		/* Must be set to oss_mixext.timestamp */
+  int filler[8];		/* Reserved for future use. Initialize to 0 */
+} oss_mixer_value;
+
+#define OSS_ENUM_MAXVALUE	255
+#define OSS_ENUM_STRINGSIZE	3000
+typedef struct oss_mixer_enuminfo
+{
+  int dev;
+  int ctrl;
+  int nvalues;
+  int version;			/* Read the manual */
+  short strindex[OSS_ENUM_MAXVALUE];
+  char strings[OSS_ENUM_STRINGSIZE];
+} oss_mixer_enuminfo;
+
+#define OSS_OPEN_READ	PCM_ENABLE_INPUT
+#define OSS_OPEN_WRITE	PCM_ENABLE_OUTPUT
+#define OSS_OPEN_READWRITE	(OSS_OPEN_READ|OSS_OPEN_WRITE)
+
+/*
+ * Older names for the above (to be removed in the future since they
+ * may pollute the name space)
+ */
+#define OPEN_READ	OSS_OPEN_READ
+#define OPEN_WRITE	OSS_OPEN_WRITE
+#define OPEN_READWRITE	OSS_OPEN_READWRITE
+
+typedef struct oss_audioinfo
+{
+  int dev;			/* Audio device number */
+  oss_devname_t name;
+  int busy;			/* 0, OPEN_READ, OPEN_WRITE or OPEN_READWRITE */
+  int pid;
+  int caps;			/* PCM_CAP_INPUT, PCM_CAP_OUTPUT */
+  int iformats, oformats;
+  int magic;			/* Reserved for internal use */
+  oss_cmd_t cmd;		/* Command using the device (if known) */
+  int card_number;
+  int port_number;
+  int mixer_dev;
+  int legacy_device;		/* Obsolete field. Replaced by devnode */
+  int enabled;			/* 1=enabled, 0=device not ready at this moment */
+  int flags;			/* For internal use only - no practical meaning */
+  int min_rate, max_rate;	/* Sample rate limits */
+  int min_channels, max_channels;	/* Number of channels supported */
+  int binding;			/* DSP_BIND_FRONT, etc. 0 means undefined */
+  int rate_source;
+  oss_handle_t handle;
+#define OSS_MAX_SAMPLE_RATES	20	/* Cannot be changed  */
+  unsigned int nrates, rates[OSS_MAX_SAMPLE_RATES];	/* Please read the manual before using these */
+  oss_longname_t song_name;	/* Song name (if given) */
+  oss_label_t label;		/* Device label (if given) */
+  int latency;			/* In usecs, -1=unknown */
+  oss_devnode_t devnode;	/* Device special file name (absolute path) */
+  int next_play_engine;		/* Read the documentation for more info */
+  int next_rec_engine;		/* Read the documentation for more info */
+  int filler[184];
+} oss_audioinfo;
+
+typedef struct oss_mixerinfo
+{
+  int dev;
+  oss_id_t id;
+  char name[32];		/* oss_devname_t is better, but may break compat */
+  int modify_counter;
+  int card_number;
+  int port_number;
+  oss_handle_t handle;
+  int magic;			/* Reserved */
+  int enabled;
+  int caps;
+#define MIXER_CAP_VIRTUAL	0x00000001
+#define MIXER_CAP_LAYOUT_B	0x00000002	/* For internal use only */
+#define MIXER_CAP_NARROW	0x00000004	/* Conserve horiz space */
+  int flags;			/* Reserved */
+  int nrext;
+  /*
+   * The priority field can be used to select the default (motherboard)
+   * mixer device. The mixer with the highest priority is the
+   * most preferred one. -2 or less means that this device cannot be used
+   * as the default mixer.
+   */
+  int priority;
+  oss_devnode_t devnode;	/* Device special file name (absolute path) */
+  int legacy_device;
+  int filler[245];		/* Reserved */
+} oss_mixerinfo;
+
+typedef struct oss_midi_info
+{
+  int dev;			/* Midi device number */
+  oss_devname_t name;
+  int busy;			/* 0, OPEN_READ, OPEN_WRITE or OPEN_READWRITE */
+  int pid;
+  oss_cmd_t cmd;		/* Command using the device (if known) */
+  int caps;
+#define MIDI_CAP_MPU401		0x00000001	/**** OBSOLETE ****/
+#define MIDI_CAP_INPUT		0x00000002
+#define MIDI_CAP_OUTPUT		0x00000004
+#define MIDI_CAP_INOUT		(MIDI_CAP_INPUT|MIDI_CAP_OUTPUT)
+#define MIDI_CAP_VIRTUAL	0x00000008	/* Pseudo device */
+#define MIDI_CAP_MTCINPUT	0x00000010	/* Supports SNDCTL_MIDI_MTCINPUT */
+#define MIDI_CAP_CLIENT		0x00000020	/* Virtual client side device */
+#define MIDI_CAP_SERVER		0x00000040	/* Virtual server side device */
+#define MIDI_CAP_INTERNAL	0x00000080	/* Internal (synth) device */
+#define MIDI_CAP_EXTERNAL	0x00000100	/* external (MIDI port) device */
+#define MIDI_CAP_PTOP		0x00000200	/* Point to point link to one device */
+#define MIDI_CAP_MTC		0x00000400	/* MTC/SMPTE (control) device */
+  int magic;			/* Reserved for internal use */
+  int card_number;
+  int port_number;
+  int enabled;			/* 1=enabled, 0=device not ready at this moment */
+  int flags;			/* For internal use only - no practical meaning */
+  oss_handle_t handle;
+  oss_longname_t song_name;	/* Song name (if known) */
+  oss_label_t label;		/* Device label (if given) */
+  int latency;			/* In usecs, -1=unknown */
+  oss_devnode_t devnode;	/* Device special file name (absolute path) */
+  int legacy_device;		/* Legacy device mapping */
+  int filler[235];
+} oss_midi_info;
+
+typedef struct oss_card_info
+{
+  int card;
+  char shortname[16];
+  char longname[128];
+  int flags;
+  char hw_info[400];
+  int intr_count, ack_count;
+  int filler[154];
+} oss_card_info;
+
+#define SNDCTL_SYSINFO		__SIOR ('X', 1, oss_sysinfo)
+#define OSS_SYSINFO		SNDCTL_SYSINFO	/* Old name */
+
+#define SNDCTL_MIX_NRMIX	__SIOR ('X', 2, int)
+#define SNDCTL_MIX_NREXT	__SIOWR('X', 3, int)
+#define SNDCTL_MIX_EXTINFO	__SIOWR('X', 4, oss_mixext)
+#define SNDCTL_MIX_READ		__SIOWR('X', 5, oss_mixer_value)
+#define SNDCTL_MIX_WRITE	__SIOWR('X', 6, oss_mixer_value)
+
+#define SNDCTL_AUDIOINFO	__SIOWR('X', 7, oss_audioinfo)
+#define SNDCTL_MIX_ENUMINFO	__SIOWR('X', 8, oss_mixer_enuminfo)
+#define SNDCTL_MIDIINFO		__SIOWR('X', 9, oss_midi_info)
+#define SNDCTL_MIXERINFO	__SIOWR('X',10, oss_mixerinfo)
+#define SNDCTL_CARDINFO		__SIOWR('X',11, oss_card_info)
+#define SNDCTL_ENGINEINFO	__SIOWR('X',12, oss_audioinfo)
+#define SNDCTL_AUDIOINFO_EX	__SIOWR('X',13, oss_audioinfo)
+
+#define SNDCTL_MIX_DESCRIPTION	__SIOWR('X',14, oss_mixer_enuminfo)
+
+/*
+ * SNDCTL_MIX_MATRIX_WRITE and SNDCTL_MIX_MATRIX_READ are private ioctl
+ * calls that each driver can define in whatever way they like. They can
+ * be used _ONLY_ by device specific utilities. Each driver can define
+ * meaning of the fields of oss_mixermatrix_t as they like. This means
+ * that applications using this interface will depend on the specific device.
+ *
+ * This interface can be used for example to implement a (GUI) tool that can 
+ * set the signal routings of an on-board mixer matrix of some high end
+ * audio card. The application (designer) must have complete understanding
+ * of the device to be supported. The application will not be portable to any
+ * other device.
+ *
+ * Applications using this interface must verify that the magic field
+ * returned by SNDCTL_MIXERINFO matches the right device/driver.
+ */
+typedef struct
+{
+	int secret;	/* Initialize this to driver spcified secret value */
+	int source, target;
+	int function;
+	int value;
+	int options[16];
+} oss_mixermatrix_t;
+
+#define SNDCTL_MIX_MATRIX_WRITE	__SIOWR('X',15, oss_mixermatrix_t)
+#define SNDCTL_MIX_MATRIX_READ	__SIOWR('X',16, oss_mixermatrix_t)
+
+/* ioctl codes 'X', 200-255 are reserved for internal use */
+
+/*
+ * Few more "globally" available ioctl calls.
+ */
+#define SNDCTL_SETSONG		__SIOW ('Y', 2, oss_longname_t)
+#define SNDCTL_GETSONG		__SIOR ('Y', 2, oss_longname_t)
+#define SNDCTL_SETNAME		__SIOW ('Y', 3, oss_longname_t)
+#define SNDCTL_SETLABEL		__SIOW ('Y', 4, oss_label_t)
+#define SNDCTL_GETLABEL		__SIOR ('Y', 4, oss_label_t)
+/*
+ * The "new" mixer API definitions end here.
+ ***************************************
+ */
+
+/*
+ *********************************************************
+ * Few routines that are included in -lOSSlib
+ *
+ * At this moment this interface is not used. OSSlib contains just
+ * stubs that call the related system calls directly.
+ */
+#ifdef OSSLIB
+extern int osslib_open (const char *path, int flags, int dummy);
+extern void osslib_close (int fd);
+extern int osslib_write (int fd, const void *buf, int count);
+extern int osslib_read (int fd, void *buf, int count);
+extern int osslib_ioctl (int fd, unsigned int request, void *arg);
+#else
+#  define osslib_open	open
+#  define osslib_close	close
+#  define osslib_write	write
+#  define osslib_read	read
+#  define osslib_ioctl	ioctl
+#endif
+
+#if 1
+#define SNDCTL_DSP_NONBLOCK		__SIO  ('P',14)	/* Obsolete. Not supported any more */
+#endif
+
+#if 1
+/*
+ * Some obsolete macros that are not part of Open Sound System API.
+ */
+#define SOUND_PCM_READ_RATE             SOUND_PCM_READ_RATE_is_obsolete
+#define SOUND_PCM_READ_BITS             SOUND_PCM_READ_BITS_is_obsolete
+#define SOUND_PCM_READ_CHANNELS         SOUND_PCM_READ_CHANNELS_is_obsolete
+#define SOUND_PCM_WRITE_RATE            SOUND_PCM_WRITE_RATE_is_obsolet_use_SNDCTL_DSP_SPEED_instead
+#define SOUND_PCM_WRITE_CHANNELS        SOUND_PCM_WRITE_CHANNELS_is_obsolete_use_SNDCTL_DSP_CHANNELS_instead
+#define SOUND_PCM_WRITE_BITS            SOUND_PCM_WRITE_BITS_is_obsolete_use_SNDCTL_DSP_SETFMT_instead
+#define SOUND_PCM_POST                  SOUND_PCM_POST_is_obsolete_use_SNDCTL_DSP_POST_instead
+#define SOUND_PCM_RESET                 SOUND_PCM_RESET_is_obsolete_use_SNDCTL_DSP_HALT_instead
+#define SOUND_PCM_SYNC                  SOUND_PCM_SYNC_is_obsolete_use_SNDCTL_DSP_SYNC_instead
+#define SOUND_PCM_SUBDIVIDE             SOUND_PCM_SUBDIVIDE_is_obsolete_use_SNDCTL_DSP_SUBDIVIDE_instead
+#define SOUND_PCM_SETFRAGMENT           SOUND_PCM_SETFRAGMENT_is_obsolete_use_SNDCTL_DSP_SETFRAGMENT_instead
+#define SOUND_PCM_GETFMTS               SOUND_PCM_GETFMTS_is_obsolete_use_SNDCTL_DSP_GETFMTS_instead
+#define SOUND_PCM_SETFMT                SOUND_PCM_SETFMT_is_obsolete_use_SNDCTL_DSP_SETFMT_instead
+#define SOUND_PCM_GETOSPACE             SOUND_PCM_GETOSPACE_is_obsolete_use_SNDCTL_DSP_GETOSPACE_instead
+#define SOUND_PCM_GETISPACE             SOUND_PCM_GETISPACE_is_obsolete_use_SNDCTL_DSP_GETISPACE_instead
+#define SOUND_PCM_NONBLOCK              SOUND_PCM_NONBLOCK_is_obsolete_use_SNDCTL_DSP_NONBLOCK_instead
+#define SOUND_PCM_GETCAPS               SOUND_PCM_GETCAPS_is_obsolete_use_SNDCTL_DSP_GETCAPS_instead
+#define SOUND_PCM_GETTRIGGER            SOUND_PCM_GETTRIGGER_is_obsolete_use_SNDCTL_DSP_GETTRIGGER_instead
+#define SOUND_PCM_SETTRIGGER            SOUND_PCM_SETTRIGGER_is_obsolete_use_SNDCTL_DSP_SETTRIGGER_instead
+#define SOUND_PCM_SETSYNCRO             SOUND_PCM_SETSYNCRO_is_obsolete_use_SNDCTL_DSP_SETSYNCRO_instead
+#define SOUND_PCM_GETIPTR               SOUND_PCM_GETIPTR_is_obsolete_use_SNDCTL_DSP_GETIPTR_instead
+#define SOUND_PCM_GETOPTR               SOUND_PCM_GETOPTR_is_obsolete_use_SNDCTL_DSP_GETOPTR_instead
+#define SOUND_PCM_MAPINBUF              SOUND_PCM_MAPINBUF_is_obsolete_use_SNDCTL_DSP_MAPINBUF_instead
+#define SOUND_PCM_MAPOUTBUF             SOUND_PCM_MAPOUTBUF_is_obsolete_use_SNDCTL_DSP_MAPOUTBUF_instead
+#endif
+
+#endif
diff -Nura v4l2rtspserver_imp_tools/inc/TSServerMediaSubsession.h v4l2rtspserver-master/inc/TSServerMediaSubsession.h
--- v4l2rtspserver_imp_tools/inc/TSServerMediaSubsession.h	2019-02-01 20:08:29.562626000 +0100
+++ v4l2rtspserver-master/inc/TSServerMediaSubsession.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* ---------------------------------------------------------------------------
-** This software is in the public domain, furnished "as is", without technical
-** support, and with no warranty, express or implied, as to its usefulness for
-** any purpose.
-**
-** TSServerMediaSubsession.h
-** 
-** -------------------------------------------------------------------------*/
-
-#pragma once
-
-#include <map>
-#include "UnicastServerMediaSubsession.h"
-#include "MemoryBufferSink.h"
-
-// -----------------------------------------
-//    ServerMediaSubsession for HLS
-// -----------------------------------------
-class TSServerMediaSubsession : public UnicastServerMediaSubsession
-{
-	public:
-		static TSServerMediaSubsession* createNew(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration)
-		{
-			return new TSServerMediaSubsession(env, replicator, format, sliceDuration);
-		}
-		
-	protected:
-		TSServerMediaSubsession(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration); 
-		virtual ~TSServerMediaSubsession();
-			
-		virtual float         getCurrentNPT(void* streamToken);
-		virtual float         duration() const ;
-		virtual void          seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes);
-		virtual FramedSource* getStreamSource(void* streamToken);
-					
-	protected:
-		unsigned int      m_slice;
-		MemoryBufferSink* m_hlsSink;
-};
-
-
diff -Nura v4l2rtspserver_imp_tools/mips.toolchain v4l2rtspserver-master/mips.toolchain
--- v4l2rtspserver_imp_tools/mips.toolchain	2019-02-01 20:08:29.563626000 +0100
+++ v4l2rtspserver-master/mips.toolchain	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-SET(CMAKE_SYSTEM_NAME Linux)
-SET(CMAKE_SYSTEM_PROCESSOR mips)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE ${CMAKE_SYSTEM_PROCESSOR})
-SET(CMAKE_C_COMPILER mips-linux-gnu-gcc)
-SET(CMAKE_CXX_COMPILER mips-linux-gnu-g++)
-
-set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
-set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
diff -Nura v4l2rtspserver_imp_tools/nanopi.toolchain v4l2rtspserver-master/nanopi.toolchain
--- v4l2rtspserver_imp_tools/nanopi.toolchain	2019-02-01 20:08:29.563626000 +0100
+++ v4l2rtspserver-master/nanopi.toolchain	2019-02-03 20:24:23.648172000 +0100
@@ -4,6 +4,8 @@
 SET(CMAKE_C_COMPILER arm-linux-gcc)
 SET(CMAKE_CXX_COMPILER arm-linux-g++)
 
+execute_process(COMMAND ${CMAKE_C_COMPILER} -print-sysroot OUTPUT_VARIABLE CMAKE_FIND_ROOT_PATH OUTPUT_STRIP_TRAILING_WHITESPACE)
+
 set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
 set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
 set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
diff -Nura v4l2rtspserver_imp_tools/raspberry.toolchain v4l2rtspserver-master/raspberry.toolchain
--- v4l2rtspserver_imp_tools/raspberry.toolchain	2019-02-01 20:08:29.563626000 +0100
+++ v4l2rtspserver-master/raspberry.toolchain	2019-02-03 20:24:23.648172000 +0100
@@ -1,9 +1,8 @@
 SET(CMAKE_SYSTEM_NAME Linux)
-SET(CMAKE_SYSTEM_PROCESSOR armv7l)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE armhf)
+SET(CMAKE_SYSTEM_PROCESSOR armhf)
+set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE ${CMAKE_SYSTEM_PROCESSOR})
 SET(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
 SET(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)
-
+SET(CMAKE_FIND_ROOT_PATH ${PROJECT_SOURCE_DIR}/rootfs)
 SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
-set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
-set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+include_directories(SYSTEM ${PROJECT_SOURCE_DIR}/rootfs/usr/include/arm-linux-gnueabihf)
diff -Nura v4l2rtspserver_imp_tools/README.md v4l2rtspserver-master/README.md
--- v4l2rtspserver_imp_tools/README.md	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/README.md	2019-02-03 20:24:23.640172000 +0100
@@ -1,13 +1,11 @@
-[![TravisCI](https://travis-ci.org/mpromonet/v4l2rtspserver.png)](https://travis-ci.org/mpromonet/v4l2rtspserver)
-[![CircleCI](https://circleci.com/gh/mpromonet/v4l2rtspserver.svg?style=shield)](https://circleci.com/gh/mpromonet/v4l2rtspserver)
-
 [![Codacy Badge](https://api.codacy.com/project/badge/Grade/aa0c28514aa843ea9fa7da358d905871)](https://www.codacy.com/app/michelpromonet_2643/v4l2rtspserver?utm_source=github.com&utm_medium=referral&utm_content=mpromonet/v4l2rtspserver&utm_campaign=badger)
+[![Build status](https://travis-ci.org/mpromonet/v4l2rtspserver.png)](https://travis-ci.org/mpromonet/v4l2rtspserver)
 [![Coverity Scan Build Status](https://scan.coverity.com/projects/4644/badge.svg)](https://scan.coverity.com/projects/4644)
 [![Coverage Status](https://coveralls.io/repos/github/mpromonet/v4l2rtspserver/badge.svg?branch=master)](https://coveralls.io/github/mpromonet/v4l2rtspserver?branch=master)
 
 [![Release](https://img.shields.io/github/release/mpromonet/v4l2rtspserver.svg)](https://github.com/mpromonet/v4l2rtspserver/releases/latest)
 [![Download](https://img.shields.io/github/downloads/mpromonet/v4l2rtspserver/total.svg)](https://github.com/mpromonet/v4l2rtspserver/releases/latest)
-[![Docker Pulls](https://img.shields.io/docker/pulls/mpromonet/v4l2rtspserver.svg)](https://hub.docker.com/r/mpromonet/v4l2rtspserver/)
+
 
 v4l2rtspserver
 ====================
@@ -22,7 +20,7 @@
 - RTP/TCP
 - RTP/RTSP/HTTP
 
-The HTTP server support (available using -S option for capture format that could be muxed in Transport Stream):
+The HTTP server support :
 - HLS
 - MPEG-DASH
 
@@ -53,6 +51,7 @@
 		 -M addr  : multicast group:port (default is random_address:20000)
 		 -c       : don't repeat config (default repeat config before IDR frame)
 		 -t secs  : RTCP expiration timeout (default 65)
+		 -T       : send Transport Stream instead of elementary Stream
 		 -S[secs] : HTTP segment duration (enable HLS & MPEG-DASH)
 		 
 		 V4L2 options :
@@ -68,7 +67,7 @@
 		 ALSA options :
 		 -A freq    : ALSA capture frequency and channel (default 44100)
 		 -C channels: ALSA capture channels (default 2)
-		 -a fmt     : ALSA capture audio format (default S16_LE)
+		 -a fmt     : ALSA capture audio format (default S16_BE)
 		 
 		 device   : V4L2 capture device and/or ALSA device (default /dev/video0)
 
@@ -90,11 +89,19 @@
 
 Build
 ------- 
+- Before build (optional)
+	The build try to install live555 package using apt-get, however in order to install live555 disabling check of port reuse, you can proceed like this:
+
+		wget http://www.live555.com/liveMedia/public/live555-latest.tar.gz -O - | tar xvzf -
+		cd live
+		./genMakefiles linux
+		sudo make CPPFLAGS=-DALLOW_RTSP_SERVER_PORT_REUSE=1 install
+
 - Build  
 
 		cmake . && make
 
-	If live555 is not installed it will download it from live555.com and compile it. If asound is not installed, ALSA will be disabled.  
+	If it fails you will need to install liblivemedia-dev liblog4cpp5-dev.  
 	If it still not work you will need to read Makefile.  
 
 - Install (optional) 
@@ -146,23 +153,3 @@
  * using Chrome installing [Native HLS playback](https://chrome.google.com/webstore/detail/native-hls-playback/emnphkkblegpebimobpbekeedfgemhof)
 
 There is also a small HTML page that use hls.js and dash.js, but dash still not work because player doesnot support MP2T format.
-
-Using Docker image
-===============
-You can start the application using the docker image :
-
-        docker run -p 8554:8554 -it mpromonet/v4l2rtspserver
-
-You can expose V4L2 devices from your host using :
-
-        docker run --device=/dev/video0 -p 8554:8554 -it mpromonet/v4l2rtspserver
-
-The container entry point is the v4l2rtspserver application, then you can :
-
-* get the help using :
-
-        docker run -it mpromonet/v4l2rtspserver -h
-
-* run the container specifying some paramters :
-
-        docker run --device=/dev/video0 -p 8554:8554 -it mpromonet/v4l2rtspserver -u "" -H640 -H480 
diff -Nura v4l2rtspserver_imp_tools/src/ALSACapture.cpp v4l2rtspserver-master/src/ALSACapture.cpp
--- v4l2rtspserver_imp_tools/src/ALSACapture.cpp	2019-02-01 20:08:29.564626000 +0100
+++ v4l2rtspserver-master/src/ALSACapture.cpp	2019-02-03 20:24:23.648172000 +0100
@@ -11,168 +11,831 @@
 **                                                                                    
 ** -------------------------------------------------------------------------*/
 
-#ifdef HAVE_ALSA
-
 #include "ALSACapture.h"
+#include "soundcard.h"
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <loguru.hpp>
+
+/**
+ * lame_error_callback, lame_message_callback, lame_debug_callback: LAME
+ * logging callback functions.
+ *
+ * [Parameters]
+ *     format: Format string.
+ *     args: Format arguments.
+ */
+static void lame_error_callback(const char *format, va_list args)
+{
+
+    LOG_F(ERROR,format, args);
+}
+
+static void lame_message_callback(const char *format, va_list args)
+{
+    LOG_F(INFO,format, args);
+}
+
+
+extern "C" {
+#include <wave.h>
+#include <noise_remover.h>
+#include "filt.h"
+}
+/* Tested configuration
++--------------+---------------+--------------+--------------+--------------+--------------+
+|      Audio   |    inSample   |   outSample  |    Filter    |   S/W Vol    |   H/W Vol    |
++--------------+---------------+--------------+--------------+--------------+--------------+
+|      MP3     |    8000       |     8000     |     1,2      |    yes       |    yes       |
+|              |    8000       |     44100    |     1,2      |    yes       |    yes       |
+|              |    44100      |     44100    |     1,2      |    yes       |    yes       |
++--------------+---------------+--------------+--------------+--------------+--------------+
+|      OPUS    |    8000       |     48000    |     1,2      |    yes       |    yes       |
+|              |    48000      |     48000    |     1,2      |    yes       |    yes       |
++--------------+---------------+--------------+--------------+--------------+--------------+
+|      PCM     |    8000       |      8000    |     1,2      |    yes       |    yes       |
++--------------+---------------+--------------+--------------+--------------+--------------+
+|      PCMU    |    8000       |      8000    |     1,2      |    yes       |    yes       |
++--------------+---------------+--------------+--------------+--------------+--------------+
+*/
+
+
+// ------------------------------------------------------
+// IMP Audio
+#include <imp/imp_audio.h>
+
+void ALSACapture::initAudioIMP(const ALSACaptureParameters & params)
+{
+	int devID = 1;
+	IMPAudioIOAttr attr;
+
+	attr.samplerate = (IMPAudioSampleRate) params.m_inSampleRate;
+	attr.bitwidth = AUDIO_BIT_WIDTH_16;
+	attr.soundmode = AUDIO_SOUND_MODE_MONO;
+	attr.frmNum = 50;
+	attr.numPerFrm = getBufferSize()/10;
+
+	attr.chnCnt = 1;
+	int ret = IMP_AI_SetPubAttr(devID, &attr);
+	if(ret != 0) {
+		LOG_F(ERROR,"set ai %d attr err: %d", devID, ret);
+		exit(0);
+		return ;
+	}
+
+	memset(&attr, 0x0, sizeof(attr));
+	ret = IMP_AI_GetPubAttr(devID, &attr);
+	if(ret != 0) {
+		LOG_F(ERROR, "get ai %d attr err: %d", devID, ret);
+		return ;
+	}
+
+	LOG_F(INFO, "Audio In GetPubAttr samplerate : %d", attr.samplerate);
+	LOG_F(INFO, "Audio In GetPubAttr   bitwidth : %d", attr.bitwidth);
+	LOG_F(INFO, "Audio In GetPubAttr  soundmode : %d", attr.soundmode);
+	LOG_F(INFO, "Audio In GetPubAttr     frmNum : %d", attr.frmNum);
+	LOG_F(INFO, "Audio In GetPubAttr  numPerFrm : %d", attr.numPerFrm);
+	LOG_F(INFO, "Audio In GetPubAttr     chnCnt : %d", attr.chnCnt);
+
+
+	/* Step 2: enable AI device. */
+	ret = IMP_AI_Enable(devID);
+	if(ret != 0) {
+		LOG_F(ERROR, "enable ai %d err", devID);
+		return ;
+	}
+
+	/* Step 3: set audio channel attribute of AI device. */
+	int chnID = 0;
+	IMPAudioIChnParam chnParam = {0};
+	chnParam.usrFrmDepth = 50;
+	ret = IMP_AI_SetChnParam(devID, chnID, &chnParam);
+	if(ret != 0) {
+		LOG_F(ERROR, "set ai %d channel %d attr err: %d", devID, chnID, ret);
+		return ;
+	}
+
+	memset(&chnParam, 0x0, sizeof(chnParam));
+	ret = IMP_AI_GetChnParam(devID, chnID, &chnParam);
+	if(ret != 0) {
+		LOG_F(ERROR, "get ai %d channel %d attr err: %d", devID, chnID, ret);
+		//return ;
+	}
+
+	LOG_F(INFO, "Audio In GetChnParam usrFrmDepth : %d", chnParam.usrFrmDepth);
+
+	/* Step 4: enable AI channel. */
+	ret = IMP_AI_EnableChn(devID, chnID);
+	if(ret != 0) {
+		LOG_F(ERROR, "Audio Record enable channel failed");
+		return ;
+	}
+
+    int chnVol = 70;
+    if (m_newConfig->hardVolume != -1)
+    {
+        chnVol = m_newConfig->hardVolume;
+        m_currentConfig.hardVolume = m_newConfig->hardVolume;
+    }
+
+	/* Step 5: Set audio channel volume. */
+	ret = IMP_AI_SetVol(devID, chnID, chnVol);
+	if(ret != 0) {
+		LOG_F(ERROR, "Audio Record set volume failed");
+	}
+
+	ret = IMP_AI_GetVol(devID, chnID, &chnVol);
+	if(ret != 0) {
+		LOG_F(ERROR, "Audio Record get volume failed");
+		//return ;
+	}
+    LOG_F(INFO,"Audio In GetVol    vol : %d", chnVol);
+
+
+   UpdateIMPFilter();
+}
+
+void ALSACapture::initAudio(const ALSACaptureParameters & params)
+{
+    LOG_F(INFO, "Open ALSA device: %s", params.m_devName.c_str() );
+
 
+    if ((fd = ::open(params.m_devName.c_str(), O_RDONLY, 0)) == -1)
+    {
+        LOG_F(ERROR,"cannot open audio device: %s", params.m_devName.c_str());
+    }
+
+    int format= AFMT_S16_LE;
+    if (::ioctl(fd, SNDCTL_DSP_SETFMT, &format)==-1)
+    { // Fatal error
+         LOG_F(ERROR,"Cant set format...%s", params.m_devName.c_str());
+    }
+
+    int stereo = params.m_channels-1;
+    LOG_F(INFO,"Channel Count: %d", params.m_channels);
+    if (::ioctl(fd, SNDCTL_DSP_STEREO, &stereo)==-1)
+    { // Fatal error
+       LOG_F(ERROR,"Cant set Mono/Stereo ...%s", params.m_devName.c_str());
+    }
+
+    int speed =  params.m_inSampleRate;
+
+    if (ioctl(fd, SNDCTL_DSP_SPEED, &speed)==-1)
+    { // Fatal error
+         LOG_F(ERROR, "Cant set Speed ...%s",params.m_devName.c_str());
+    }
+
+    if (m_newConfig->hardVolume != -1)
+    {
+        if (ioctl(fd, SNDCTL_EXT_SET_RECORD_VOLUME, &m_newConfig->hardVolume)==-1)
+        { // Fatal error
+            LOG_F(ERROR, "Cant set vol %d", m_newConfig->hardVolume);
+        }
+        m_currentConfig.hardVolume = m_newConfig->hardVolume;
+    }
+}
 
 ALSACapture* ALSACapture::createNew(const ALSACaptureParameters & params) 
 { 
-	ALSACapture* capture = new ALSACapture(params);
-	if (capture) 
-	{
-		if (capture->getFd() == -1) 
-		{
-			delete capture;
-			capture = NULL;
-		}
-	}
-	return capture; 
+    ALSACapture* capture = new ALSACapture(params);
+    if (capture)
+    {
+        if (capture->getFd() == -1)
+        {
+            delete capture;
+            capture = NULL;
+        }
+    }
+    return capture;
 }
 
 ALSACapture::~ALSACapture()
 {
-	this->close();
+    this->close();
 }
 
 void ALSACapture::close()
 {
-	if (m_pcm != NULL)
+
+}
+
+ALSACapture::ALSACapture(const ALSACaptureParameters & params) : m_bufferSize(0), m_periodSize(0), m_params(params)
+{
+    m_sharedMem = SharedMem::instance();
+    m_sharedMem.readConfig();
+    m_newConfig = m_sharedMem.getConfig();
+
+    memcpy(&m_currentConfig, m_newConfig, sizeof(shared_conf));
+
+    m_audioSource = params.m_source;
+
+    if (m_audioSource == SOURCE_IMP)
+    {
+        initAudioIMP(params);
+    } else {
+        initAudio(params);
+    }
+
+    switch (params.m_encode)
+    {
+    case ENCODE_OPUS:
+    {
+#define APPLICATION OPUS_APPLICATION_VOIP
+       int err =0;
+        /*Create a new encoder state */
+       encoder = opus_encoder_create(params.m_inSampleRate, params.m_channels, APPLICATION, &err);
+       if (err<0)
+       {
+          LOG_F(ERROR, "failed to create an encoder: %s", opus_strerror(err));
+       }
+
+       /* Set the desired bit-rate. You can also set other parameters if needed.
+          The Opus library is designed to have good defaults, so only set
+          parameters you know you need. Doing otherwise is likely to result
+          in worse quality, but better. */
+
+       opus_encoder_ctl(encoder, OPUS_SET_BITRATE(params.m_outSampleRate));
+       opus_encoder_ctl(encoder, OPUS_SET_COMPLEXITY(0));
+       break;
+      }
+    case ENCODE_MP3:
+    {
+       // Lame Init:
+        gfp = lame_init();
+        lame_set_errorf(gfp, lame_error_callback);
+        lame_set_msgf  (gfp, lame_message_callback);
+        //lame_set_debugf(lame, lame_debug_callback);
+        lame_set_num_channels(gfp,params.m_channels );
+        //lame_set_mode(gfp, 3);
+        lame_set_in_samplerate(gfp, params.m_inSampleRate);
+        lame_set_out_samplerate(gfp, params.m_outSampleRate);
+      //  lame_set_scale(gfp, 3.0);
+        int ret_code = lame_init_params(gfp);
+        if (ret_code < 0)
+        { /* Fatal error */
+         LOG_F(ERROR,"Cant init Lame");
+        }
+        //lame_print_config(gfp);
+        break;
+    }
+    case ENCODE_PCM:
+    default:
+        break;
+    }
+
+}
+
+void ALSACapture::setSwVolume(short &val, int vol)
+{
+ val += (short) (val * (vol / 100.0));
+}
+
+
+#define _SWAP(val) (val << 8) | ((val >> 8) & 0xFF);
+inline signed short lowpass(signed short input, bool swap)
+{
+   static signed short last_sample=0;
+   signed short retvalue=(input + (last_sample * 7)) >> 3;
+   last_sample=retvalue;
+   if (swap)
+    return _SWAP(retvalue);
+   return retvalue;
+}
+
+inline short ALSACapture::filter(short val,bool swap, int num_sample)
+{
+    if (m_Filtermethod == 1)
+    {
+         static struct noise_remover_s nrm;
+         static bool isInit = false;
+         if (isInit == false) {
+            noise_remover_init( &nrm );
+            isInit = true;
+         }
+
+        short y;
+        /* process audio */
+        val = ASHIFT16(val,-2);
+
+        y = noise_remover ( &nrm, val, 1 );  /* training=1 */
+
+        if( y>8192 ) // 8192 = ASHIFT16( 32768, -2 )
+            y = 32767;
+        else if( y<-8192 )
+            y = -32768;
+        else
+            y = ASHIFT16(y,+2);
+
+        return lowpass(y, swap);
+    }
+
+    if (m_Filtermethod == 2)
+    {
+        return lowpass(val, swap);
+    }
+
+    if (swap == true)
+        return _SWAP(val);
+    return val;
+}
+
+void ALSACapture::udpateHWVolume(unsigned int newVol)
+{
+    if (m_audioSource == SOURCE_IMP)
+    {
+        int devID = 1;
+        int chnID = 0;
+        int ret;
+        ret = IMP_AI_SetVol(devID, chnID, newVol);
+        if(ret != 0) {
+            LOG_F(ERROR, "Audio Record set volume failed");
+        }
+    } else {
+     if (ioctl(fd, SNDCTL_EXT_SET_RECORD_VOLUME, &newVol)==-1)
+        { // Fatal error
+            LOG_F(ERROR, "Cant set vol %d", newVol);
+        }
+    }
+    LOG_F(INFO, "Set H/Wvol %d", newVol);
+}
+
+void ALSACapture::UpdateIMPFilter()
+{
+    int ret;
+	IMPAudioIOAttr attr;
+	int devID = 1;
+    int chnID = 0;
+
+    ret = IMP_AI_GetPubAttr(devID, &attr);
+	if(ret != 0) {
+		LOG_F(ERROR, "get ai %d attr err: %d", devID, ret);
+	}
+    if ( m_newConfig->highfilter == true)
+    {
+	    ret = IMP_AI_EnableHpf(&attr);
+	    if(ret != 0) {
+	    	LOG_F(ERROR, "Enable audio hpf error.");
+	    }
+	    LOG_F(INFO, "Enabled highfilter");
+    }
+    else
+    {
+        ret = IMP_AI_DisableHpf();
+        if(ret != 0) {
+            LOG_F(ERROR, "Disable audio hpf error.");
+        }
+        LOG_F(INFO, "Disabled highfilter");
+    }
+
+    if ( m_newConfig->aecfilter == true)
+    {
+        if (m_params.m_inSampleRate <= 16000)
+        {
+            // Enable Aec
+            ret = IMP_AI_EnableAec(devID, chnID, 0, 0);
+            if(ret != 0) {
+                LOG_F(ERROR, "Audio enable aec failed");
+            }
+            LOG_F(INFO, "Enabled aec");
+        }
+        else
+        {
+         LOG_F(ERROR, "Can't enable aec for bitrate > 16000");
+        }
+    }
+    else
+    {
+        ret = IMP_AI_DisableAec(devID, chnID);
+        if(ret != 0) {
+            LOG_F(ERROR, "Disable aec failed");
+        }
+        LOG_F(INFO, "Disabled aec");
+    }
+
+	// This filter start at 3
+	if (m_newConfig->filter >= 3)
 	{
-		snd_pcm_close (m_pcm);
-		m_pcm = NULL;
-	}
+	    if (m_params.m_inSampleRate <= 16000)
+        {
+            ret = IMP_AI_EnableNs(&attr, m_newConfig->filter-3); //NS_VERYHIGH);
+            if(ret != 0) {
+                LOG_F(ERROR, "enable audio ns error.");
+            }
+            LOG_F(INFO, "NS Filter=%d", m_newConfig->filter-3);
+        }
+        else
+        {
+            LOG_F(ERROR, "Can't enable this filter for bitrate > 16000");
+        }
+    }
+    else
+    {
+        // This API crashes, so set to the minimum
+        ret = IMP_AI_EnableNs(&attr, NS_LOW); //NS_VERYHIGH);
+        //ret = IMP_AI_DisableNs();
+        if(ret != 0) {
+            LOG_F(ERROR, "disable audio ns error.");
+        }
+        LOG_F(INFO, "NS Filter disabled");
+    }
+
+}
+
+size_t ALSACapture::read(char* buffer, size_t bufferSize)
+{
+    m_sharedMem.readConfig();
+    if (m_currentConfig.hardVolume != m_newConfig->hardVolume) {
+        udpateHWVolume( m_newConfig->hardVolume);
+        m_currentConfig.hardVolume = m_newConfig->hardVolume;
+    }
+    if (m_audioSource == SOURCE_IMP)
+    {
+        if (m_Filtermethod != m_newConfig->filter
+           || m_HighFiltermethod != m_newConfig->highfilter
+           || m_AECFiltermethod != m_newConfig->aecfilter)
+        {
+           UpdateIMPFilter();
+        }
+    }
+    m_Filtermethod = m_newConfig->filter;
+    m_HighFiltermethod = m_newConfig->highfilter;
+    m_AECFiltermethod = m_newConfig->aecfilter;
+    switch (m_params.m_encode)
+    {
+        case ENCODE_OPUS:
+            if (m_audioSource == SOURCE_IMP)
+                return readOpusIMP(buffer, bufferSize, m_newConfig->softVolume);
+
+            return readOpus(buffer, bufferSize, m_newConfig->softVolume);
+            break;
+        case ENCODE_MP3:
+            if (m_audioSource == SOURCE_IMP)
+                return readMP3IMP(buffer, bufferSize, m_newConfig->softVolume);
+            return readMP3(buffer, bufferSize, m_newConfig->softVolume);
+            break;
+        case ENCODE_PCM:
+            if (m_audioSource == SOURCE_IMP)
+                return readPCMIMP(buffer, bufferSize, m_newConfig->softVolume);
+
+            return readPCM(buffer, bufferSize, m_newConfig->softVolume);
+            break;
+        case ENCODE_ULAW:
+            if (m_audioSource == SOURCE_IMP)
+                return readULAWIMP(buffer, bufferSize, m_newConfig->softVolume);
+
+            return readULAW(buffer, bufferSize, m_newConfig->softVolume);
+            break;
+
+    }
+    return 0;
+}
+
+unsigned long ALSACapture::getBufferSize()
+{
+  switch (m_params.m_encode)
+    {
+        case ENCODE_OPUS:
+            if (m_audioSource == SOURCE_IMP)
+                return (m_params.m_inSampleRate*2 /50)*3*10;
+            return (m_params.m_inSampleRate*2 /50)*6;
+            break;
+        case ENCODE_MP3:
+            return m_params.m_inSampleRate * sizeof(short) * 1;
+            break;
+        case ENCODE_PCM:
+            return (m_params.m_inSampleRate*0.02)*sizeof(short)*10 *2;
+            break;
+        case ENCODE_ULAW:
+            return (m_params.m_inSampleRate*0.02)*sizeof(short)*10;
+            break;
+    }
+    return 1;
+}
+
+size_t ALSACapture::readULAW(char* buffer, size_t bufferSize, int volume)
+{
+    int num_samples = bufferSize / sizeof(short);
+    short localBuffer[ num_samples ];
+    // Read 10 packets of 20ms
+    int bytesRead = ::read (fd, &localBuffer, bufferSize); //(m_params.m_inSampleRate*0.02)*sizeof(short)*10);
+    num_samples = bytesRead / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)localBuffer)[i], volume);
+        buffer[i] = ulaw_encode(filter(((signed short*)localBuffer)[i], false, num_samples));
+    }
+
+    return num_samples;
+}
+
+size_t ALSACapture::readPCM(char* buffer, size_t bufferSize, int volume)
+{
+    int num_samples = bufferSize / sizeof(short);
+    short localBuffer[ num_samples ];
+    // Read 10 packets of 20ms
+    int bytesRead = ::read (fd, &localBuffer, bufferSize); //(m_params.m_inSampleRate*0.02)*sizeof(short)*10);
+    num_samples = bytesRead / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)localBuffer)[i], volume);
+        ((signed short*)buffer)[i] = filter(((signed short*)localBuffer)[i], true, num_samples);
+    }
+
+    return num_samples*2;
+}
+
+size_t ALSACapture::readOpus(char* buffer, size_t bufferSize, int volume)
+{
+    int num_samples = bufferSize / sizeof(short);
+    short localBuffer[ num_samples ];
+    int bytesRead = ::read (fd, &localBuffer,bufferSize); //(m_params.m_inSampleRate*2 /50)*6);
+    num_samples = bytesRead / sizeof(short);
+
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)localBuffer)[i], volume);
+        ((signed short*)localBuffer)[i] = filter(((signed short*)localBuffer)[i], false, num_samples);
+    }
+
+
+     /* Encode the frame. */
+     bytesRead = opus_encode(encoder, localBuffer, num_samples, (unsigned char*)buffer, bufferSize);
+
+      if (bytesRead<0)
+      {
+            LOG_F(ERROR, "Error converting to OPUS %d",bytesRead);
+            //LOG(ERROR) << "Buffersize " << bufferSize;
+            bytesRead = 1;
+      }
+
+    return bytesRead;
 }
-	
-ALSACapture::ALSACapture(const ALSACaptureParameters & params) : m_pcm(NULL), m_bufferSize(0), m_periodSize(0), m_params(params)
+
+size_t ALSACapture::readMP3(char* buffer, size_t bufferSize, int volume)
 {
-	LOG(NOTICE) << "Open ALSA device: \"" << params.m_devName << "\"";
-	
-	snd_pcm_hw_params_t *hw_params = NULL;
-	int err = 0;
-	
-	// open PCM device
-	if ((err = snd_pcm_open (&m_pcm, m_params.m_devName.c_str(), SND_PCM_STREAM_CAPTURE, 0)) < 0) {
-		LOG(ERROR) << "cannot open audio device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-	}
-				
-	// configure hw_params
-	else if ((err = snd_pcm_hw_params_malloc (&hw_params)) < 0) {
-		LOG(ERROR) << "cannot allocate hardware parameter structure device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	else if ((err = snd_pcm_hw_params_any (m_pcm, hw_params)) < 0) {
-		LOG(ERROR) << "cannot initialize hardware parameter structure device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}			
-	else if ((err = snd_pcm_hw_params_set_access (m_pcm, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED)) < 0) {
-		LOG(ERROR) << "cannot set access type device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	else if (this->configureFormat(hw_params) < 0) {
-		this->close();
-	}
-	else if ((err = snd_pcm_hw_params_set_rate_near (m_pcm, hw_params, &m_params.m_sampleRate, 0)) < 0) {
-		LOG(ERROR) << "cannot set sample rate device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	else if ((err = snd_pcm_hw_params_set_channels (m_pcm, hw_params, m_params.m_channels)) < 0) {
-		LOG(ERROR) << "cannot set channel count device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	else if ((err = snd_pcm_hw_params (m_pcm, hw_params)) < 0) {
-		LOG(ERROR) << "cannot set parameters device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	
-	// get buffer size
-	else if ((err = snd_pcm_get_params(m_pcm, &m_bufferSize, &m_periodSize)) < 0) {
-		LOG(ERROR) << "cannot get parameters device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}
-	
-	// start capture
-	else if ((err = snd_pcm_prepare (m_pcm)) < 0) {
-		LOG(ERROR) << "cannot prepare audio interface for use device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}			
-	else if ((err = snd_pcm_start (m_pcm)) < 0) {
-		LOG(ERROR) << "cannot start audio interface for use device: " << m_params.m_devName << " error:" <<  snd_strerror (err);
-		this->close();
-	}			
-	
-	LOG(NOTICE) << "ALSA device: \"" << m_params.m_devName << "\" buffer_size:" << m_bufferSize << " period_size:" << m_periodSize << " rate:" << m_params.m_sampleRate;
-}
-			
-int ALSACapture::configureFormat(snd_pcm_hw_params_t *hw_params) {
-	
-	// try to set format, widht, height
-	std::list<snd_pcm_format_t>::iterator it;
-	for (it = m_params.m_formatList.begin(); it != m_params.m_formatList.end(); ++it) {
-		snd_pcm_format_t format = *it;
-		int err = snd_pcm_hw_params_set_format (m_pcm, hw_params, format);
-		if (err < 0) {
-			LOG(NOTICE) << "cannot set sample format device: " << m_params.m_devName << " to:" << format << " error:" <<  snd_strerror (err);
-		} else {
-			LOG(NOTICE) << "set sample format device: " << m_params.m_devName << " to:" << format << " ok";
-			m_fmt = format;
-			return 0;
-		}		
+    int num_samples = bufferSize / sizeof(short);
+    short localBuffer[ num_samples ];
+    int mp3buf_size = 1.25*num_samples + 7200;
+
+    int bytesRead = ::read (fd, &localBuffer, bufferSize); //m_params.m_inSampleRate * sizeof(short) * 1); //8192*2);
+    num_samples = bytesRead / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)localBuffer)[i], volume);
+        ((signed short*)localBuffer)[i] = filter(((signed short*)localBuffer)[i], false, num_samples);
+    }
+
+    bytesRead = lame_encode_buffer( gfp, localBuffer, NULL,  num_samples,(unsigned char*)buffer,mp3buf_size);
+    //LOG(ERROR) << "Bytes Converted to MP3:" << bytesRead;
+    if(bytesRead == 0){
+         LOG_F(ERROR,"Error converting to MP3");
+        //LOG(ERROR) << "Buffersize " << bufferSize;
+        bytesRead = 1;
+    }
+    return bytesRead;
+
+}
+
+
+
+size_t ALSACapture::readPCMIMP(char* buffer, size_t bufferSize, int volume)
+{
+    int num_samples = bufferSize / sizeof(short);
+
+    int devID = 1;
+    int chnID = 0;
+
+    int ret = IMP_AI_PollingFrame(devID, chnID, 10000);
+	if (ret != 0 ) {
+			LOG_F(ERROR, "Audio Polling Frame Data error");
+	}
+	IMPAudioFrame frm;
+	ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);
+	if(ret != 0) {
+			LOG_F(ERROR, "Audio Get Frame Data error");
+			return 1;
+	}
+	num_samples = frm.len / sizeof(short);
+
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)frm.virAddr)[i], volume);
+        ((signed short*)buffer)[i] = filter(((signed short*)frm.virAddr)[i], true, num_samples);
+    }
+
+
+	ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);
+	if(ret != 0) {
+		LOG_F(ERROR,  "Audio release frame data error");
+		return 1;
 	}
-	return -1;
+
+    return num_samples*2;
+
 }
 
-size_t ALSACapture::read(char* buffer, size_t bufferSize)
+
+size_t ALSACapture::readULAWIMP(char* buffer, size_t bufferSize, int volume)
 {
-	size_t size = 0;
-	int fmt_phys_width_bytes = 0;
-	if (m_pcm != 0)
-	{
-		int fmt_phys_width_bits = snd_pcm_format_physical_width(m_fmt);
-		fmt_phys_width_bytes = fmt_phys_width_bits / 8;
+    int num_samples = bufferSize / sizeof(short);
 
-		snd_pcm_sframes_t ret = snd_pcm_readi (m_pcm, buffer, m_periodSize*fmt_phys_width_bytes);
-		LOG(DEBUG) << "ALSA buffer in_size:" << m_periodSize*fmt_phys_width_bytes << " read_size:" << ret;
-		if (ret > 0) {
-			size = ret;				
-			
-			// swap if capture in not in network order
-			if (!snd_pcm_format_big_endian(m_fmt)) {
-				for(unsigned int i = 0; i < size; i++){
-					char * ptr = &buffer[i * fmt_phys_width_bytes * m_params.m_channels];
-					
-					for(unsigned int j = 0; j < m_params.m_channels; j++){
-						ptr += j * fmt_phys_width_bytes;
-						for (int k = 0; k < fmt_phys_width_bytes/2; k++) {
-							char byte = ptr[k];
-							ptr[k] = ptr[fmt_phys_width_bytes - 1 - k];
-							ptr[fmt_phys_width_bytes - 1 - k] = byte; 
-						}
-					}
-				}
-			}
-		}
+    int devID = 1;
+    int chnID = 0;
+
+    int ret = IMP_AI_PollingFrame(devID, chnID, 1000);
+	if (ret != 0 ) {
+			LOG_F(ERROR, "Audio Polling Frame Data error");
+	}
+	IMPAudioFrame frm;
+	ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);
+	if(ret != 0) {
+			LOG_F(ERROR, "Audio Get Frame Data error");
+			return 1;
+	}
+	num_samples = frm.len / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)frm.virAddr)[i], volume);
+        buffer[i] = ulaw_encode(filter(((signed short*)frm.virAddr)[i], false, num_samples));
+    }
+
+	ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);
+	if(ret != 0) {
+		LOG_F(ERROR,  "Audio release frame data error");
+		return 1;
 	}
-	return size * m_params.m_channels * fmt_phys_width_bytes;
+
+    return num_samples;
 }
-		
+
+
+
+size_t ALSACapture::readOpusIMP(char* buffer, size_t bufferSize, int volume)
+{
+   int num_samples = 0;
+   int devID = 1;
+   int chnID = 0;
+
+   int ret = IMP_AI_PollingFrame(devID, chnID, 1000);
+   if (ret != 0 ) {
+        LOG_F(ERROR, "Audio Polling Frame Data error");
+   }
+   IMPAudioFrame frm;
+   ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);
+   if(ret != 0) {
+    LOG_F(ERROR, "Audio Get Frame Data error");
+    return 1;
+   }
+   num_samples = frm.len / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)frm.virAddr)[i], volume);
+        ((signed short*)frm.virAddr)[i] = filter(((signed short*)frm.virAddr)[i], false, num_samples);
+    }
+
+    /* Encode the frame. */
+    int bytesRead = opus_encode(encoder, (short*)frm.virAddr, num_samples, (unsigned char*)buffer, bufferSize);
+
+    ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);
+	if(ret != 0) {
+		LOG_F(ERROR,  "Audio release frame data error");
+		return 1;
+	}
+    if (bytesRead<0)
+    {
+        LOG_F(ERROR, "Error converting to OPUS %d",bytesRead);
+        //LOG(ERROR) << "Buffersize " << bufferSize;
+        bytesRead = 1;
+    }
+
+    return bytesRead;
+}
+
+size_t ALSACapture::readMP3IMP(char* buffer, size_t bufferSize, int volume)
+{
+    int num_samples = 0;
+    int mp3buf_size = 1.25*num_samples + 7200;
+    int devID = 1;
+    int chnID = 0;
+    int ret = IMP_AI_PollingFrame(devID, chnID, 2000);
+    if (ret != 0 ) {
+        LOG_F(ERROR, "Audio Polling Frame Data error");
+    }
+    IMPAudioFrame frm;
+    ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);
+    if(ret != 0) {
+        LOG_F(ERROR, "Audio Get Frame Data error");
+        return 1;
+    }
+    num_samples = frm.len / sizeof(short);
+
+    for (int i =0; i<  num_samples ; i++)
+    {
+        if (volume != -1) setSwVolume(((signed short*)frm.virAddr)[i], volume);
+        ((signed short*)frm.virAddr)[i] = filter(((signed short*)frm.virAddr)[i], false, num_samples);
+    }
+
+    int bytesRead = lame_encode_buffer( gfp, (short*)frm.virAddr, NULL,  num_samples,(unsigned char*)buffer,mp3buf_size);
+    //LOG(ERROR) << "Bytes Converted to MP3:" << bytesRead;
+    if(bytesRead == 0){
+         LOG_F(ERROR,"Error converting to MP3");
+        //LOG(ERROR) << "Buffersize " << bufferSize;
+        bytesRead = 1;
+    }
+    ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);
+    if(ret != 0) {
+    	LOG_F(ERROR,  "Audio release frame data error");
+    	return 1;
+    }
+    return bytesRead;
+
+}
+
 int ALSACapture::getFd()
 {
-	unsigned int nbfs = 1;
-	struct pollfd pfds[nbfs]; 
-	pfds[0].fd = -1;
-	
-	if (m_pcm != 0)
-	{
-		int count = snd_pcm_poll_descriptors_count (m_pcm);
-		int err = snd_pcm_poll_descriptors(m_pcm, pfds, count);
-		if (err < 0) {
-			fprintf (stderr, "cannot snd_pcm_poll_descriptors (%s)\n", snd_strerror (err));
-		}
-	}
-	return pfds[0].fd;
+    return fd;
 }
-		
-#endif
 
+/*=================================================================================
+**	The following routines came from the sox-12.15 (Sound eXcahcnge) distribution.
+**
+**	This code is not compiled into libsndfile. It is only used to test the
+**	libsndfile lookup tables for correctness.
+**
+**	I have included the original authors comments.
+*/
+
+/*
+** This routine converts from linear to ulaw.
+**
+** Craig Reese: IDA/Supercomputing Research Center
+** Joe Campbell: Department of Defense
+** 29 September 1989
+**
+** References:
+** 1) CCITT Recommendation G.711  (very difficult to follow)
+** 2) "A New Digital Technique for Implementation of Any
+**     Continuous PCM Companding Law," Villeret, Michel,
+**     et al. 1973 IEEE Int. Conf. on Communications, Vol 1,
+**     1973, pg. 11.12-11.17
+** 3) MIL-STD-188-113,"Interoperability and Performance Standards
+**     for Analog-to_Digital Conversion Techniques,"
+**     17 February 1987
+**
+** Input: Signed 16 bit linear sample
+** Output: 8 bit ulaw sample
+*/
+
+#define uBIAS 0x84		/* define the add-in bias for 16 bit.frames */
+
+#define uCLIP 32635
+
+unsigned char ALSACapture::ulaw_encode (short sample)
+{	static int exp_lut [256] =
+	{	0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+		4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
+		5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+		5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
+		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
+		} ;
+
+	int sign, exponent, mantissa ;
+	unsigned char ulawbyte ;
+
+	/* Get the sample into sign-magnitude. */
+	sign = (sample >> 8) & 0x80 ;					/* set aside the sign */
+	if (sign != 0)
+		sample = -sample ;							/* get magnitude */
+	if (sample > uCLIP)
+		sample = uCLIP ;							/* clip the magnitude */
+
+	/* Convert from 16 bit linear to ulaw. */
+	sample = sample + uBIAS ;
+	exponent = exp_lut [(sample >> 7) & 0xFF] ;
+	mantissa = (sample >> (exponent + 3)) & 0x0F ;
+	ulawbyte = ~ (sign | (exponent << 4) | mantissa) ;
+
+	return ulawbyte ;
+} /* ulaw_encode */
 
diff -Nura v4l2rtspserver_imp_tools/src/ConfigReader.cpp v4l2rtspserver-master/src/ConfigReader.cpp
--- v4l2rtspserver_imp_tools/src/ConfigReader.cpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/src/ConfigReader.cpp	2019-02-03 20:24:23.648172000 +0100
@@ -0,0 +1,69 @@
+#include "ConfigReader.h"
+
+
+
+void ConfigReader::readConfig() {
+
+    // Ini file to override some path when /system/sdcard won't exit
+
+    char dirNameBuffer[1024 + 1] = {0};
+    // Read the symbolic link '/proc/self/exe'.
+    const char *linkName = "/proc/self/exe";
+    readlink(linkName, dirNameBuffer, sizeof(dirNameBuffer) - 1);
+
+    // Read the same exe file + ini
+    strncat(dirNameBuffer, ".ini", sizeof(dirNameBuffer) - 1);
+    LOG_S(INFO) <<  "Reading Config:" << dirNameBuffer;
+    reader = new INIReader(dirNameBuffer);
+    if (reader->ParseError() < 0) {
+        LOG_S(ERROR) << "Cant read Config";
+        exit(-1);
+    }
+}
+
+char* ConfigReader::getSensorName() {
+    return strdup(reader->Get("Hardware", "SensorName", "").c_str());
+}
+int ConfigReader::getSensorAddr(){
+    return reader->GetInteger("Hardware", "SensorAddr", 0);
+}
+
+int ConfigReader::getWidth(){
+    return reader->GetInteger("Video", "Width", 0);
+}
+
+int ConfigReader::getHeight(){
+    return reader->GetInteger("Video", "Height", 0);
+}
+
+int ConfigReader::getFps(){
+    return reader->GetInteger("Video", "Fps", 0);
+}
+int ConfigReader::getBitrate(){
+    return reader->GetInteger("Video", "Bitrate", 0);
+}
+
+
+bool ConfigReader::getAudioEnabled(){
+    return reader->GetBoolean("Audio","Enabled",false);
+}
+
+
+int ConfigReader::getEncoderMode(){
+    return reader->GetInteger("Video","EncoderMode",1);
+}
+
+
+
+int ConfigReader::getRtspPort(){
+    return reader->GetInteger("RTSP","Port",1);
+}
+
+char* ConfigReader::getRtspUrl(){
+    return strdup(reader->Get("RTSP", "Url", "").c_str());
+}
+
+
+int ConfigReader::getRtspMode(){
+    return reader->GetInteger("RTSP","Mode",1);
+}
diff -Nura v4l2rtspserver_imp_tools/src/DeviceSource.cpp v4l2rtspserver-master/src/DeviceSource.cpp
--- v4l2rtspserver_imp_tools/src/DeviceSource.cpp	2019-02-01 20:08:29.565626000 +0100
+++ v4l2rtspserver-master/src/DeviceSource.cpp	2019-02-03 20:24:23.649172000 +0100
@@ -14,262 +14,236 @@
 #include <sstream>
 
 // project
-#include "logger.h"
-#include "DeviceSource.h"
 
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
+
+#include "DeviceSource.h"
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
 // ---------------------------------
 // V4L2 FramedSource Stats
 // ---------------------------------
-int  V4L2DeviceSource::Stats::notify(int tv_sec, int framesize)
-{
-	m_fps++;
-	m_size+=framesize;
-	if (tv_sec != m_fps_sec)
-	{
-		LOG(INFO) << m_msg  << "tv_sec:" <<   tv_sec << " fps:" << m_fps << " bandwidth:"<< (m_size/128) << "kbps";		
-		m_fps_sec = tv_sec;
-		m_fps = 0;
-		m_size = 0;
-	}
-	return m_fps;
+int V4L2DeviceSource::Stats::notify(int tv_sec, int framesize) {
+    m_fps++;
+    m_size += framesize;
+    if (tv_sec != m_fps_sec) {
+        LOG_S(9) << m_msg << "tv_sec:" << tv_sec << " fps:" << m_fps << " bandwidth:" << (m_size / 128) << "kbps";
+        m_fps_sec = tv_sec;
+        m_fps = 0;
+        m_size = 0;
+    }
+    return m_fps;
 }
 
 // ---------------------------------
 // V4L2 FramedSource
 // ---------------------------------
-V4L2DeviceSource* V4L2DeviceSource::createNew(UsageEnvironment& env, DeviceInterface * device, int outputFd, unsigned int queueSize, bool useThread) 
-{ 	
-	V4L2DeviceSource* source = NULL;
-	if (device)
-	{
-		source = new V4L2DeviceSource(env, device, outputFd, queueSize, useThread);
-	}
-	return source;
+V4L2DeviceSource *
+V4L2DeviceSource::createNew(UsageEnvironment &env, DeviceInterface *device, int outputFd, unsigned int queueSize,
+                            bool useThread) {
+    V4L2DeviceSource *source = NULL;
+    if (device) {
+        source = new V4L2DeviceSource(env, device, outputFd, queueSize, useThread);
+    }
+    return source;
 }
 
 // Constructor
-V4L2DeviceSource::V4L2DeviceSource(UsageEnvironment& env, DeviceInterface * device, int outputFd, unsigned int queueSize, bool useThread) 
-	: FramedSource(env), 
-	m_in("in"), 
-	m_out("out") , 
-	m_outfd(outputFd),
-	m_device(device),
-	m_queueSize(queueSize)
-{
-	m_eventTriggerId = envir().taskScheduler().createEventTrigger(V4L2DeviceSource::deliverFrameStub);
-	memset(&m_thid, 0, sizeof(m_thid));
-	memset(&m_mutex, 0, sizeof(m_mutex));
-	if (m_device)
-	{
-		if (useThread)
-		{
-			pthread_mutex_init(&m_mutex, NULL);
-			pthread_create(&m_thid, NULL, threadStub, this);		
-		}
-		else
-		{
-			envir().taskScheduler().turnOnBackgroundReadHandling( m_device->getFd(), V4L2DeviceSource::incomingPacketHandlerStub, this);
-		}
-	}
+V4L2DeviceSource::V4L2DeviceSource(UsageEnvironment &env, DeviceInterface *device, int outputFd, unsigned int queueSize,
+                                   bool useThread)
+        : FramedSource(env),
+          m_in("in"),
+          m_out("out"),
+          m_outfd(outputFd),
+          m_device(device),
+          m_queueSize(queueSize) {
+    m_eventTriggerId = envir().taskScheduler().createEventTrigger(V4L2DeviceSource::deliverFrameStub);
+    memset(&m_thid, 0, sizeof(m_thid));
+    memset(&m_mutex, 0, sizeof(m_mutex));
+    if (m_device) {
+        if (useThread) {
+            pthread_mutex_init(&m_mutex, NULL);
+            pthread_create(&m_thid, NULL, threadStub, this);
+        } else {
+            envir().taskScheduler().turnOnBackgroundReadHandling(m_device->getFd(),
+                                                                 V4L2DeviceSource::incomingPacketHandlerStub, this);
+        }
+    }
 }
 
 // Destructor
-V4L2DeviceSource::~V4L2DeviceSource()
-{	
-	envir().taskScheduler().deleteEventTrigger(m_eventTriggerId);
-	pthread_join(m_thid, NULL);	
-	pthread_mutex_destroy(&m_mutex);
-	delete m_device;
+V4L2DeviceSource::~V4L2DeviceSource() {
+    envir().taskScheduler().deleteEventTrigger(m_eventTriggerId);
+    pthread_join(m_thid, NULL);
+    pthread_mutex_destroy(&m_mutex);
+    delete m_device;
 }
 
 // thread mainloop
-void* V4L2DeviceSource::thread()
-{
-	int stop=0;
-	fd_set fdset;
-	FD_ZERO(&fdset);
-	timeval tv;
-	
-	LOG(NOTICE) << "begin thread"; 
-	while (!stop) 
-	{
-		int fd = m_device->getFd();
-		FD_SET(fd, &fdset);
-		tv.tv_sec=1;
-		tv.tv_usec=0;	
-		int ret = select(fd+1, &fdset, NULL, NULL, &tv);
-		if (ret == 1)
-		{
-			if (FD_ISSET(fd, &fdset))
-			{
-				if (this->getNextFrame() <= 0)
-				{
-					LOG(ERROR) << "error:" << strerror(errno); 						
-					stop=1;
-				}
-			}
-		}
-		else if (ret == -1)
-		{
-			LOG(ERROR) << "stop " << strerror(errno); 
-			stop=1;
-		}
-	}
-	LOG(NOTICE) << "end thread"; 
-	return NULL;
+void *V4L2DeviceSource::thread() {
+    int stop = 0;
+    fd_set fdset;
+    FD_ZERO(&fdset);
+
+    loguru::set_thread_name("DeviceSource");
+    LOG_S(INFO) << "begin thread";
+    while (!stop) {
+        if (this->getNextFrame() <= 0) {
+            LOG_S(ERROR) << "error:" << strerror(errno);
+            stop = 1;
+        }
+
+    }
+    LOG_S(INFO) << "end thread";
+    return NULL;
 }
 
 // getting FrameSource callback
-void V4L2DeviceSource::doGetNextFrame()
-{
-	deliverFrame();
+void V4L2DeviceSource::doGetNextFrame() {
+    deliverFrame();
 }
 
 // stopping FrameSource callback
-void V4L2DeviceSource::doStopGettingFrames()
-{
-	LOG(NOTICE) << "V4L2DeviceSource::doStopGettingFrames";	
-	FramedSource::doStopGettingFrames();
+void V4L2DeviceSource::doStopGettingFrames() {
+    LOG_S(INFO) << "V4L2DeviceSource::doStopGettingFrames";
+    FramedSource::doStopGettingFrames();
 }
 
 // deliver frame to the sink
-void V4L2DeviceSource::deliverFrame()
-{			
-	if (isCurrentlyAwaitingData()) 
-	{
-		fDurationInMicroseconds = 0;
-		fFrameSize = 0;
-		
-		pthread_mutex_lock (&m_mutex);
-		if (m_captureQueue.empty())
-		{
-			LOG(DEBUG) << "Queue is empty";		
-		}
-		else
-		{				
-			timeval curTime;
-			gettimeofday(&curTime, NULL);			
-			Frame * frame = m_captureQueue.front();
-			m_captureQueue.pop_front();
-	
-			m_out.notify(curTime.tv_sec, frame->m_size);
-			if (frame->m_size > fMaxSize) 
-			{
-				fFrameSize = fMaxSize;
-				fNumTruncatedBytes = frame->m_size - fMaxSize;
-			} 
-			else 
-			{
-				fFrameSize = frame->m_size;
-			}
-			timeval diff;
-			timersub(&curTime,&(frame->m_timestamp),&diff);
-
-			LOG(DEBUG) << "deliverFrame\ttimestamp:" << curTime.tv_sec << "." << curTime.tv_usec << "\tsize:" << fFrameSize <<"\tdiff:" <<  (diff.tv_sec*1000+diff.tv_usec/1000) << "ms\tqueue:" << m_captureQueue.size();		
-			
-			fPresentationTime = frame->m_timestamp;
-			memcpy(fTo, frame->m_buffer, fFrameSize);
-			delete frame;
-		}
-		pthread_mutex_unlock (&m_mutex);
-		
-		if (fFrameSize > 0)
-		{
-			// send Frame to the consumer
-			FramedSource::afterGetting(this);			
-		}
-	}
+void V4L2DeviceSource::deliverFrame() {
+    if (isCurrentlyAwaitingData()) {
+        fDurationInMicroseconds = 0;
+        fFrameSize = 0;
+
+        pthread_mutex_lock(&m_mutex);
+        if (m_captureQueue.empty()) {
+            //LOG_S(INFO) << "Queue is empty";
+        } else {
+            timeval curTime;
+            gettimeofday(&curTime, NULL);
+            Frame *frame = m_captureQueue.front();
+            m_captureQueue.pop_front();
+
+            m_out.notify(curTime.tv_sec, frame->m_size);
+            if (frame->m_size > (int)fMaxSize) {
+                fFrameSize = fMaxSize;
+                fNumTruncatedBytes = frame->m_size - fMaxSize;
+            } else {
+                fFrameSize = frame->m_size;
+            }
+            timeval diff;
+            timersub(&curTime, &(frame->m_timestamp), &diff);
+
+            LOG_S(9) << "deliverFrame\ttimestamp:" << curTime.tv_sec << "." << curTime.tv_usec << "\tsize:"
+                       << fFrameSize << "\tdiff:" << (diff.tv_sec * 1000 + diff.tv_usec / 1000) << "ms\tqueue:"
+                       << m_captureQueue.size();
+
+            fPresentationTime = frame->m_timestamp;
+            memcpy(fTo, frame->m_buffer, fFrameSize);
+            delete frame;
+        }
+        pthread_mutex_unlock(&m_mutex);
+
+        if (fFrameSize > 0) {
+            // send Frame to the consumer
+            FramedSource::afterGetting(this);
+        }
+    }
 }
-	
+
 // FrameSource callback on read event
-void V4L2DeviceSource::incomingPacketHandler()
-{
-	if (this->getNextFrame() <= 0)
-	{
-		handleClosure(this);
-	}
+void V4L2DeviceSource::incomingPacketHandler() {
+    if (this->getNextFrame() <= 0) {
+        handleClosure(this);
+    }
 }
 
 // read from device
-int V4L2DeviceSource::getNextFrame() 
-{
-	timeval ref;
-	gettimeofday(&ref, NULL);											
-	char buffer[m_device->getBufferSize()];	
-	int frameSize = m_device->read(buffer,  m_device->getBufferSize());	
-	if (frameSize < 0)
-	{
-		LOG(NOTICE) << "V4L2DeviceSource::getNextFrame errno:" << errno << " "  << strerror(errno);		
-	}
-	else if (frameSize == 0)
-	{
-		LOG(NOTICE) << "V4L2DeviceSource::getNextFrame no data errno:" << errno << " "  << strerror(errno);		
-	}
-	else
-	{
-		timeval tv;
-		gettimeofday(&tv, NULL);												
-		timeval diff;
-		timersub(&tv,&ref,&diff);
-		m_in.notify(tv.tv_sec, frameSize);
-		LOG(DEBUG) << "getNextFrame\ttimestamp:" << ref.tv_sec << "." << ref.tv_usec << "\tsize:" << frameSize <<"\tdiff:" <<  (diff.tv_sec*1000+diff.tv_usec/1000) << "ms";
-		processFrame(buffer,frameSize,ref);
-		if (m_outfd != -1) 
-		{
-			write(m_outfd, buffer, frameSize);
-		}		
-	}			
-	return frameSize;
-}	
-
-		
-void V4L2DeviceSource::processFrame(char * frame, int frameSize, const timeval &ref) 
-{
-	timeval tv;
-	gettimeofday(&tv, NULL);												
-	timeval diff;
-	timersub(&tv,&ref,&diff);
-		
-	std::list< std::pair<unsigned char*,size_t> > frameList = this->splitFrames((unsigned char*)frame, frameSize);
-	while (!frameList.empty())
-	{
-		std::pair<unsigned char*,size_t>& frame = frameList.front();
-		size_t size = frame.second;
-		char* buf = new char[size];
-		memcpy(buf, frame.first, size);
-		queueFrame(buf,size,ref);
-
-		LOG(DEBUG) << "queueFrame\ttimestamp:" << ref.tv_sec << "." << ref.tv_usec << "\tsize:" << size <<"\tdiff:" <<  (diff.tv_sec*1000+diff.tv_usec/1000) << "ms";		
-		frameList.pop_front();
-	}			
-}	
+int V4L2DeviceSource::getNextFrame() {
+    timeval ref;
+    gettimeofday(&ref, NULL);
+    char buffer[m_device->getBufferSize()];
+    int frameSize = m_device->read(buffer, m_device->getBufferSize());
+    if (frameSize < 0) {
+        LOG_S(9) << "V4L2DeviceSource::getNextFrame errno:" << errno << " " << strerror(errno);
+    } else if (frameSize == 0) {
+        LOG_S(9) << "V4L2DeviceSource::getNextFrame no data errno:" << errno << " " << strerror(errno);
+    } else {
+        timeval tv;
+        gettimeofday(&tv, NULL);
+        timeval diff;
+        timersub(&tv, &ref, &diff);
+        m_in.notify(tv.tv_sec, frameSize);
+        LOG_S(9) << "getNextFrame\ttimestamp:" << ref.tv_sec << "." << ref.tv_usec << "\tsize:" << frameSize
+                   << "\tdiff:" << (diff.tv_sec * 1000 + diff.tv_usec / 1000) << "ms";
+        processFrame(buffer, frameSize, ref);
+        switch(m_outfd){
+            case -1:
+
+            break;
+            case -2:
+                key_t key1;
+                key1 = ftok("/usr/include", 'x');
+                int shm_id;
+                shm_id = shmget( key1, m_device->getBufferSize(), IPC_CREAT);
+                void* shared_mem;
+                shared_mem = shmat( shm_id, NULL, 0);
+                memcpy(shared_mem,buffer,frameSize);
+                shmdt(shared_mem);
+            break;
+            default:
+                fwrite (buffer , 1, frameSize, (FILE*)m_outfd);
+            break;
+        }
+    }
+    return frameSize;
+}
+
+
+void V4L2DeviceSource::processFrame(char *frame, int frameSize, const timeval &ref) {
+    timeval tv;
+    gettimeofday(&tv, NULL);
+    timeval diff;
+    timersub(&tv, &ref, &diff);
+
+    std::list <std::pair<unsigned char *, size_t>> frameList = this->splitFrames((unsigned char *) frame, frameSize);
+    while (!frameList.empty()) {
+        std::pair<unsigned char *, size_t> &frame = frameList.front();
+        size_t size = frame.second;
+        char *buf = new char[size];
+        memcpy(buf, frame.first, size);
+        queueFrame(buf, size, ref);
+
+        LOG_S(9) << "queueFrame\ttimestamp:" << ref.tv_sec << "." << ref.tv_usec << "\tsize:" << size << "\tdiff:"
+                   << (diff.tv_sec * 1000 + diff.tv_usec / 1000) << "ms";
+        frameList.pop_front();
+    }
+}
 
 // post a frame to fifo
-void V4L2DeviceSource::queueFrame(char * frame, int frameSize, const timeval &tv) 
-{
-	pthread_mutex_lock (&m_mutex);
-	while (m_captureQueue.size() >= m_queueSize)
-	{
-		LOG(DEBUG) << "Queue full size drop frame size:"  << (int)m_captureQueue.size() ;		
-		delete m_captureQueue.front();
-		m_captureQueue.pop_front();
-	}
-	m_captureQueue.push_back(new Frame(frame, frameSize, tv));	
-	pthread_mutex_unlock (&m_mutex);
-	
-	// post an event to ask to deliver the frame
-	envir().taskScheduler().triggerEvent(m_eventTriggerId, this);
-}	
-
-// split packet in frames					
-std::list< std::pair<unsigned char*,size_t> > V4L2DeviceSource::splitFrames(unsigned char* frame, unsigned frameSize) 
-{				
-	std::list< std::pair<unsigned char*,size_t> > frameList;
-	if (frame != NULL)
-	{
-		frameList.push_back(std::pair<unsigned char*,size_t>(frame, frameSize));
-	}
-	return frameList;
+void V4L2DeviceSource::queueFrame(char *frame, int frameSize, const timeval &tv) {
+    pthread_mutex_lock(&m_mutex);
+    while (m_captureQueue.size() >= m_queueSize) {
+        //LOG_S(INFO) << "Queue full size drop frame size:" << (int) m_captureQueue.size();
+        delete m_captureQueue.front();
+        m_captureQueue.pop_front();
+    }
+    m_captureQueue.push_back(new Frame(frame, frameSize, tv));
+    pthread_mutex_unlock(&m_mutex);
+
+    // post an event to ask to deliver the frame
+    envir().taskScheduler().triggerEvent(m_eventTriggerId, this);
+}
+
+// split packet in frames
+std::list <std::pair<unsigned char *, size_t>> V4L2DeviceSource::splitFrames(unsigned char *frame, unsigned frameSize) {
+    std::list <std::pair<unsigned char *, size_t>> frameList;
+    if (frame != NULL) {
+        frameList.push_back(std::pair<unsigned char *, size_t>(frame, frameSize));
+    }
+    return frameList;
 }
 
 
diff -Nura v4l2rtspserver_imp_tools/src/H264_V4l2DeviceSource.cpp v4l2rtspserver-master/src/H264_V4l2DeviceSource.cpp
--- v4l2rtspserver_imp_tools/src/H264_V4l2DeviceSource.cpp	2019-02-01 20:08:29.565626000 +0100
+++ v4l2rtspserver-master/src/H264_V4l2DeviceSource.cpp	2019-02-03 20:24:23.649172000 +0100
@@ -15,9 +15,10 @@
 #include <Base64.hh>
 
 // project
-#include "logger.h"
+//#include "logger.h"
 #include "H264_V4l2DeviceSource.h"
-
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
 // ---------------------------------
 // H264 V4L2 FramedSource
 // ---------------------------------
@@ -35,9 +36,9 @@
 	{	
 		switch (m_frameType&0x1F)					
 		{
-			case 7: LOG(INFO) << "SPS size:" << size << " bufSize:" << bufSize; m_sps.assign((char*)buffer,size); break;
-			case 8: LOG(INFO) << "PPS size:" << size << " bufSize:" << bufSize; m_pps.assign((char*)buffer,size); break;
-			case 5: LOG(INFO) << "IDR size:" << size << " bufSize:" << bufSize; 
+			case 7: LOG_S(9) << "SPS size:" << size << " bufSize:" << bufSize; m_sps.assign((char*)buffer,size); break;
+			case 8: LOG_S(9) << "PPS size:" << size << " bufSize:" << bufSize; m_pps.assign((char*)buffer,size); break;
+			case 5: LOG_S(9) << "IDR size:" << size << " bufSize:" << bufSize;
 				if (m_repeatConfig && !m_sps.empty() && !m_pps.empty())
 				{
 					frameList.push_back(std::pair<unsigned char*,size_t>((unsigned char*)m_sps.c_str(), m_sps.size()));
@@ -83,11 +84,11 @@
 	{
 		switch ((m_frameType&0x7E)>>1)					
 		{
-			case 32: LOG(INFO) << "VPS size:" << size << " bufSize:" << bufSize; m_vps.assign((char*)buffer,size); break;
-			case 33: LOG(INFO) << "SPS size:" << size << " bufSize:" << bufSize; m_sps.assign((char*)buffer,size); break;
-			case 34: LOG(INFO) << "PPS size:" << size << " bufSize:" << bufSize; m_pps.assign((char*)buffer,size); break;
+			case 32: LOG_S(9) << "VPS size:" << size << " bufSize:" << bufSize; m_vps.assign((char*)buffer,size); break;
+			case 33: LOG_S(9) << "SPS size:" << size << " bufSize:" << bufSize; m_sps.assign((char*)buffer,size); break;
+			case 34: LOG_S(9) << "PPS size:" << size << " bufSize:" << bufSize; m_pps.assign((char*)buffer,size); break;
 			case 19: 
-			case 20: LOG(INFO) << "IDR size:" << size << " bufSize:" << bufSize; 
+			case 20: LOG_S(INFO) << "IDR size:" << size << " bufSize:" << bufSize;
 				if (m_repeatConfig && !m_vps.empty() && !m_sps.empty() && !m_pps.empty())
 				{
 					frameList.push_back(std::pair<unsigned char*,size_t>((unsigned char*)m_vps.c_str(), m_vps.size()));
@@ -168,7 +169,7 @@
 		}
 		size -= outsize;		
 	} else if (size>= sizeof(H264shortmarker)) {
-		 LOG(INFO) << "No marker found";
+		 LOG_S(FATAL) << "No marker found";
 	}
 
 	return outFrame;
diff -Nura v4l2rtspserver_imp_tools/src/HTTPServer.cpp v4l2rtspserver-master/src/HTTPServer.cpp
--- v4l2rtspserver_imp_tools/src/HTTPServer.cpp	2019-02-01 20:08:29.566626000 +0100
+++ v4l2rtspserver-master/src/HTTPServer.cpp	2019-02-03 20:24:23.649172000 +0100
@@ -167,70 +167,11 @@
 	return true;
 }
 
-bool HTTPServer::HTTPClientConnection::sendFile(char const* urlSuffix)
-{
-	bool ok = false;
-	
-	std::string url(urlSuffix);
-	size_t pos = url.find_first_of(" ");
-	if (pos != std::string::npos)
-	{
-		url.erase(0,pos+1);
-	}
-	pos = url.find_first_of(" ");
-	if (pos != std::string::npos)
-	{
-		url.erase(pos);
-	}
-	pos = url.find_first_of("/");
-	if (pos != std::string::npos)
-	{
-		url.erase(0,1);
-	}
-	std::string pattern("../");
-	while ((pos = url.find(pattern, pos)) != std::string::npos) {
-		url.erase(pos, pattern.length());
-	}			
-	
-	std::string ext;
-	pos = url.find_last_of(".");
-	if (pos != std::string::npos)
-	{
-		ext.assign(url.substr(pos+1));
-	}
-	
-	if (url.empty())
-	{
-		url = "index.html"; 
-		ext = "html";
-	}
-	if (ext=="js") ext ="javascript";
-	std::ifstream file(url.c_str());
-	if (file.is_open())
-	{
-		envir() << "send file:" << url.c_str() <<"\n";
-		std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
-		std::string mime("text/");
-		mime.append(ext);
-		this->sendHeader(mime.c_str(), content.size());
-		this->streamSource(content);
-		ok = true;
-	}
-	return ok;
-}			
 		
 void HTTPServer::HTTPClientConnection::handleHTTPCmd_StreamingGET(char const* urlSuffix, char const* fullRequestStr) 
 {
 	char const* questionMarkPos = strrchr(urlSuffix, '?');
-	if (strcmp(urlSuffix, "getVersion") == 0) 
-	{
-		std::ostringstream os;
-		os << VERSION;
-		std::string content(os.str());
-		this->sendHeader("text/plain", content.size());
-		this->streamSource(content);
-	}
-	else if (strncmp(urlSuffix, "getStreamList", strlen("getStreamList")) == 0) 
+	if (strncmp(urlSuffix, "getStreamList", strlen("getStreamList")) == 0) 
 	{
 		std::ostringstream os;
 		HTTPServer* httpServer = (HTTPServer*)(&fOurServer);
@@ -243,19 +184,17 @@
 		os << "[\n";
 		bool first = true;
 		while ( (serverSession = it.next()) != NULL) {
-			if (serverSession->duration() > 0) {
-				if (first) 
-				{
-					first = false;
-					os << " ";					
-				}
-				else 
-				{
-					os << ",";					
-				}
-				os << "\"" << serverSession->streamName() << "\"";
-				os << "\n";
+			if (first) 
+			{
+				first = false;
+				os << " ";					
 			}
+			else 
+			{
+				os << ",";					
+			}
+			os << "\"" << serverSession->streamName() << "\"";
+			os << "\n";
 		}
 		os << "]\n";
 		std::string content(os.str());
@@ -289,13 +228,48 @@
 		if (!ok)
 		{
 			// send local files
-			ok = this->sendFile(fullRequestStr);
+			std::string url(fullRequestStr);
+			size_t pos = url.find_first_of(" ");
+			if (pos != std::string::npos)
+			{
+				url.erase(0,pos+1);
+			}
+			pos = url.find_first_of(" ");
+			if (pos != std::string::npos)
+			{
+				url.erase(pos);
+			}
+			pos = url.find_first_of("/");
+			if (pos != std::string::npos)
+			{
+				url.erase(0,1);
+			}
+			std::string pattern("../");
+			while ((pos = url.find(pattern, pos)) != std::string::npos) {
+				url.erase(pos, pattern.length());
+			}			
+			if (url.empty())
+			{
+				url = "index.html"; 
+				ext = "html";
+			}
+			if (ext=="js") ext ="javascript";
+			std::ifstream file(url.c_str());
+			if (file.is_open())
+			{
+				envir() << "send file:" << url.c_str() <<"\n";
+				std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
+				std::string mime("text/");
+				mime.append(ext);
+				this->sendHeader(mime.c_str(), content.size());
+				this->streamSource(content);
+				ok = true;
+			}
 		}
 
 		if (!ok)
 		{
 			handleHTTPCmd_notSupported();
-			fIsActive = False;
 		}
 	}
 	else
@@ -312,7 +286,6 @@
 		if (subsession == NULL) 
 		{
 			handleHTTPCmd_notSupported();
-			fIsActive = False;
 			return;			  
 		}
 
@@ -334,7 +307,6 @@
 		{
 			// For some reason, we do not know the size of the requested range.  We can't handle this request:
 			handleHTTPCmd_notSupported();
-			fIsActive = False;
 		}
 		else
 		{
diff -Nura v4l2rtspserver_imp_tools/src/ImpCapture.cpp v4l2rtspserver-master/src/ImpCapture.cpp
--- v4l2rtspserver_imp_tools/src/ImpCapture.cpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/src/ImpCapture.cpp	2019-02-03 20:24:23.649172000 +0100
@@ -0,0 +1,46 @@
+#include "ImpCapture.h"
+
+#include <sys/types.h>
+
+
+#include "sharedmem.h"
+
+ImpCapture::ImpCapture(impParams params) {
+    impEncoder = new ImpEncoder(params);
+    height = params.height;
+    width = params.width;
+    mode = params.mode;
+    //m_buffer = malloc(height*width);
+}
+
+
+int ImpCapture::getWidth() {
+    return this->width;
+};
+
+int ImpCapture::getHeight() {
+    return this->height;
+};
+
+
+size_t ImpCapture::read(char *buffer, size_t bufferSize) {
+    int frameSize;
+
+
+    if (mode != IMP_MODE_JPEG) {
+        frameSize = impEncoder->snap_h264((uint8_t*)buffer);
+    }
+    //memcpy(buffer, m_buffer, frameSize);
+    return frameSize;
+}
+
+int ImpCapture::getFd() {
+    return 0;
+}
+
+unsigned long ImpCapture::getBufferSize() {
+    return width*height; //impEncoder->getBufferSize();
+}
+
+
+
diff -Nura v4l2rtspserver_imp_tools/src/ImpEncoder.cpp v4l2rtspserver-master/src/ImpEncoder.cpp
--- v4l2rtspserver_imp_tools/src/ImpEncoder.cpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/src/ImpEncoder.cpp	2019-02-03 20:24:23.650172000 +0100
@@ -0,0 +1,1555 @@
+/*
+ * sample-Encoder-jpeg.c
+ *
+ * Copyright (C) 2014 Ingenic Semiconductor Co.,Ltd
+ */
+
+
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
+
+#include <stdio.h>
+
+#include <imp/imp_log.h>
+#include <imp/imp_common.h>
+#include <imp/imp_system.h>
+#include <imp/imp_framesource.h>
+#include <imp/imp_encoder.h>
+#include <imp/imp_ivs.h>
+#include <imp/imp_ivs_move.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <stdarg.h>
+#include <signal.h>
+#include "ImpEncoder.h"
+
+
+#include <stdexcept>
+#include <tuple>
+
+
+bool m_osdOn = true;
+bool m_jpegOn = true;
+bool m_motionOn = false;
+
+
+// ---- OSD
+//
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+#include FT_MODULE_H
+#include FT_CFF_DRIVER_H
+#include "OSD.hpp"
+char *fontMono = NULL;
+char *fontSans = NULL;
+int image_width;
+int image_height;
+
+#include "loguru.hpp"
+#include "sharedmem.h"
+#include "../tools/sharedmem.h"
+#include "../inc/imp/imp_encoder.h"
+
+
+
+bool gDetectionOn = false;
+bool ismotionActivated = true;
+
+char *detectionScriptOn = NULL;
+char *detectionScriptOff = NULL;
+char *detectionTracking= NULL;
+#include "ConfigReader.h"
+
+
+IMPIVSInterface *inteface = NULL;
+
+// Activate or not tracking
+bool isMotionTracking = false;
+int motionTimeout = -1; // -1 is for deactivation
+
+static int ivsMoveStart(int grp_num, int chn_num, IMPIVSInterface **interface, int x0, int y0, int x1, int y1, int width, int height );
+static void *ivsMoveDetectionThread(void *arg);
+
+static void snap_jpeg(std::vector<uint8_t> &buffer);
+
+//#define RING 1
+#ifdef RING
+#include "ring.hpp"
+#include <mutex>
+// ugly ...
+extern DetectionSaveToDiskState flushBufferToFile;
+typedef RingBufferT<uint8_t> CircularBuffer;
+
+CircularBuffer *m_ringBuffer = NULL;
+void *saveRingThread(void *p);
+
+std::mutex m_mutexVector;
+std::vector<uint8_t> m_vectorBuffer;
+#endif
+
+
+static int ivsSetsensitivity(int sens)
+{
+	int ret = 0;
+	IMP_IVS_MoveParam param;
+	ret = IMP_IVS_GetParam(0, &param);
+	if (ret < 0) {
+		LOG_S(ERROR) << "IMP_IVS_GetParam(0) failed";
+		return -1;
+	}
+
+    param.sense[0] = sens;
+    param.sense[1] = sens;
+    param.sense[2] = sens;
+    param.sense[3] = sens;
+
+	ret = IMP_IVS_SetParam(0, &param);
+	if (ret < 0) {
+		LOG_S(ERROR) << "IMP_IVS_SetParam(0) failed";
+		return -1;
+	}
+	return 0;
+}
+
+static int ivsSetDetectionRegion(int detectionRegion[4] )
+{
+	int ret = 0;
+    ret = ivsMoveStart(0, 0, &inteface, detectionRegion[0], detectionRegion[1], detectionRegion[2], detectionRegion[3],image_width,image_height) ;
+    if (ret < 0) {
+        LOG_S(ERROR) << "ivsMoveStart(0, 0) failed";
+    }
+    pthread_t tid;
+    //  start to get ivs move result
+    if (pthread_create(&tid, NULL, ivsMoveDetectionThread, NULL)) {
+        LOG_S(ERROR) << "create sample_ivs_move_get_result_process failed";
+    }
+  	return 0;
+}
+
+
+static void* update_thread(void *p) {
+    loguru::set_thread_name("update_thread");
+
+    std::vector<uint8_t> jpeg_buffer;
+    FT_Library library = NULL;
+    FT_Face face = NULL;
+    int font_baseline_offset = 0;
+
+    if (m_osdOn == true) {
+
+        if (FT_Init_FreeType(&library) != 0) {
+            LOG_S(ERROR) << "Could not initialize FreeType";
+            return NULL;
+        }
+
+        FT_UInt hinting_engine = FT_CFF_HINTING_ADOBE;
+
+        if (FT_Property_Set(library, "cff", "hinting-engine", &hinting_engine) != 0) {
+            LOG_S(ERROR) << "Could not set hinting engine";
+            return NULL;
+        }
+    }
+    bool firstConfigPass = true;
+    bool alreadySetDetectionRegion = false;
+
+    SharedMem &sharedMem = SharedMem::instance();
+    shared_conf *newConfig = sharedMem.getConfig();
+    shared_conf currentConfig = {0};
+    OSD *motion_osd = NULL;
+    OSD *timestamp_osd = NULL;
+    if (m_osdOn == true) {
+        // Move it to the top right of the screen
+        motion_osd = new OSD(image_width - DETECTION_CIRCLE_SIZE, 0, DETECTION_CIRCLE_SIZE, DETECTION_CIRCLE_SIZE, 0);
+
+        // Default to top left and 10px high until we read the config
+        timestamp_osd = new OSD(0, 0, image_width, 10, 1);
+
+        if (IMP_OSD_Start(0) != 0) {
+            LOG_S(ERROR) << "OSD show error";
+            return NULL;
+        }
+
+        motion_osd->show(true);
+        timestamp_osd->show(true);
+    }
+    while (true) {
+        sharedMem.readConfig();
+
+        // Update the settings
+        if (currentConfig.flip != newConfig->flip) {
+            LOG_S(INFO) << "Changed FLIP";
+            if (newConfig->flip == 1) {
+                IMP_ISP_Tuning_SetISPVflip(IMPISP_TUNING_OPS_MODE_ENABLE);
+                IMP_ISP_Tuning_SetISPHflip(IMPISP_TUNING_OPS_MODE_ENABLE);
+            } else {
+                IMP_ISP_Tuning_SetISPVflip(IMPISP_TUNING_OPS_MODE_DISABLE);
+                IMP_ISP_Tuning_SetISPHflip(IMPISP_TUNING_OPS_MODE_DISABLE);
+            }
+        }
+
+        if (currentConfig.nightmode != newConfig->nightmode) {
+            LOG_S(INFO) << "Changed NIGHTVISION";
+            ImpEncoder::setNightVision(newConfig->nightmode);
+        }
+
+        if (currentConfig.bitrate != newConfig->bitrate) {
+            LOG_S(INFO) << "Attempt to changed Bitrate to " << newConfig->bitrate;
+            IMPEncoderAttrRcMode attr;
+            int ret = IMP_Encoder_GetChnAttrRcMode(0, &attr);
+            if (ret < 0) {
+                LOG_S(INFO) << "Unable to get param to change the bitrate";
+            }
+            switch (attr.rcMode) {
+                case ENC_RC_MODE_SMART:
+                    LOG_S(INFO) << "Setting SMART maxBitrate.";
+                    attr.attrH264Smart.maxBitRate = (uint)newConfig->bitrate;
+                    break;
+
+                case ENC_RC_MODE_CBR:
+                    LOG_S(INFO) << "Setting CBR outBitrate.";
+                    attr.attrH264Cbr.outBitRate = (uint)newConfig->bitrate;
+                    break;
+
+                case ENC_RC_MODE_VBR:
+                    LOG_S(INFO) << "Setting VBR maxBitrate.";
+                    attr.attrH264Vbr.maxBitRate = (uint)newConfig->bitrate;
+                    break;
+
+                default:
+                    LOG_S(INFO) << "Bitrate does not apply to rcmode " << attr.rcMode;
+                    break;
+            }
+            IMP_Encoder_SetChnAttrRcMode(0, &attr);
+            if (ret < 0) {
+                LOG_S(INFO) << "Unable to change the bitrate";
+            }
+
+        }
+
+        if ((currentConfig.frmRateConfig[0] != newConfig->frmRateConfig[0]) || (currentConfig.frmRateConfig[1] != newConfig->frmRateConfig[1])) {
+            IMPEncoderFrmRate rate = {0};
+            LOG_S(INFO) << "Attempt to change fps to " << newConfig->frmRateConfig[0] << "," << newConfig->frmRateConfig[1];
+            rate.frmRateNum = newConfig->frmRateConfig[0];
+            rate.frmRateDen = newConfig->frmRateConfig[1];
+
+            int ret = IMP_Encoder_SetChnFrmRate(0, &rate);
+
+            if (ret != 0) {
+                LOG_S(ERROR) << "IMP_Encoder_SetChnFrmRate(0) error:" << ret;
+            }
+        }
+        if (m_osdOn == true) {
+            // Remap the old pre-defined color values
+            if (newConfig->osdColor == 0)       newConfig->osdColor = RGBAColor::WHITE;
+            else if (newConfig->osdColor == 1)  newConfig->osdColor = RGBAColor::BLACK;
+            else if (newConfig->osdColor == 2)  newConfig->osdColor = RGBAColor::RED;
+            else if (newConfig->osdColor == 3)  newConfig->osdColor = RGBAColor::GREEN;
+            else if (newConfig->osdColor == 4)  newConfig->osdColor = RGBAColor::BLUE;
+            else if (newConfig->osdColor == 5)  newConfig->osdColor = RGBAColor::CYAN;
+            else if (newConfig->osdColor == 6)  newConfig->osdColor = RGBAColor::YELLOW;
+            else if (newConfig->osdColor == 7)  newConfig->osdColor = RGBAColor::MAGENTA;
+
+            if (firstConfigPass || (currentConfig.osdFixedWidth != newConfig->osdFixedWidth)
+                                || strcmp(currentConfig.osdFontName, newConfig->osdFontName) != 0) {
+                int result;
+
+                if (newConfig->osdFontName[0] != 0) {
+                    LOG_S(INFO) << "Font name:" << newConfig->osdFontName;
+                    FT_Done_Face(face);
+                    result = FT_New_Face(library, newConfig->osdFontName, 0, &face);
+                } else if (newConfig->osdFixedWidth) {
+                    LOG_S(INFO) << "Font name:" << fontMono;
+                    FT_Done_Face(face);
+                    result = FT_New_Face(library, fontMono, 0, &face);
+                } else {
+                    LOG_S(INFO) << "Font name:" << fontSans;
+                    FT_Done_Face(face);
+                    result = FT_New_Face(library, fontSans, 0, &face);
+                }
+
+                if (result != 0) {
+                    LOG_S(ERROR) << "Could not load or parse the font file";
+                }
+
+                // to trigger OSD resize
+                firstConfigPass = true;
+
+                LOG_S(INFO) << "Changed OSD font";
+            }
+
+            if (currentConfig.osdPosY != newConfig->osdPosY) {
+                timestamp_osd->setBounds(timestamp_osd->getX(), newConfig->osdPosY, timestamp_osd->getWidth(), timestamp_osd->getHeight());
+
+                // As the size changed, re-display the OSD
+                LOG_S(INFO) <<  "Changed OSD y-offset";
+
+                // to trigger OSD resize
+                firstConfigPass = true;
+            }
+
+            // Old interface specify 0 for "small" font
+            if (newConfig->osdSize == 0) {
+                newConfig->osdSize = 18;
+            // and 1 for "bigger" font
+            } else if (newConfig->osdSize == 1) {
+                newConfig->osdSize = 40;
+            }
+
+            if (firstConfigPass || (currentConfig.osdSize != newConfig->osdSize)) {
+                if (FT_Set_Char_Size(face, 0, newConfig->osdSize * 64, 100, 100) != 0) {
+                    LOG_S(ERROR) << "Could not set font size";
+                }
+
+                int font_height;
+                std::tie(font_height, font_baseline_offset) = get_vertical_font_dimensions(face);
+                timestamp_osd->setBounds(timestamp_osd->getX(), timestamp_osd->getY(), image_width, font_height);
+
+                LOG_S(INFO) << "Max font bitmap height is " << font_height << " and baseline offset is " << font_baseline_offset;
+
+                LOG_S(INFO) << "Changed OSD size";
+            }
+        }
+
+        if (m_motionOn == true) {
+
+            if (currentConfig.motionTracking != newConfig->motionTracking ) {
+                isMotionTracking = newConfig->motionTracking;
+                if (isMotionTracking == true) {
+                    LOG_S(INFO) << "Tracking set to On";
+                    if (alreadySetDetectionRegion == false)
+                    {
+                        alreadySetDetectionRegion = true;
+                        ivsSetsensitivity(newConfig->sensitivity);
+                        ivsSetDetectionRegion(newConfig->detectionRegion);
+                    }
+                } else {
+                        LOG_S(INFO) << "Tracking set to Off";
+                }
+            }
+
+            if (currentConfig.sensitivity != newConfig->sensitivity) {
+                if (newConfig->sensitivity == -1) {
+                    ismotionActivated = false;
+                    LOG_S(INFO) << "Deactivate motion";
+                } else {
+                    ismotionActivated = true;
+                    LOG_S(INFO) << "Changed motion sensitivity=" << newConfig->sensitivity ;
+                    if (alreadySetDetectionRegion == false) {
+                        alreadySetDetectionRegion = true;
+                        ivsSetDetectionRegion(newConfig->detectionRegion);
+                        LOG_S(INFO) << "Changed motion region";
+                    }
+
+                    ivsSetsensitivity(newConfig->sensitivity);
+                }
+            }
+        }
+
+        if ((m_osdOn == true) && (m_motionOn == true)) {
+            // Remap the old pre-defined color values
+            if (newConfig->motionOSD == 0)       newConfig->motionOSD = RGBAColor::WHITE;
+            else if (newConfig->motionOSD == 1)  newConfig->motionOSD = RGBAColor::BLACK;
+            else if (newConfig->motionOSD == 2)  newConfig->motionOSD = RGBAColor::RED;
+            else if (newConfig->motionOSD == 3)  newConfig->motionOSD = RGBAColor::GREEN;
+            else if (newConfig->motionOSD == 4)  newConfig->motionOSD = RGBAColor::BLUE;
+            else if (newConfig->motionOSD == 5)  newConfig->motionOSD = RGBAColor::CYAN;
+            else if (newConfig->motionOSD == 6)  newConfig->motionOSD = RGBAColor::YELLOW;
+            else if (newConfig->motionOSD == 7)  newConfig->motionOSD = RGBAColor::MAGENTA;
+
+            if (currentConfig.motionOSD != newConfig->motionOSD) {
+                LOG_S(INFO) << "Display motion OSD color=" << newConfig->motionOSD;
+            }
+        }
+        if (m_motionOn == true) {
+            if (newConfig->motionTimeout > 0) {
+                motionTimeout = newConfig->motionTimeout;
+            }
+        }
+
+        memcpy(&currentConfig, newConfig, sizeof(shared_conf));
+        strcpy(currentConfig.osdTimeDisplay, newConfig->osdTimeDisplay);
+
+        if (firstConfigPass) {
+            firstConfigPass = false;
+        }
+
+        // Read the current time
+        struct timespec spec;
+        clock_gettime(CLOCK_REALTIME, &spec);
+
+        // Sleep until just a little after the next second
+        spec.tv_sec = 0;
+        spec.tv_nsec = 1010000000L - spec.tv_nsec;
+
+        nanosleep(&spec, NULL);
+
+        if (m_osdOn == true) {
+            // Draw the timestamp OSD
+            osd_draw_timestamp(*timestamp_osd, face, font_baseline_offset, currentConfig);
+            // Draw the motion detection circle
+            if (currentConfig.motionOSD != -1) {
+                osd_draw_detection_circle(*motion_osd, gDetectionOn, currentConfig);
+            }
+        }
+
+        if (m_jpegOn == true) {
+            // Dump the JPEG once every second
+            jpeg_buffer.clear();
+
+            try {
+                snap_jpeg(jpeg_buffer);
+                sharedMem.copyImage(jpeg_buffer.data(), jpeg_buffer.size());
+            } catch (const std::runtime_error &e) {
+                LOG_S(INFO) << "Failed to read the JPEG stream: " << e.what();
+            }
+        }
+    }
+
+
+    return NULL;
+}
+
+static int file_exist(const char *filename)
+{
+  FILE *f = fopen(filename,"r");
+  if (f == NULL)
+    return 0;
+   fclose(f);
+   return 1;
+}
+
+static void exec_command(const char *command, char param[4][2])
+{
+     if (file_exist(command))
+     {
+      if (param == NULL) {
+         LOG_S(INFO) << "Will execute command " << command;
+         int retVal =  system(command);
+         LOG_S(INFO) << "Execute " << command << " returned:" << retVal;
+      } else {
+         char exe[256] = {0};
+         snprintf(exe, sizeof(exe), "%s %s %s %s %s", command, param[0],param[1],param[2],param[3]);
+
+         LOG_S(INFO) << "Will execute command " << exe;
+         int retVal =  system(exe);
+         LOG_S(INFO) << "Execute " << exe << " returned:" << retVal;
+      }
+     }
+     else
+     {
+         LOG_S(INFO) << "command " << command << " does not exist\n";
+     }
+
+}
+
+static int ivsMoveStart(int grp_num, int chn_num, IMPIVSInterface **interface, int x0, int y0, int x1, int y1, int width, int height )
+{
+    int ret = 0;
+    IMP_IVS_MoveParam param;
+    memset(&param, 0, sizeof(IMP_IVS_MoveParam));
+    // Skip to 50 avoid detection at startup, not sure it impacts when running
+    param.skipFrameCnt = 50;
+    param.frameInfo.width = width;
+    param.frameInfo.height = height;
+    if (isMotionTracking == true) {
+        // use the 4 regions
+        param.roiRectCnt = 4;
+        // Sensitivity (0 to 4)
+        param.sense[0] = 4;
+        param.sense[1] = 4;
+        param.sense[2] = 4;
+        param.sense[3] = 4;
+
+        // 0,0 +--------------------+-----------------+
+        //     |                    |                 |
+        //     |           0        |      1          |
+        //     |                    |                 |
+        // h/2 +--------------------+-----------------+
+        //     |                    |                 |
+        //     |          2         |      3          |
+        //     |                    |                 |
+        // h   +--------------------+-----------------+
+        //                          w/2               w
+
+        // Region 0
+        param.roiRect[0].p0.x = 0;
+        param.roiRect[0].p0.y = 0;
+        param.roiRect[0].p1.x = (width/2)- 1;
+        param.roiRect[0].p1.y = (height/2) - 1;
+
+        // Region 1
+        param.roiRect[1].p0.x = (width/2);
+        param.roiRect[1].p0.y = 0;
+        param.roiRect[1].p1.x = (width)- 1;
+        param.roiRect[1].p1.y = (height/2) - 1;
+
+        // Region 2
+        param.roiRect[2].p0.x = 0;
+        param.roiRect[2].p0.y = (height/2);
+        param.roiRect[2].p1.x = (width/2)- 1;
+        param.roiRect[2].p1.y = (height) - 1;
+
+        // Region 3
+        param.roiRect[3].p0.x = width/2;
+        param.roiRect[3].p0.y = (height/2);
+        param.roiRect[3].p1.x = width-1;
+        param.roiRect[3].p1.y = (height) - 1;
+
+        LOG_S(INFO) << "Detection region for motion tracking\n";
+    }
+    else
+    {
+       // Define the detection region, for now only one of the size of the video
+        param.roiRectCnt = 1;
+
+        // Sensitivity (0 to 4)
+        param.sense[0] = 4;
+
+        param.roiRect[0].p0.x = x0;
+        param.roiRect[0].p0.y = y0;
+        if (x1 == 0 && y1 == 0)
+        {
+            param.roiRect[0].p1.x = width - 1;
+            param.roiRect[0].p1.y = height  - 1;
+        } else {
+            param.roiRect[0].p1.x = x1 - 1;
+            param.roiRect[0].p1.y = y1  - 1;
+
+        }
+
+        LOG_S(INFO) << "Detection region= ((" << param.roiRect[0].p0.x << "," << param.roiRect[0].p0.y << ")-("<< param.roiRect[0].p1.x << "," << param.roiRect[0].p1.y << "))";
+    }
+
+    *interface = IMP_IVS_CreateMoveInterface(&param);
+    if (*interface == NULL) {
+        LOG_S(ERROR) << "IMP_IVS_CreateGroup(0) failed";
+        return -1;
+    }
+
+    ret = IMP_IVS_CreateChn(chn_num, *interface);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_IVS_CreateChn(" << chn_num << ") failed";
+        return -1;
+    }
+
+    ret = IMP_IVS_RegisterChn(grp_num, chn_num);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_IVS_RegisterChn(" << grp_num << "," << chn_num << "failed";
+        return -1;
+    }
+
+    ret = IMP_IVS_StartRecvPic(chn_num);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_IVS_StartRecvPic(" << chn_num << ") failed";
+        return -1;
+    }
+
+    return 0;
+}
+
+static void endofmotion(int sig)
+{
+    // In case of inactivity execute the script with no arguments
+    exec_command(detectionTracking, NULL);
+    LOG_S(INFO) << "End of motion";
+}
+
+static void *ivsMoveDetectionThread(void *arg)
+{
+    int ret = 0;
+    int chn_num = 0; 
+    IMP_IVS_MoveOutput *result = NULL;
+    bool isWasOn = false;
+    //time_t lastEvent = time(NULL)+15;
+
+    loguru::set_thread_name("ivsMoveDetectionThread");
+
+    while (1) {
+
+        if (ismotionActivated == true) {
+
+            ret = IMP_IVS_PollingResult(chn_num, IMP_IVS_DEFAULT_TIMEOUTMS);
+            if (ret < 0) {
+                LOG_S(ERROR) << "IMP_IVS_PollingResult("<<chn_num << "," << IMP_IVS_DEFAULT_TIMEOUTMS<< ") failed";
+                return (void *)-1;
+            }
+
+            ret = IMP_IVS_GetResult(chn_num, (void **)&result);
+            if (ret < 0) {
+                LOG_S(ERROR) << "IMP_IVS_GetResult(" << chn_num << ") failed";
+                return (void *)-1;
+            }
+
+
+            if (isMotionTracking == true) {
+               if (result->retRoi[0] == 1 ||
+                   result->retRoi[1] == 1 ||
+                   result->retRoi[2] == 1 ||
+                   result->retRoi[3] == 1) {
+                        char param[4][2] = {};
+                        isWasOn = true;
+                        gDetectionOn = true;
+
+                       snprintf(param[0], sizeof(param[0]), "%.1d", result->retRoi[0]);
+                       snprintf(param[1], sizeof(param[1]), "%.1d", result->retRoi[1]);
+                       snprintf(param[2], sizeof(param[2]), "%.1d", result->retRoi[2]);
+                       snprintf(param[3], sizeof(param[3]), "%.1d", result->retRoi[3]);
+
+                       exec_command(detectionTracking, param);
+                       exec_command(detectionScriptOn, NULL);
+
+                       if (motionTimeout != -1)
+                       {
+                            signal(SIGALRM, endofmotion);
+                            alarm(motionTimeout);
+                       }
+                }
+                else
+                {
+                    if (isWasOn == true) {
+                        exec_command(detectionScriptOff, NULL);
+                    }
+                    gDetectionOn = false;
+                    isWasOn = false;
+                }
+            } else {
+
+                if ((isWasOn == false) &&
+                    (result->retRoi[0] == 1) )
+                {
+                 // Detection !!!
+                    //time_t diffTime = time(NULL) - lastEvent;
+                   // printf("Diff time = %d\n", diffTime);
+                    //if (diffTime > 30)
+                    {
+                        isWasOn = true;
+                        gDetectionOn = true;
+                        exec_command(detectionScriptOn, NULL);
+                        LOG_S(INFO) << "Detect !!";
+                    }
+                } else {
+       /*                 if (isWasOn == true) {
+                            exec_command(detectionScriptOff, NULL);
+                        }
+                        gDetectionOn = false;
+                        isWasOn = false;*/
+                }
+
+                if ((isWasOn == true) &&
+                    (result->retRoi[0] == 0))
+                {
+
+                    isWasOn = false;
+                    gDetectionOn = false;
+                    exec_command(detectionScriptOff, NULL);
+                    LOG_S(INFO) << "Detect finished!!";
+                    //lastEvent = time(NULL);
+                }
+            }
+
+            ret = IMP_IVS_ReleaseResult(chn_num, (void *)result);
+            if (ret < 0) {
+                LOG_S(ERROR) << "IMP_IVS_ReleaseResult("<< chn_num << ") failed";
+                return (void *)-1;
+            }
+
+        }
+        else
+        {
+            sleep(1);
+        }
+    }
+    return (void *)0;
+}
+
+ImpEncoder::ImpEncoder(impParams params) {
+    currentParams = params;
+
+    int skiptype = 0;
+    int quality = 0;
+    int maxSameSceneCnt = 0;
+
+    int ret;
+
+
+
+    //m_motionOn = reader.GetBoolean("Configuration","MOTION",true);
+    if (m_motionOn == true) {
+        LOG_S(INFO) << "Motion activated";
+        //detectionScriptOn = strdup(reader.Get("Configuration", "DetectionScriptOn", "").c_str());
+        //detectionScriptOff = strdup(reader.Get("Configuration", "DetectionScriptOff", "").c_str());
+        //detectionTracking = strdup(reader.Get("Configuration", "DetectionTracking", "").c_str());
+    } else {
+        LOG_S(INFO) << "Motion deactivated";
+    }
+
+    //m_osdOn = reader.GetBoolean("Configuration","OSD",true);
+    if (m_osdOn == true) {
+    LOG_S(INFO) << "OSD activated";
+    //fontMono = strdup(reader.Get("Configuration", "FontFixedWidth", "").c_str());
+    //fontSans = strdup(reader.Get("Configuration", "FontRegular", "").c_str());
+    } else {
+    LOG_S(INFO) << "OSD deactivated";
+    }
+    //m_jpegOn = reader.GetBoolean("Configuration","JPEG",true);
+    if (m_jpegOn == true) {
+        LOG_S(INFO) << "JPEG capture activated";
+    } else {
+        LOG_S(INFO) << "JPEG capture deactivated";
+    }
+    //skiptype = reader.GetInteger("Video", "SkipType", 0);
+    //quality = reader.GetInteger("Video", "Quality", 2);
+    //maxSameSceneCnt = reader.GetInteger("Video", "maxSameSceneCnt", 6);
+    LOG_S(INFO) << "Video settings: skip:" << skiptype << " quality:" << quality << " maxSameSceneCnt:" << maxSameSceneCnt;
+
+
+
+
+
+
+
+    // Init Structure:
+    memset(&chn, 0, sizeof(chn_conf));
+
+    chn.index = 0;
+    chn.enable = 1;
+    chn.fs_chn_attr.pixFmt = PIX_FMT_NV12;
+    chn.fs_chn_attr.outFrmRateNum = currentParams.framerate;
+    chn.fs_chn_attr.outFrmRateDen = 1;
+    chn.fs_chn_attr.nrVBs = 3;
+    chn.fs_chn_attr.type = FS_PHY_CHANNEL;
+
+    chn.fs_chn_attr.crop.enable = 0;
+    chn.fs_chn_attr.crop.width = currentParams.width;
+    chn.fs_chn_attr.crop.height = currentParams.height;
+    chn.fs_chn_attr.crop.top = 0;
+    chn.fs_chn_attr.crop.left = 0;
+
+    chn.fs_chn_attr.scaler.enable = 1;
+    chn.fs_chn_attr.scaler.outwidth = currentParams.width;
+    chn.fs_chn_attr.scaler.outheight = currentParams.height;
+
+
+    chn.fs_chn_attr.picWidth = currentParams.width;
+    chn.fs_chn_attr.picHeight = currentParams.height;
+
+    chn.framesource_chn.deviceID = DEV_ID_FS;
+    chn.framesource_chn.groupID = 0;
+    chn.framesource_chn.outputID = 0;
+
+    chn.imp_encoder.deviceID = DEV_ID_ENC;
+    chn.imp_encoder.groupID = 0;
+    chn.imp_encoder.outputID = 0;
+
+    if (m_osdOn == true) {
+        chn.OSD_Cell.deviceID = DEV_ID_OSD;
+        chn.OSD_Cell.groupID = 0;
+        chn.OSD_Cell.outputID = 0;
+    }
+    encoderMode = currentParams.rcmode;
+
+
+#ifdef RING
+    m_ringBuffer = new CircularBuffer(2048*1024*1);
+
+    pthread_t t_id = 0;
+    if (pthread_create(&t_id, NULL, saveRingThread, NULL)) {
+        LOG_S(ERROR) << "pthread_create saveRingThread failed";
+    }
+#endif
+
+    /* Step.1 System init */
+    ret = sample_system_init();
+    if (ret < 0) {
+        LOG_S(ERROR) <<"IMP_System_Init() failed";
+    }
+
+    /* Step.2 FrameSource init */
+    ret = sample_framesource_init();
+    if (ret < 0) {
+        LOG_S(ERROR) << "FrameSource init failed";
+
+    }
+
+
+    ret = IMP_Encoder_CreateGroup(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_CreateGroup(0) error !";
+
+    }
+
+    if (m_jpegOn == true) {
+        ret = IMP_Encoder_CreateGroup(1);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_Encoder_CreateGroup(1) error !";
+        }
+        /* Step.3 Encoder init */
+        ret = sample_jpeg_init();
+        if (ret < 0) {
+            LOG_S(ERROR) << "Encoder JPEG init failed";
+
+        }
+    }
+    /* Step.3 Encoder init */
+    ret = sample_encoder_init(quality, skiptype, maxSameSceneCnt);
+    if (ret < 0) {
+        LOG_S(ERROR) << "Encoder h264 init failed";
+
+    }
+    image_width = currentParams.width;
+    image_height = currentParams.height;
+
+    if (m_osdOn == true) {
+        // ----- OSD implementation: Init
+        //
+        if (IMP_OSD_CreateGroup(0) != 0) {
+           LOG_S(ERROR) << "IMP_OSD_CreateGroup(0) error !";
+        }
+
+        /* Step Bind */
+        ret = IMP_System_Bind(&chn.framesource_chn, &chn.OSD_Cell);
+        if (ret < 0) {
+            LOG_S(ERROR) << "Bind FrameSource channel0 and OSD failed";
+        }
+
+        ret = IMP_System_Bind(&chn.OSD_Cell, &chn.imp_encoder);
+        if (ret < 0) {
+            LOG_S(ERROR) << "Bind OSD and Encoder failed";
+        }
+    }
+    /* Step Bind */
+    ret = IMP_System_Bind(&chn.framesource_chn, &chn.imp_encoder);
+    if (ret < 0) {
+        LOG_S(ERROR) << "Bind FrameSource channel0 and encoder failed";
+    }
+
+    if (m_motionOn == true) {
+        // ----- Motion implementation: Init
+
+        IMPCell ivs_grp0 = { DEV_ID_IVS , 0, 0};
+        ret = IMP_IVS_CreateGroup(0);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_IVS_CreateGroup(0) failed";
+        }
+
+        ret = IMP_System_Bind (&chn.framesource_chn, &ivs_grp0);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_System_Bind";
+        }
+    }
+
+    // --- OSD and other stuffs thread
+    pthread_t tid;
+    ret = pthread_create(&tid, NULL, update_thread, NULL);
+    sleep(0);
+    if (ret) {
+        LOG_S(ERROR) << "thread create error";
+    }
+
+    ret = sample_framesource_streamon();
+    if (ret < 0) {
+        LOG_S(ERROR) << "ImpStreamOn failed";
+
+    }
+
+    /* drop several pictures of invalid data */
+    nanosleep((const struct timespec[]){{0, 500000000L}}, NULL);
+    if (m_jpegOn == true) {
+        // JPEG
+        ret = IMP_Encoder_StartRecvPic(1);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_Encoder_StartRecvPic(2) failed";
+        }
+    }
+    // H264
+    ret = IMP_Encoder_StartRecvPic(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_StartRecvPic(0) failed";
+    }
+
+    memset(&m_mutex, 0, sizeof(m_mutex));
+    pthread_mutex_init(&m_mutex, NULL);
+
+
+}
+
+
+ImpEncoder::~ImpEncoder() {
+    int ret;
+
+
+    /* Step.b UnBind */
+    ret = IMP_Encoder_StopRecvPic(1);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_StopRecvPic() failed";
+
+    }
+
+    ret = IMP_Encoder_StopRecvPic(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_StopRecvPic() failed";
+
+    }
+
+    /* Exit sequence as follow... */
+    /* Step.a Stream Off */
+    ret = sample_framesource_streamoff();
+    if (ret < 0) {
+        LOG_S(ERROR) << "FrameSource StreamOff failed";
+
+    }
+
+    /* Step.b UnBind */
+
+    ret = IMP_System_UnBind(&chn.framesource_chn, &chn.imp_encoder);
+    if (ret < 0) {
+        LOG_S(ERROR) << "UnBind FrameSource channel0 and Encoder failed";
+
+    }
+
+
+    /* Step.c Encoder exit */
+    ret = sample_encoder_exit();
+    if (ret < 0) {
+        LOG_S(ERROR) << "Encoder exit failed";
+
+    }
+
+    /* Step.d FrameSource exit */
+    ret = sample_framesource_exit();
+    if (ret < 0) {
+        LOG_S(ERROR) << "FrameSource exit failed";
+
+    }
+
+    /* Step.e System exit */
+    ret = sample_system_exit();
+    if (ret < 0) {
+        LOG_S(ERROR) << "sample_system_exit() failed";
+
+    }
+
+}
+
+void save_stream(std::vector<uint8_t> &buffer, IMPEncoderStream &stream) {
+    for (unsigned int i = 0; i < stream.packCount; i++) {
+        IMPEncoderPack &packet = stream.pack[i];
+
+        buffer.insert(buffer.end(), (uint8_t *)packet.virAddr, (uint8_t *)packet.virAddr + packet.length);
+    }
+}
+
+int save_stream(uint8_t *buffer, IMPEncoderStream &stream) {
+    int bytes_read = 0;
+
+    for (unsigned int i = 0; i < stream.packCount; i++) {
+        IMPEncoderPack &packet = stream.pack[i];
+
+        memcpy(buffer + bytes_read, (void *)packet.virAddr, packet.length);
+        bytes_read += packet.length;
+    }
+
+    return bytes_read;
+}
+
+void snap_jpeg(std::vector<uint8_t> &buffer) {
+    // Polling JPEG Snap, set timeout as 1000msec
+    if (IMP_Encoder_PollingStream(1, 1000) != 0) {
+        throw std::runtime_error("Polling stream timeout");
+    }
+
+    IMPEncoderStream stream;
+
+    if (IMP_Encoder_GetStream(1, &stream, 1) != 0) {
+        throw std::runtime_error("IMP_Encoder_GetStream() failed");
+    }
+
+    save_stream(buffer, stream);
+    IMP_Encoder_ReleaseStream(1, &stream);
+}
+#ifdef RING
+void *saveRingThread(void *p)
+{
+    int fd = 0;
+    char _fileName[256];
+    uint8_t buf[2048*1024*1];
+
+    while (1)
+    {
+        LOG_S(INFO) << "Loop " << flushBufferToFile;
+        switch (flushBufferToFile) {
+            case BUFFERIZE:
+             if (fd != 0)
+             {
+                LOG_S(INFO) << "Close";
+                close(fd);
+                fd = 0;
+             }
+             LOG_S(INFO) << "Size=" << m_ringBuffer->getAvailableWrite();
+             sleep(1);
+             break;
+            case LIVETODISK:
+                if (fd == 0)
+                {
+                    /* if (fileNo == 0) fileNo = 1;
+                     else  fileNo =  0;*/
+                     snprintf(_fileName, sizeof(_fileName), "/system/sdcard/www/cgi-bin/file0.h264");
+                     LOG_S(INFO) << "Open " << _fileName;
+                     fd =  open(_fileName, O_RDWR | O_CREAT | O_TRUNC, 0777);
+                }
+
+                if (fd != 0)
+                {
+                    while (m_ringBuffer->getAvailableWrite() == 0)
+                        sleep(1);
+                    //flushBufferToFile = LIVETODISKBUFFER;
+                   /* while ((m_ringBuffer->size() > 0)
+                           && (flushBufferToFile == LIVETODISK))*/
+                    {
+                        size_t s = m_ringBuffer->read(buf, sizeof(buf));
+                        write(fd,buf, s);
+                        LOG_S(INFO) << "write Size ring=" << s;
+                    }
+
+
+                }
+                else
+                {
+                    printf("Can not open !!\n");
+                }
+                break;
+            case LIVETODISKBUFFER:
+             m_mutexVector.lock();
+             if (m_vectorBuffer.size() > 0)
+             {
+                size_t t = write(fd, &m_vectorBuffer[0], m_vectorBuffer.size());
+                m_vectorBuffer.clear();
+                m_mutexVector.unlock();
+
+                LOG_S(INFO) << "Write=" << t;
+             } else {
+                m_mutexVector.unlock();
+                sleep(1);
+             }
+
+             break;
+        }
+    }
+    return NULL;
+}
+#endif
+
+int ImpEncoder::snap_h264(uint8_t *buffer) {
+    // H264 Channel start receive picture
+    int num_frames = 1;
+    int bytes_read = 0;
+
+    for (int i = 0; i < num_frames; i++) {
+        // Polling H264 Stream, set timeout as 1000msec
+
+        if (IMP_Encoder_PollingStream(0, 1000) != 0) {
+            LOG_S(ERROR) << "Polling stream timeout";
+            continue;
+        }
+
+        IMPEncoderStream stream;
+
+        // Get H264 Stream
+        if (IMP_Encoder_GetStream(0, &stream, 1) != 0) {
+            throw std::runtime_error("IMP_Encoder_GetStream() failed");
+        }
+
+        LOG_S(9) << "i" << i << ", stream.packCount"<<stream.packCount <<" stream.h264RefType="<<stream.refType << "seq="<< stream.seq;
+
+        bytes_read += save_stream(buffer, stream);
+
+        IMP_Encoder_ReleaseStream(0, &stream);
+    }
+#ifdef RING
+    //if (flushBufferToFile == BUFFERIZE) {
+        m_ringBuffer->write(buffer,bytes_read);
+    /*} else {
+        m_mutexVector.lock();
+        m_vectorBuffer.insert(m_vectorBuffer.end(), buffer, buffer + bytes_read);
+        m_mutexVector.unlock();
+        printf("Vector size=%d\n", m_vectorBuffer.size());
+    }*/
+#endif
+    return bytes_read;
+}
+/*
+bool ImpEncoder::listEmpty() {
+    pthread_mutex_lock(&m_mutex);
+    bool listEmpty = frameList.empty();
+    pthread_mutex_unlock(&m_mutex);
+    return listEmpty;
+}
+
+IMPEncoderPack ImpEncoder::getFrame() {
+    pthread_mutex_lock(&m_mutex);
+    IMPEncoderPack frame = frameList.front();
+    frameList.pop_front();
+    pthread_mutex_unlock(&m_mutex);
+    return frame;
+}
+*/
+
+void ImpEncoder::requestIDR() {
+    IMP_Encoder_RequestIDR(0);
+}
+
+
+int ImpEncoder::sample_system_init() {
+    int ret = 0;
+    char sensorName[STRING_MAX_SIZE];
+
+    int sensorAddr = ConfigReader::instance().getSensorAddr();
+    strcpy(sensorName,ConfigReader::instance().getSensorName());
+
+
+    LOG_S(INFO) << "Starting with Sensor:"<<  sensorName;
+    int sensorNameLen = strlen(sensorName);
+
+
+    memset(&sensor_info, 0, sizeof(IMPSensorInfo));
+    memcpy(sensor_info.name, sensorName, sensorNameLen);
+    sensor_info.cbus_type = SENSOR_CUBS_TYPE;
+    memcpy(sensor_info.i2c.type, sensorName, sensorNameLen);
+    sensor_info.i2c.addr = sensorAddr;
+
+    //IMP_LOG_ERR(TAG, "Imp Log %d\n", IMP_Log_Get_Option());
+    //IMP_Log_Set_Option()
+
+    ret = IMP_ISP_Open();
+    if (ret < 0) {
+        LOG_S(ERROR) << "failed to open ISP";
+        return -1;
+    }
+
+
+    ret = IMP_ISP_AddSensor(&sensor_info);
+    if (ret < 0) {
+        LOG_S(ERROR) << "failed to AddSensor";
+        exit(-1);
+        return -1;
+
+    }
+
+    ret = IMP_ISP_EnableSensor();
+    if (ret < 0) {
+        LOG_S(ERROR) << "failed to EnableSensor";
+        return -1;
+    }
+
+
+    ret = IMP_System_Init();
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_System_Init failed";
+        return -1;
+    }
+
+
+    /* enable turning, to debug graphics */
+
+    ret = IMP_ISP_EnableTuning();
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_ISP_EnableTuning failed";
+        return -1;
+    }
+
+    /*
+       ret = IMP_ISP_Tuning_SetWDRAttr(IMPISP_TUNING_OPS_MODE_DISABLE);
+       if (ret < 0) {
+       IMP_LOG_ERR(TAG, "failed to set WDR\n");
+       return -1;
+       }
+     */
+
+    return 0;
+}
+
+
+int ImpEncoder::sample_system_exit() {
+    int ret = 0;
+
+    LOG_S(INFO) << "sample_system_exit start";
+
+
+    IMP_System_Exit();
+
+    ret = IMP_ISP_DisableSensor();
+    if (ret < 0) {
+        LOG_S(ERROR) << "failed to EnableSensor";
+        return -1;
+    }
+
+    ret = IMP_ISP_DelSensor(&sensor_info);
+    if (ret < 0) {
+        LOG_S(ERROR) << "failed to AddSensor";
+        return -1;
+    }
+
+    ret = IMP_ISP_DisableTuning();
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_ISP_DisableTuning failed";
+        return -1;
+    }
+
+    if (IMP_ISP_Close()) {
+        LOG_S(ERROR) << "failed to open ISP";
+        return -1;
+    }
+
+    LOG_S(INFO) <<" sample_system_exit success";
+
+    return 0;
+}
+
+int ImpEncoder::sample_framesource_streamon() {
+
+    int out_pipe[2];
+    int saved_stdout;
+    saved_stdout = dup(STDOUT_FILENO);
+    pipe(out_pipe);
+    dup2(out_pipe[1], STDOUT_FILENO);
+
+
+    int ret = 0;
+    /* Enable channels */
+
+    ret = IMP_FrameSource_EnableChn(0);
+    if (ret < 0) {
+        dup2(saved_stdout, STDOUT_FILENO);
+        LOG_S(ERROR) << "IMP_FrameSource_EnableChn(0) error:"<<  ret;
+        return -1;
+    } else {
+        fflush(stdout);
+        dup2(saved_stdout, STDOUT_FILENO);
+    }
+
+
+    return 0;
+}
+
+int ImpEncoder::sample_framesource_streamoff() {
+    int ret = 0;
+    /* Enable channels */
+
+    ret = IMP_FrameSource_DisableChn(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_DisableChn(0) error:"<<  ret;
+        return -1;
+    }
+
+    return 0;
+}
+
+int ImpEncoder::sample_framesource_init() {
+    int ret;
+
+
+    ret = IMP_FrameSource_CreateChn(0, &chn.fs_chn_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_CreateChn(0) error:"<<  ret;
+        return -1;
+    }
+
+    ret = IMP_FrameSource_SetChnAttr(0, &chn.fs_chn_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_SetChnAttr(0) error:"<<  ret;
+        return -1;
+    }
+
+    ret = IMP_FrameSource_CreateChn(1, &chn.fs_chn_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_CreateChn(1) error:"<<  ret;
+        return -1;
+    }
+
+    ret = IMP_FrameSource_SetChnAttr(1, &chn.fs_chn_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_SetChnAttr(1) error:"<<  ret;
+        return -1;
+    }
+
+    return 0;
+}
+
+int ImpEncoder::sample_framesource_exit() {
+    int ret;
+
+
+    /*Destroy channel i*/
+    ret = IMP_FrameSource_DestroyChn(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_FrameSource_DestroyChn(0) error:"<<  ret;
+        return -1;
+    }
+
+    return 0;
+}
+
+int ImpEncoder::sample_jpeg_init() {
+    int ret;
+    IMPEncoderAttr *enc_attr;
+    IMPEncoderCHNAttr channel_attr;
+    IMPFSChnAttr *imp_chn_attr_tmp;
+
+
+    imp_chn_attr_tmp = &chn.fs_chn_attr;
+    memset(&channel_attr, 0, sizeof(IMPEncoderCHNAttr));
+    enc_attr = &channel_attr.encAttr;
+    enc_attr->enType = PT_JPEG;
+    enc_attr->bufSize = 0;
+    enc_attr->profile = 0;
+    enc_attr->picWidth = imp_chn_attr_tmp->picWidth;
+    enc_attr->picHeight = imp_chn_attr_tmp->picHeight;
+
+    /* Create Channel */
+    ret = IMP_Encoder_CreateChn(1, &channel_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_CreateChn(1) error:"<<  ret;
+        return -1;
+    }
+
+    /* Resigter Channel */
+    ret = IMP_Encoder_RegisterChn(0, 1);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_RegisterChn(0,1) error:"<<  ret;
+        return -1;
+    }
+
+    return 0;
+}
+
+int ImpEncoder::sample_encoder_init(int quality, int skiptype, int maxSameSceneCnt) {
+
+    int ret;
+    IMPEncoderAttr *enc_attr;
+    IMPEncoderRcAttr *rc_attr;
+    IMPFSChnAttr *imp_chn_attr_tmp;
+    IMPEncoderCHNAttr channel_attr;
+
+
+    imp_chn_attr_tmp = &chn.fs_chn_attr;
+    memset(&channel_attr, 0, sizeof(IMPEncoderCHNAttr));
+    enc_attr = &channel_attr.encAttr;
+    enc_attr->enType = PT_H264;
+    enc_attr->bufSize = 0;
+    enc_attr->profile = 1;
+    enc_attr->picWidth = imp_chn_attr_tmp->picWidth;
+    enc_attr->picHeight = imp_chn_attr_tmp->picHeight;
+    rc_attr = &channel_attr.rcAttr;
+
+
+
+
+    rc_attr->maxGop = 2 * 25 / 1;
+    SharedMem &mem = SharedMem::instance();
+    mem.readConfig();
+    encoderMode = ConfigReader::instance().getEncoderMode();
+
+    int bitrate = ConfigReader::instance().getBitrate();
+       LOG_S(INFO) << "Using Bitrate:" + bitrate;
+    if (encoderMode == ENC_RC_MODE_CBR) {
+        LOG_S(INFO) << "Using CBR mode.";
+        rc_attr->attrRcMode.rcMode = ENC_RC_MODE_CBR;
+
+        rc_attr->attrRcMode.attrH264Cbr.outBitRate = bitrate;
+
+
+        rc_attr->attrRcMode.attrH264Cbr.maxQp = 45;
+        rc_attr->attrRcMode.attrH264Cbr.minQp = 15;
+        rc_attr->attrRcMode.attrH264Cbr.iBiasLvl = 0;
+        rc_attr->attrRcMode.attrH264Cbr.frmQPStep = 3;
+        rc_attr->attrRcMode.attrH264Cbr.gopQPStep = 15;
+        rc_attr->attrRcMode.attrH264Cbr.adaptiveMode = false;
+        rc_attr->attrRcMode.attrH264Cbr.gopRelation = false;
+        
+        rc_attr->attrHSkip.hSkipAttr.skipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+        rc_attr->attrHSkip.hSkipAttr.m = 0;
+        rc_attr->attrHSkip.hSkipAttr.n = 0;
+        rc_attr->attrHSkip.hSkipAttr.maxSameSceneCnt = maxSameSceneCnt;
+        rc_attr->attrHSkip.hSkipAttr.bEnableScenecut = 0;
+        rc_attr->attrHSkip.hSkipAttr.bBlackEnhance = 0;
+        rc_attr->attrHSkip.maxHSkipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+    } else if (encoderMode == ENC_RC_MODE_VBR) {
+        LOG_S(INFO) << "Using VBR mode.";
+        rc_attr->attrRcMode.rcMode = ENC_RC_MODE_VBR;
+
+        rc_attr->attrRcMode.attrH264Vbr.maxBitRate = bitrate;
+
+
+
+        rc_attr->attrRcMode.attrH264Vbr.maxQp = 45;
+        rc_attr->attrRcMode.attrH264Vbr.minQp = 15;
+        rc_attr->attrRcMode.attrH264Vbr.staticTime = 2;
+        rc_attr->attrRcMode.attrH264Vbr.iBiasLvl = 0;
+        rc_attr->attrRcMode.attrH264Vbr.changePos = 80;
+        rc_attr->attrRcMode.attrH264Vbr.qualityLvl = quality;
+        rc_attr->attrRcMode.attrH264Vbr.frmQPStep = 3;
+        rc_attr->attrRcMode.attrH264Vbr.gopQPStep = 15;
+        rc_attr->attrRcMode.attrH264Vbr.gopRelation = false;
+
+        rc_attr->attrHSkip.hSkipAttr.skipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+        rc_attr->attrHSkip.hSkipAttr.m = 0;
+        rc_attr->attrHSkip.hSkipAttr.n = 0;
+        rc_attr->attrHSkip.hSkipAttr.maxSameSceneCnt = maxSameSceneCnt;
+        rc_attr->attrHSkip.hSkipAttr.bEnableScenecut = 0;
+        rc_attr->attrHSkip.hSkipAttr.bBlackEnhance = 0;
+        rc_attr->attrHSkip.maxHSkipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+    } else if (encoderMode == ENC_RC_MODE_SMART) {
+        LOG_S(INFO) << "Using SMART mode.";
+
+        rc_attr->attrRcMode.attrH264Smart.maxBitRate = bitrate;
+
+
+
+
+        rc_attr->attrRcMode.rcMode = ENC_RC_MODE_SMART;
+        rc_attr->attrRcMode.attrH264Smart.maxQp = 45;
+        rc_attr->attrRcMode.attrH264Smart.minQp = 15;
+        rc_attr->attrRcMode.attrH264Smart.staticTime = 2;
+        rc_attr->attrRcMode.attrH264Smart.iBiasLvl = 0;
+        rc_attr->attrRcMode.attrH264Smart.changePos = 80;
+        rc_attr->attrRcMode.attrH264Smart.qualityLvl = quality;
+        rc_attr->attrRcMode.attrH264Smart.frmQPStep = 3;
+        rc_attr->attrRcMode.attrH264Smart.gopQPStep = 15;
+        rc_attr->attrRcMode.attrH264Smart.gopRelation = false;
+        
+        rc_attr->attrHSkip.hSkipAttr.skipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N4X;
+        rc_attr->attrHSkip.hSkipAttr.m = rc_attr->maxGop - 1;
+        rc_attr->attrHSkip.hSkipAttr.n = 1;
+        rc_attr->attrHSkip.hSkipAttr.maxSameSceneCnt = maxSameSceneCnt;
+        rc_attr->attrHSkip.hSkipAttr.bEnableScenecut = false;
+        rc_attr->attrHSkip.hSkipAttr.bBlackEnhance = 0;
+        rc_attr->attrHSkip.maxHSkipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N4X;
+    } else { /* fixQp */
+        LOG_S(INFO) << "Using FIX QP mode.";
+        rc_attr->attrRcMode.rcMode = ENC_RC_MODE_FIXQP;
+        rc_attr->attrRcMode.attrH264FixQp.qp = 42;
+
+        rc_attr->attrHSkip.hSkipAttr.skipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+        rc_attr->attrHSkip.hSkipAttr.m = 0;
+        rc_attr->attrHSkip.hSkipAttr.n = 0;
+        rc_attr->attrHSkip.hSkipAttr.maxSameSceneCnt = maxSameSceneCnt;
+        rc_attr->attrHSkip.hSkipAttr.bEnableScenecut = 0;
+        rc_attr->attrHSkip.hSkipAttr.bBlackEnhance = 0;
+        rc_attr->attrHSkip.maxHSkipType = (IMPSkipType) skiptype; //IMP_Encoder_STYPE_N1X;
+    }
+                
+    ret = IMP_Encoder_CreateChn(0, &channel_attr);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_CreateChn(0) error:"<<  ret;
+        return -1;
+    }
+
+    ret = IMP_Encoder_RegisterChn(0, 0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_RegisterChn(0,0) error:"<<  ret;
+        return -1;
+    }
+
+    IMPEncoderFrmRate rate = {0};
+    ret = IMP_Encoder_GetChnFrmRate(0, &rate);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_GetChnFrmRate(0) error:"<<  ret;
+
+    }
+
+    return 0;
+}
+
+int ImpEncoder::encoder_chn_exit(int encChn) {
+    int ret;
+    IMPEncoderCHNStat chn_stat;
+    ret = IMP_Encoder_Query(encChn, &chn_stat);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_Query(" <<encChn<<" ) error:"<<  ret;
+        return -1;
+    }
+
+    if (chn_stat.registered) {
+        ret = IMP_Encoder_UnRegisterChn(encChn);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_Encoder_UnRegisterChn(" <<encChn<<") error:"<<  ret;
+            return -1;
+        }
+
+        ret = IMP_Encoder_DestroyChn(encChn);
+        if (ret < 0) {
+            LOG_S(ERROR) << "IMP_Encoder_DestroyChn(" <<encChn<<")  error:"<<  ret;
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+int ImpEncoder::sample_encoder_exit(void) {
+    int ret;
+
+    ret = encoder_chn_exit(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "encoder_chn_exit(0) error:"<<  ret;
+        return -1;
+    }
+
+    ret = encoder_chn_exit(ENC_JPEG_CHANNEL);
+    if (ret < 0) {
+        LOG_S(ERROR) << "encoder_chn_exit(ENC_JPEG_CHANNEL) error:"<<  ret;
+        return -1;
+    }
+
+    ret = IMP_Encoder_DestroyGroup(0);
+    if (ret < 0) {
+        LOG_S(ERROR) << "IMP_Encoder_DestroyGroup(0) error:"<<  ret;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+void ImpEncoder::setNightVision(bool state) {
+    IMPISPRunningMode isprunningmode;
+    IMPISPSceneMode sceneMode;
+    IMPISPColorfxMode colormode;
+    int ret;
+    if (state) {
+        isprunningmode = IMPISP_RUNNING_MODE_NIGHT;
+        sceneMode = IMPISP_SCENE_MODE_NIGHT;
+        colormode = IMPISP_COLORFX_MODE_BW;
+    } else {
+        isprunningmode = IMPISP_RUNNING_MODE_DAY;
+        sceneMode = IMPISP_SCENE_MODE_AUTO;
+        colormode = IMPISP_COLORFX_MODE_AUTO;
+    }
+    ret = IMP_ISP_Tuning_SetISPRunningMode(isprunningmode);
+    if (ret) {
+        LOG_S(ERROR) << "IMP_ISP_Tuning_SetISPRunningMode(" << isprunningmode << ") error:"<<  ret;;
+    }
+    ret = IMP_ISP_Tuning_SetSceneMode(sceneMode);
+    if (ret) {
+        LOG_S(ERROR) << "IMP_ISP_Tuning_SetSceneMode(" << sceneMode << ") error:"<<  ret;
+    }
+
+    ret = IMP_ISP_Tuning_SetColorfxMode(colormode);
+    if (ret) {
+       LOG_S(ERROR) << "IMP_ISP_Tuning_SetColorfxMode("<< colormode << ") error:"<<  ret;
+    }
+
+
+}
+
diff -Nura v4l2rtspserver_imp_tools/src/main.cpp v4l2rtspserver-master/src/main.cpp
--- v4l2rtspserver_imp_tools/src/main.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/main.cpp	2019-02-03 20:24:23.651172000 +0100
@@ -36,717 +36,553 @@
 #include "V4l2Capture.h"
 #include "V4l2Output.h"
 
+#include "ImpCapture.h"
+#include "ImpEncoder.h"
+
 #include "H264_V4l2DeviceSource.h"
 #include "ServerMediaSubsession.h"
 #include "UnicastServerMediaSubsession.h"
 #include "MulticastServerMediaSubsession.h"
-#include "TSServerMediaSubsession.h"
+#include "SegmentServerMediaSubsession.h"
 #include "HTTPServer.h"
+#include "ConfigReader.h"
 
-#ifdef HAVE_ALSA
 #include "ALSACapture.h"
-#endif
+
+#define LOGURU_IMPLEMENTATION 1
+#include "loguru.hpp"
 
 // -----------------------------------------
 //    signal handler
 // -----------------------------------------
 char quit = 0;
-void sighandler(int n)
-{ 
-	printf("SIGINT\n");
-	quit =1;
-}
+
+void sighandler(int n) {
+    LOG_S(ERROR) << "SIGINT";
+    quit = 1;
+}
+
+DetectionSaveToDiskState flushBufferToFile = BUFFERIZE;
+void sighandlerUsr1(int n) {
+   LOG_S(INFO) << "SIGUSR1";
+   if (flushBufferToFile == BUFFERIZE)
+   {
+        LOG_S(INFO) << "SIGEVENT: buffer to disk";
+        flushBufferToFile = LIVETODISK;
+   } else  {
+        LOG_S(INFO) << "SIGEVENT: End write to disk";
+        flushBufferToFile = BUFFERIZE;
+   }
 
 
+    signal(SIGUSR1, sighandlerUsr1);
+}
 // -----------------------------------------
 //    create UserAuthenticationDatabase for RTSP server
 // -----------------------------------------
-UserAuthenticationDatabase* createUserAuthenticationDatabase(const std::list<std::string> & userPasswordList, const char* realm)
-{
-	UserAuthenticationDatabase* auth = NULL;
-	if (userPasswordList.size() > 0)
-	{
-		auth = new UserAuthenticationDatabase(realm, (realm != NULL) );
-		
-		std::list<std::string>::const_iterator it;
-		for (it = userPasswordList.begin(); it != userPasswordList.end(); ++it)
-		{
-			std::istringstream is(*it);
-			std::string user;
-			getline(is, user, ':');	
-			std::string password;
-			getline(is, password);	
-			auth->addUserRecord(user.c_str(), password.c_str());
-		}
-	}
-	
-	return auth;
+UserAuthenticationDatabase *
+createUserAuthenticationDatabase(const std::list <std::string> &userPasswordList, const char *realm) {
+    UserAuthenticationDatabase *auth = NULL;
+    if (userPasswordList.size() > 0) {
+        auth = new UserAuthenticationDatabase(realm, (realm != NULL));
+
+        std::list<std::string>::const_iterator it;
+        for (it = userPasswordList.begin(); it != userPasswordList.end(); ++it) {
+            std::istringstream is(*it);
+            std::string user;
+            getline(is, user, ':');
+            std::string password;
+            getline(is, password);
+            auth->addUserRecord(user.c_str(), password.c_str());
+        }
+    }
+
+    return auth;
 }
 
 // -----------------------------------------
 //    create RTSP server
 // -----------------------------------------
-RTSPServer* createRTSPServer(UsageEnvironment& env, unsigned short rtspPort, unsigned short rtspOverHTTPPort, int timeout, unsigned int hlsSegment, const std::list<std::string> & userPasswordList, const char* realm)
-{
-	UserAuthenticationDatabase* auth = createUserAuthenticationDatabase(userPasswordList, realm);
-	RTSPServer* rtspServer = HTTPServer::createNew(env, rtspPort, auth, timeout, hlsSegment);
-	if (rtspServer != NULL)
-	{
-		// set http tunneling
-		if (rtspOverHTTPPort)
-		{
-			rtspServer->setUpTunnelingOverHTTP(rtspOverHTTPPort);
-		}
-	}
-	return rtspServer;
+RTSPServer *
+createRTSPServer(UsageEnvironment &env, unsigned short rtspPort, unsigned short rtspOverHTTPPort, int timeout,
+                 unsigned int hlsSegment, const std::list <std::string> &userPasswordList, const char *realm) {
+    UserAuthenticationDatabase *auth = createUserAuthenticationDatabase(userPasswordList, realm);
+    RTSPServer *rtspServer = HTTPServer::createNew(env, rtspPort, auth, timeout, hlsSegment);
+    if (rtspServer != NULL) {
+        // set http tunneling
+        if (rtspOverHTTPPort) {
+            rtspServer->setUpTunnelingOverHTTP(rtspOverHTTPPort);
+        }
+    }
+    return rtspServer;
 }
 
 
 // -----------------------------------------
 //    create FramedSource server
 // -----------------------------------------
-FramedSource* createFramedSource(UsageEnvironment* env, int format, DeviceInterface* videoCapture, int outfd, int queueSize, bool useThread, bool repeatConfig)
-{
-	FramedSource* source = NULL;
-	if (format == V4L2_PIX_FMT_H264)
-	{
-		source = H264_V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread, repeatConfig, false);
-	}
-	else if (format == V4L2_PIX_FMT_HEVC)
-	{
-		source = H265_V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread, repeatConfig, false);
-	}
-	else 
-	{
-		source = V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread);
-	}
-	return source;
+FramedSource *
+createFramedSource(UsageEnvironment *env, int format, DeviceInterface *videoCapture, int outfd, int queueSize,
+                   bool useThread, bool repeatConfig, MPEG2TransportStreamFromESSource *muxer) {
+    bool muxTS = (muxer != NULL);
+    FramedSource *source = NULL;
+    if (format == V4L2_PIX_FMT_H264) {
+        source = H264_V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread, repeatConfig, muxTS);
+        if (muxTS) {
+            muxer->addNewVideoSource(source, 5);
+            source = muxer;
+        }
+    } else if (format == V4L2_PIX_FMT_HEVC) {
+        source = H265_V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread, repeatConfig, muxTS);
+        if (muxTS) {
+            muxer->addNewVideoSource(source, 6);
+            source = muxer;
+        }
+    } else {
+        source = V4L2DeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread);
+        //source = ImpJpegDeviceSource::createNew(*env, videoCapture, outfd, queueSize, useThread);
+    }
+    return source;
 }
-	
+
 // -----------------------------------------
 //    add an RTSP session
 // -----------------------------------------
-int addSession(RTSPServer* rtspServer, const std::string & sessionName, const std::list<ServerMediaSubsession*> & subSession)
-{
-	int nbSubsession = 0;
-	if (subSession.empty() == false)
-	{
-		UsageEnvironment& env(rtspServer->envir());
-		ServerMediaSession* sms = ServerMediaSession::createNew(env, sessionName.c_str());
-		if (sms != NULL)
-		{
-			std::list<ServerMediaSubsession*>::const_iterator subIt;
-			for (subIt = subSession.begin(); subIt != subSession.end(); ++subIt)
-			{
-				sms->addSubsession(*subIt);
-				nbSubsession++;
-			}
-			
-			rtspServer->addServerMediaSession(sms);
-
-			char* url = rtspServer->rtspURL(sms);
-			if (url != NULL)
-			{
-				LOG(NOTICE) << "Play this stream using the URL \"" << url << "\"";
-				delete[] url;			
-			}
-		}
-	}
-	return nbSubsession;
+int addSession(RTSPServer *rtspServer, const std::string &sessionName,
+               const std::list<ServerMediaSubsession *> &subSession) {
+    int nbSubsession = 0;
+    if (subSession.empty() == false) {
+        UsageEnvironment &env(rtspServer->envir());
+        ServerMediaSession *sms = ServerMediaSession::createNew(env, sessionName.c_str());
+        if (sms != NULL) {
+            std::list<ServerMediaSubsession *>::const_iterator subIt;
+            for (subIt = subSession.begin(); subIt != subSession.end(); ++subIt) {
+                sms->addSubsession(*subIt);
+                nbSubsession++;
+            }
+
+            rtspServer->addServerMediaSession(sms);
+
+            char *url = rtspServer->rtspURL(sms);
+            if (url != NULL) {
+                LOG_S(INFO) << "Play this stream using the URL \"" << url << "\"" ;
+                delete[] url;
+            }
+        }
+    }
+    return nbSubsession;
 }
 
 // -----------------------------------------
 //    convert V4L2 pix format to RTP mime
 // -----------------------------------------
-std::string getVideoRtpFormat(int format)
-{
-	std::string rtpFormat;
-	switch(format)
-	{	
-		case V4L2_PIX_FMT_HEVC : rtpFormat = "video/H265"; break;
-		case V4L2_PIX_FMT_H264 : rtpFormat = "video/H264"; break;
-		case V4L2_PIX_FMT_MJPEG: rtpFormat = "video/JPEG"; break;
-		case V4L2_PIX_FMT_JPEG : rtpFormat = "video/JPEG"; break;
-		case V4L2_PIX_FMT_VP8  : rtpFormat = "video/VP8" ; break;
-		case V4L2_PIX_FMT_VP9  : rtpFormat = "video/VP9" ; break;
-		case V4L2_PIX_FMT_YUYV : rtpFormat = "video/RAW" ; break;
-	}
-	
-	return rtpFormat;
+std::string getRtpFormat(int format, bool muxTS) {
+    std::string rtpFormat;
+    if (muxTS) {
+        rtpFormat = "video/MP2T";
+    } else {
+        switch (format) {
+            case V4L2_PIX_FMT_HEVC :
+                rtpFormat = "video/H265";
+                break;
+            case V4L2_PIX_FMT_H264 :
+                rtpFormat = "video/H264";
+                break;
+            case V4L2_PIX_FMT_MJPEG:
+                rtpFormat = "video/JPEG";
+                break;
+            case V4L2_PIX_FMT_JPEG :
+                rtpFormat = "video/JPEG";
+                break;
+            case V4L2_PIX_FMT_VP8  :
+                rtpFormat = "video/VP8";
+                break;
+            case V4L2_PIX_FMT_VP9  :
+                rtpFormat = "video/VP9";
+                break;
+        }
+    }
+
+    return rtpFormat;
 }
 
 // -----------------------------------------
 //    convert string video format to fourcc 
 // -----------------------------------------
-int decodeVideoFormat(const char* fmt)
-{
-	char fourcc[4];
-	memset(&fourcc, 0, sizeof(fourcc));
-	if (fmt != NULL)
-	{
-		strncpy(fourcc, fmt, 4);	
-	}
-	return v4l2_fourcc(fourcc[0], fourcc[1], fourcc[2], fourcc[3]);
+int decodeVideoFormat(const char *fmt) {
+    char fourcc[4];
+    memset(&fourcc, 0, sizeof(fourcc));
+    if (fmt != NULL) {
+        strncpy(fourcc, fmt, 4);
+    }
+    return v4l2_fourcc(fourcc[0], fourcc[1], fourcc[2], fourcc[3]);
 }
 
-// -----------------------------------------
-//    convert string audio format to pcm
-// -----------------------------------------
-#ifdef HAVE_ALSA
-snd_pcm_format_t decodeAudioFormat(const std::string& fmt)
-{
-	snd_pcm_format_t audioFmt = SND_PCM_FORMAT_UNKNOWN;
-	if (fmt == "S16_BE") {
-		audioFmt = SND_PCM_FORMAT_S16_BE;
-	} else if (fmt == "S16_LE") {
-		audioFmt = SND_PCM_FORMAT_S16_LE;
-	} else if (fmt == "S24_BE") {
-		audioFmt = SND_PCM_FORMAT_S24_BE;
-	} else if (fmt == "S24_LE") {
-		audioFmt = SND_PCM_FORMAT_S24_LE;
-	} else if (fmt == "S32_BE") {
-		audioFmt = SND_PCM_FORMAT_S32_BE;
-	} else if (fmt == "S32_LE") {
-		audioFmt = SND_PCM_FORMAT_S32_LE;
-	} else if (fmt == "ALAW") {
-		audioFmt = SND_PCM_FORMAT_A_LAW;
-	} else if (fmt == "MULAW") {
-		audioFmt = SND_PCM_FORMAT_MU_LAW;
-	} else if (fmt == "S8") {
-		audioFmt = SND_PCM_FORMAT_S8;
-	}
-	return audioFmt;
-}
-std::string getAudioRtpFormat(snd_pcm_format_t format, int sampleRate, int channels)
+
+//"EncodeFormat:InSampleRate:OutSampleRate"
+void decodeEncodeFormat(const std::string &in, audioencoding &format, int &inAudioFreq, int &outAudioFreq )
 {
-	std::ostringstream os;
-	os << "audio/";
-	switch (format) {
-		case SND_PCM_FORMAT_A_LAW:
-			os << "PCMA";
-			break;
-		case SND_PCM_FORMAT_MU_LAW:
-			os << "PCMU";
-			break;
-		case SND_PCM_FORMAT_S8:
-			os << "L8";
-			break;
-		case SND_PCM_FORMAT_S24_BE:
-		case SND_PCM_FORMAT_S24_LE:
-			os << "L24";
-			break;
-		case SND_PCM_FORMAT_S32_BE:
-		case SND_PCM_FORMAT_S32_LE:
-			os << "L32";
-			break;
-		default:
-			os << "L16";
-			break;
-	}
-	os << "/" << sampleRate << "/" << channels;
-	return os.str();
+  std::istringstream is(in);
+  std::string form("MP3");
+  getline(is, form, ':');
+  std::string inSampleRate("44100");
+  getline(is, inSampleRate, ':');
+  std::string outSampleRate("44100");
+  getline(is, outSampleRate, ':');
+
+  if (!form.empty()) {
+        if (form.find("OPUS") ==0)
+        {
+            format = ENCODE_OPUS;
+        }
+        else if (form.find("PCMU") ==0)
+        {
+            format = ENCODE_ULAW;
+        }
+        else if (form.find("PCM") ==0)
+        {
+            format = ENCODE_PCM;
+        }
+        else {
+            format = ENCODE_MP3;
+        }
+    }
+
+    if (inSampleRate.length() > 0)
+        inAudioFreq =  std::stoi(inSampleRate);
+
+    if (outSampleRate.length() > 0)
+        outAudioFreq =  std::stoi(outSampleRate);
 }
-#endif
+
+
 
 // -------------------------------------------------------
 //    decode multicast url <group>:<rtp_port>:<rtcp_port>
 // -------------------------------------------------------
-void decodeMulticastUrl(const std::string & maddr, in_addr & destinationAddress, unsigned short & rtpPortNum, unsigned short & rtcpPortNum)
-{
-	std::istringstream is(maddr);
-	std::string ip;
-	getline(is, ip, ':');						
-	if (!ip.empty())
-	{
-		destinationAddress.s_addr = inet_addr(ip.c_str());
-	}						
-	
-	std::string port;
-	getline(is, port, ':');						
-	rtpPortNum = 20000;
-	if (!port.empty())
-	{
-		rtpPortNum = atoi(port.c_str());
-	}	
-	rtcpPortNum = rtpPortNum+1;
+void decodeMulticastUrl(const std::string &maddr, in_addr &destinationAddress, unsigned short &rtpPortNum,
+                        unsigned short &rtcpPortNum) {
+    std::istringstream is(maddr);
+    std::string ip;
+    getline(is, ip, ':');
+    if (!ip.empty()) {
+        destinationAddress.s_addr = inet_addr(ip.c_str());
+    }
+
+    std::string port;
+    getline(is, port, ':');
+    rtpPortNum = 20000;
+    if (!port.empty()) {
+        rtpPortNum = atoi(port.c_str());
+    }
+    rtcpPortNum = rtpPortNum + 1;
 }
 
 // -------------------------------------------------------
 //    split video,audio device
 // -------------------------------------------------------
-void decodeDevice(const std::string & device, std::string & videoDev, std::string & audioDev)
-{
-	std::istringstream is(device);
-	getline(is, videoDev, ',');						
-	getline(is, audioDev);						
+void decodeDevice(const std::string &device, std::string &videoDev, std::string &audioDev) {
+    std::istringstream is(device);
+    getline(is, videoDev, ',');
+    getline(is, audioDev);
 }
 
-std::string getDeviceName(const std::string & devicePath)
-{
-	std::string deviceName(devicePath);
-	size_t pos = deviceName.find_last_of('/');
-	if (pos != std::string::npos) {
-		deviceName.erase(0,pos+1);
-	}
-	return deviceName;
-}
-
-
-/* ---------------------------------------------------------------------------
-**  get a "deviceid" from uevent sys file
-** -------------------------------------------------------------------------*/
-#ifdef HAVE_ALSA	
-std::string getDeviceId(const std::string& evt) {
-    std::string deviceid;
-    std::istringstream f(evt);
-    std::string key;
-    while (getline(f, key, '=')) {
-            std::string value;
-	    if (getline(f, value)) {
-		    if ( (key =="PRODUCT") || (key == "PCI_SUBSYS_ID") ) {
-			    deviceid = value;
-			    break;
-		    }
-	    }
-    }
-    return deviceid;
-}
-
-std::string  getV4l2Alsa(const std::string& v4l2device) {
-	std::string audioDevice(v4l2device);
-	
-	std::map<std::string,std::string> videodevices;
-	std::string video4linuxPath("/sys/class/video4linux");
-	DIR *dp = opendir(video4linuxPath.c_str());
-	if (dp != NULL) {
-		struct dirent *entry = NULL;
-		while((entry = readdir(dp))) {
-			std::string devicename;
-			std::string deviceid;
-			if (strstr(entry->d_name,"video") == entry->d_name) {
-				std::string ueventPath(video4linuxPath);
-				ueventPath.append("/").append(entry->d_name).append("/device/uevent");
-				std::ifstream ifsd(ueventPath.c_str());
-				deviceid = std::string(std::istreambuf_iterator<char>{ifsd}, {});
-				deviceid.erase(deviceid.find_last_not_of("\n")+1);
-			}
-
-			if (!deviceid.empty()) {
-				videodevices[entry->d_name] = getDeviceId(deviceid);
-			}
-		}
-		closedir(dp);
-	}
-
-	std::map<std::string,std::string> audiodevices;
-	int rcard = -1;
-	while ( (snd_card_next(&rcard) == 0) && (rcard>=0) ) {
-		void **hints = NULL;
-		if (snd_device_name_hint(rcard, "pcm", &hints) >= 0) {
-			void **str = hints;
-			while (*str) {				
-				std::ostringstream os;
-				os << "/sys/class/sound/card" << rcard << "/device/uevent";
-
-				std::ifstream ifs(os.str().c_str());
-				std::string deviceid = std::string(std::istreambuf_iterator<char>{ifs}, {});
-				deviceid.erase(deviceid.find_last_not_of("\n")+1);
-				deviceid = getDeviceId(deviceid);
-
-				if (!deviceid.empty()) {
-					if (audiodevices.find(deviceid) == audiodevices.end()) {
-						std::string audioname = snd_device_name_get_hint(*str, "NAME");
-						audiodevices[deviceid] = audioname;
-					}
-				}
-
-				str++;
-			}
-
-			snd_device_name_free_hint(hints);
-		}
-	}
-
-	auto deviceId  = videodevices.find(getDeviceName(v4l2device));
-	if (deviceId != videodevices.end()) {
-		auto audioDeviceIt = audiodevices.find(deviceId->second);
-		
-		if (audioDeviceIt != audiodevices.end()) {
-			audioDevice = audioDeviceIt->second;
-			std::cout <<  v4l2device << "=>" << audioDevice << std::endl;			
-		}
-	}
-	
-	
-	return audioDevice;
+std::string getDeviceName(const std::string &devicePath) {
+    std::string deviceName(devicePath);
+    size_t pos = deviceName.find_last_of('/');
+    if (pos != std::string::npos) {
+        deviceName.erase(0, pos + 1);
+    }
+    return deviceName;
 }
-#endif
+
+
 
 // -----------------------------------------
 //    entry point
 // -----------------------------------------
-int main(int argc, char** argv) 
-{
-	// default parameters
-	const char *dev_name = "/dev/video0,/dev/video0";	
-	unsigned int format = ~0;
-	std::list<unsigned int> videoformatList;
-	int width = 0;
-	int height = 0;
-	int queueSize = 10;
-	int fps = 25;
-	unsigned short rtspPort = 8554;
-	unsigned short rtspOverHTTPPort = 0;
-	bool multicast = false;
-	int verbose = 0;
-	std::string outputFile;
-	V4l2Access::IoType ioTypeIn  = V4l2Access::IOTYPE_MMAP;
-	V4l2Access::IoType ioTypeOut = V4l2Access::IOTYPE_MMAP;
-	std::string url = "unicast";
-	std::string murl = "multicast";
-	std::string tsurl = "ts";
-	bool useThread = true;
-	std::string maddr;
-	bool repeatConfig = true;
-	int timeout = 65;
-	int defaultHlsSegment = 2;
-	unsigned int hlsSegment = 0;
-	const char* realm = NULL;
-	std::list<std::string> userPasswordList;
-#ifdef HAVE_ALSA	
-	int audioFreq = 44100;
-	int audioNbChannels = 2;
-	std::list<snd_pcm_format_t> audioFmtList;
-	snd_pcm_format_t audioFmt = SND_PCM_FORMAT_UNKNOWN;
-#endif	
-	const char* defaultPort = getenv("PORT");
-	if (defaultPort != NULL) {
-		rtspPort = atoi(defaultPort);
-	}
-
-	// decode parameters
-	int c = 0;     
-	while ((c = getopt (argc, argv, "v::Q:O:" "I:P:p:m:u:M:ct:S::" "R:U:" "rwsf::F:W:H:G:" "A:C:a:" "Vh")) != -1)
-	{
-		switch (c)
-		{
-			case 'v':	verbose    = 1; if (optarg && *optarg=='v') verbose++;  break;
-			case 'Q':	queueSize  = atoi(optarg); break;
-			case 'O':	outputFile = optarg; break;
-			
-			// RTSP/RTP
-			case 'I':       ReceivingInterfaceAddr  = inet_addr(optarg); break;
-			case 'P':	rtspPort                = atoi(optarg); break;
-			case 'p':	rtspOverHTTPPort        = atoi(optarg); break;
-			case 'u':	url                     = optarg; break;
-			case 'm':	multicast = true; murl  = optarg; break;
-			case 'M':	multicast = true; maddr = optarg; break;
-			case 'c':	repeatConfig            = false; break;
-			case 't':	timeout                 = atoi(optarg); break;
-			case 'S':	hlsSegment              = optarg ? atoi(optarg) : defaultHlsSegment; break;
-			
-			// users
-			case 'R':       realm                   = optarg; break;
-			case 'U':       userPasswordList.push_back(optarg); break;
-			
-			// V4L2
-			case 'r':	ioTypeIn  = V4l2Access::IOTYPE_READWRITE; break;
-			case 'w':	ioTypeOut = V4l2Access::IOTYPE_READWRITE; break;	
-			case 's':	useThread =  false; break;
-			case 'f':	format    = decodeVideoFormat(optarg); if (format) {videoformatList.push_back(format);};  break;
-			case 'F':	fps       = atoi(optarg); break;
-			case 'W':	width     = atoi(optarg); break;
-			case 'H':	height    = atoi(optarg); break;
-			case 'G':   sscanf(optarg,"%dx%dx%d", &width, &height, &fps); break;
-			
-			// ALSA
-#ifdef HAVE_ALSA	
-			case 'A':	audioFreq = atoi(optarg); break;
-			case 'C':	audioNbChannels = atoi(optarg); break;
-			case 'a':	audioFmt = decodeAudioFormat(optarg); if (audioFmt != SND_PCM_FORMAT_UNKNOWN) {audioFmtList.push_back(audioFmt);} ; break;
-#endif			
-			
-			// version
-			case 'V':	
-				std::cout << VERSION << std::endl;
-				exit(0);			
-			break;
-			
-			// help
-			case 'h':
-			default:
-			{
-				std::cout << argv[0] << " [-v[v]] [-Q queueSize] [-O file]"                                        << std::endl;
-				std::cout << "\t          [-I interface] [-P RTSP port] [-p RTSP/HTTP port] [-m multicast url] [-u unicast url] [-M multicast addr] [-c] [-t timeout] [-T] [-S[duration]]" << std::endl;
-				std::cout << "\t          [-r] [-w] [-s] [-f[format] [-W width] [-H height] [-F fps] [device] [device]"                        << std::endl;
-				std::cout << "\t -v               : verbose"                                                                                          << std::endl;
-				std::cout << "\t -vv              : very verbose"                                                                                     << std::endl;
-				std::cout << "\t -Q <length>      : Number of frame queue  (default "<< queueSize << ")"                                              << std::endl;
-				std::cout << "\t -O <output>      : Copy captured frame to a file or a V4L2 device"                                                   << std::endl;
-				
-				std::cout << "\t RTSP/RTP options"                                                                                           << std::endl;
-				std::cout << "\t -I <addr>        : RTSP interface (default autodetect)"                                                              << std::endl;
-				std::cout << "\t -P <port>        : RTSP port (default "<< rtspPort << ")"                                                            << std::endl;
-				std::cout << "\t -p <port>        : RTSP over HTTP port (default "<< rtspOverHTTPPort << ")"                                          << std::endl;
-				std::cout << "\t -U <user>:<pass> : RTSP user and password"                                                                    << std::endl;
-				std::cout << "\t -R <realm>       : use md5 password 'md5(<username>:<realm>:<password>')"                                            << std::endl;
-				std::cout << "\t -u <url>         : unicast url (default " << url << ")"                                                              << std::endl;
-				std::cout << "\t -m <url>         : multicast url (default " << murl << ")"                                                           << std::endl;
-				std::cout << "\t -M <addr>        : multicast group:port (default is random_address:20000)"                                           << std::endl;
-				std::cout << "\t -c               : don't repeat config (default repeat config before IDR frame)"                                     << std::endl;
-				std::cout << "\t -t <timeout>     : RTCP expiration timeout in seconds (default " << timeout << ")"                                   << std::endl;
-				std::cout << "\t -S[<duration>]   : enable HLS & MPEG-DASH with segment duration  in seconds (default " << defaultHlsSegment << ")" << std::endl;
-				
-				std::cout << "\t V4L2 options"                                                                                               << std::endl;
-				std::cout << "\t -r               : V4L2 capture using read interface (default use memory mapped buffers)"                            << std::endl;
-				std::cout << "\t -w               : V4L2 capture using write interface (default use memory mapped buffers)"                           << std::endl;
-				std::cout << "\t -s               : V4L2 capture using live555 mainloop (default use a reader thread)"                                << std::endl;
-				std::cout << "\t -f               : V4L2 capture using current capture format (-W,-H,-F are ignored)"                                 << std::endl;
-				std::cout << "\t -f<format>       : V4L2 capture using format (-W,-H,-F are used)"                                                    << std::endl;
-				std::cout << "\t -W <width>       : V4L2 capture width (default "<< width << ")"                                                      << std::endl;
-				std::cout << "\t -H <height>      : V4L2 capture height (default "<< height << ")"                                                    << std::endl;
-				std::cout << "\t -F <fps>         : V4L2 capture framerate (default "<< fps << ")"                                                    << std::endl;
-				std::cout << "\t -G <w>x<h>[x<f>] : V4L2 capture format (default "<< width << "x" << height << "x" << fps << ")"  << std::endl;
-				
-#ifdef HAVE_ALSA	
-				std::cout << "\t ALSA options"                                                                                               << std::endl;
-				std::cout << "\t -A freq          : ALSA capture frequency and channel (default " << audioFreq << ")"                                << std::endl;
-				std::cout << "\t -C channels      : ALSA capture channels (default " << audioNbChannels << ")"                                       << std::endl;
-				std::cout << "\t -a fmt           : ALSA capture audio format (default S16_BE)"                                                      << std::endl;
-#endif
-				
-				std::cout << "\t Devices :"                                                                                                    << std::endl;
-				std::cout << "\t [V4L2 device][,ALSA device] : V4L2 capture device or/and ALSA capture device (default "<< dev_name << ")"     << std::endl;
-				exit(0);
-			}
-		}
-	}
-	std::list<std::string> devList;
-	while (optind<argc)
-	{
-		devList.push_back(argv[optind]);
-		optind++;
-	}
-	if (devList.empty())
-	{
-		devList.push_back(dev_name);
-	}
-	
-	// default format tries
-	if ((videoformatList.empty()) && (format!=0)) {
-		videoformatList.push_back(V4L2_PIX_FMT_H264);
-		videoformatList.push_back(V4L2_PIX_FMT_MJPEG);
-	}
-
-#ifdef HAVE_ALSA	
-	// default audio format tries
-	if (audioFmtList.empty()) {
-		audioFmtList.push_back(SND_PCM_FORMAT_S16_LE);
-		audioFmtList.push_back(SND_PCM_FORMAT_S16_BE);
-	}
-#endif	
-	
-	// init logger
-	initLogger(verbose);
-     
-	// create live555 environment
-	TaskScheduler* scheduler = BasicTaskScheduler::createNew();
-	UsageEnvironment* env = BasicUsageEnvironment::createNew(*scheduler);	
-
-	// split multicast info
-	struct in_addr destinationAddress;
-	destinationAddress.s_addr = chooseRandomIPv4SSMAddress(*env);
-	unsigned short rtpPortNum = 20000;
-	unsigned short rtcpPortNum = rtpPortNum+1;
-	unsigned char ttl = 5;
-	decodeMulticastUrl(maddr, destinationAddress, rtpPortNum, rtcpPortNum);	
-	
-	// create RTSP server
-	RTSPServer* rtspServer = createRTSPServer(*env, rtspPort, rtspOverHTTPPort, timeout, hlsSegment, userPasswordList, realm);
-	if (rtspServer == NULL) 
-	{
-		LOG(ERROR) << "Failed to create RTSP server: " << env->getResultMsg();
-	}
-	else
-	{			
-		V4l2Output* out = NULL;
-		int nbSource = 0;
-		std::list<std::string>::iterator devIt;
-		for ( devIt=devList.begin() ; devIt!=devList.end() ; ++devIt)
-		{
-			std::string deviceName(*devIt);
-			
-			std::string videoDev;
-			std::string audioDev;
-			decodeDevice(deviceName, videoDev, audioDev);
-			
-			std::string baseUrl;
-			if (devList.size() > 1)
-			{
-				baseUrl = getDeviceName(videoDev);
-				baseUrl.append("/");
-			}	
-			StreamReplicator* videoReplicator = NULL;
-			std::string rtpFormat;
-			if (!videoDev.empty())
-			{
-				// Init video capture
-				LOG(NOTICE) << "Create V4L2 Source..." << videoDev;
-				
-				V4L2DeviceParameters param(videoDev.c_str(), videoformatList, width, height, fps, verbose);
-				V4l2Capture* videoCapture = V4l2Capture::create(param, ioTypeIn);
-				if (videoCapture)
-				{
-					int outfd = -1;
-					
-					if (!outputFile.empty())
-					{
-						V4L2DeviceParameters outparam(outputFile.c_str(), videoCapture->getFormat(), videoCapture->getWidth(), videoCapture->getHeight(), 0,verbose);
-						out = V4l2Output::create(outparam, ioTypeOut);
-						if (out != NULL)
-						{
-							outfd = out->getFd();
-						}
-					}
-					
-					rtpFormat.assign(getVideoRtpFormat(videoCapture->getFormat()));
-					if (rtpFormat.empty()) {
-						LOG(FATAL) << "No Streaming format supported for device " << videoDev;
-						delete videoCapture;
-					} else {
-						LOG(NOTICE) << "Create Source ..." << videoDev;
-						FramedSource* videoSource = createFramedSource(env, videoCapture->getFormat(), new DeviceCaptureAccess<V4l2Capture>(videoCapture), outfd, queueSize, useThread, repeatConfig);
-						if (videoSource == NULL) 
-						{
-							LOG(FATAL) << "Unable to create source for device " << videoDev;
-							delete videoCapture;
-						}
-						else
-						{	
-							// extend buffer size if needed
-							if (videoCapture->getBufferSize() > OutPacketBuffer::maxSize)
-							{
-								OutPacketBuffer::maxSize = videoCapture->getBufferSize();
-							}
-							videoReplicator = StreamReplicator::createNew(*env, videoSource, false);
-						}
-					}
-				}
-			}
-					
-			// Init Audio Capture
-			StreamReplicator* audioReplicator = NULL;
-			std::string rtpAudioFormat;
-#ifdef HAVE_ALSA
-			if (!audioDev.empty())
-			{
-				// find the ALSA device associated with the V4L2 device
-				audioDev = getV4l2Alsa(audioDev);
-			
-				// Init audio capture
-				LOG(NOTICE) << "Create ALSA Source..." << audioDev;
-				
-				ALSACaptureParameters param(audioDev.c_str(), audioFmtList, audioFreq, audioNbChannels, verbose);
-				ALSACapture* audioCapture = ALSACapture::createNew(param);
-				if (audioCapture) 
-				{
-					FramedSource* audioSource = V4L2DeviceSource::createNew(*env, new DeviceCaptureAccess<ALSACapture>(audioCapture), -1, queueSize, useThread);
-					if (audioSource == NULL) 
-					{
-						LOG(FATAL) << "Unable to create source for device " << audioDev;
-						delete audioCapture;
-					}
-					else
-					{
-						rtpAudioFormat.assign(getAudioRtpFormat(audioCapture->getFormat(),audioCapture->getSampleRate(), audioCapture->getChannels()));
-						
-						// extend buffer size if needed
-						if (audioCapture->getBufferSize() > OutPacketBuffer::maxSize)
-						{
-							OutPacketBuffer::maxSize = audioCapture->getBufferSize();
-						}						
-						audioReplicator = StreamReplicator::createNew(*env, audioSource, false);
-					}
-				}
-			}		
-#endif
-					
-										
-			// Create Multicast Session
-			if (multicast)						
-			{		
-				LOG(NOTICE) << "RTP  address " << inet_ntoa(destinationAddress) << ":" << rtpPortNum;
-				LOG(NOTICE) << "RTCP address " << inet_ntoa(destinationAddress) << ":" << rtcpPortNum;
-			
-				std::list<ServerMediaSubsession*> subSession;						
-				if (videoReplicator)
-				{
-					subSession.push_back(MulticastServerMediaSubsession::createNew(*env, destinationAddress, Port(rtpPortNum), Port(rtcpPortNum), ttl, videoReplicator, rtpFormat));					
-					// increment ports for next sessions
-					rtpPortNum+=2;
-					rtcpPortNum+=2;
-				}
-				
-				if (audioReplicator)
-				{
-					subSession.push_back(MulticastServerMediaSubsession::createNew(*env, destinationAddress, Port(rtpPortNum), Port(rtcpPortNum), ttl, audioReplicator, rtpAudioFormat));				
-					
-					// increment ports for next sessions
-					rtpPortNum+=2;
-					rtcpPortNum+=2;
-				}
-				nbSource += addSession(rtspServer, baseUrl+murl, subSession);																
-			}
-			
-			// Create HLS Session					
-			if (hlsSegment > 0)
-			{
-				std::list<ServerMediaSubsession*> subSession;
-				if (videoReplicator)
-				{
-					subSession.push_back(TSServerMediaSubsession::createNew(*env, videoReplicator, rtpFormat, hlsSegment));				
-				}
-				nbSource += addSession(rtspServer, baseUrl+tsurl, subSession);
-				
-				struct in_addr ip;
-				ip.s_addr = ourIPAddress(*env);
-				LOG(NOTICE) << "HLS       http://" << inet_ntoa(ip) << ":" << rtspPort << "/" << baseUrl+tsurl << ".m3u8";
-				LOG(NOTICE) << "MPEG-DASH http://" << inet_ntoa(ip) << ":" << rtspPort << "/" << baseUrl+tsurl << ".mpd";
-			}
-			
-			// Create Unicast Session					
-			std::list<ServerMediaSubsession*> subSession;
-			if (videoReplicator)
-			{
-				subSession.push_back(UnicastServerMediaSubsession::createNew(*env, videoReplicator, rtpFormat));				
-			}
-			if (audioReplicator)
-			{
-				subSession.push_back(UnicastServerMediaSubsession::createNew(*env, audioReplicator, rtpAudioFormat));				
-			}
-			nbSource += addSession(rtspServer, baseUrl+url, subSession);				
-		}
-
-		if (nbSource>0)
-		{
-			// main loop
-			signal(SIGINT,sighandler);
-			env->taskScheduler().doEventLoop(&quit); 
-			LOG(NOTICE) << "Exiting....";			
-		}
-		
-		Medium::close(rtspServer);
-
-		if (out)
-		{
-			delete out;
-		}
-	}
-	
-	env->reclaim();
-	delete scheduler;	
-	
-	return 0;
+int main(int argc, char **argv, char**environ) {
+    // default parameters
+
+    ConfigReader::instance().readConfig();
+
+
+    bool disableAudio = ! ConfigReader::instance().getAudioEnabled();
+    bool alsaAudio = false;
+    int format = V4L2_PIX_FMT_H264;
+    int width = ConfigReader::instance().getWidth();
+    int height = ConfigReader::instance().getHeight();
+    int bitrate = ConfigReader::instance().getBitrate();
+    //loguru::g_stderr_verbosity = 10;
+    int queueSize = 10;
+    int fps = ConfigReader::instance().getFps();
+    int rcmode = ENC_RC_MODE_VBR;
+    unsigned short rtspPort = ConfigReader::instance().getRtspPort();;
+    unsigned short rtspOverHTTPPort = 0;
+    bool multicast = false;
+    int verbose = 0;
+    std::string outputFile;
+    std::string url = ConfigReader::instance().getRtspUrl();
+    bool useThread = true;
+    std::string maddr;
+    bool repeatConfig = true;
+    int timeout = 65;
+    bool muxTS = false;
+    unsigned int hlsSegment = 0;
+    const char *realm = NULL;
+    std::list <std::string> userPasswordList;
+    int inAudioFreq = 44100;
+    int outAudioFreq = 44100;
+    audioencoding encode = ENCODE_MP3;
+
+
+    const char *defaultPort = getenv("PORT");
+    if (defaultPort != NULL) {
+        rtspPort = atoi(defaultPort);
+    }
+    loguru::set_thread_name("main thread");
+    // decode parameters
+
+
+
+
+
+
+    // create live555 environment
+    TaskScheduler *scheduler = BasicTaskScheduler::createNew();
+    UsageEnvironment *env = BasicUsageEnvironment::createNew(*scheduler);
+
+    // split multicast info
+    struct in_addr destinationAddress;
+    destinationAddress.s_addr = chooseRandomIPv4SSMAddress(*env);
+    unsigned short rtpPortNum = 20000;
+    unsigned short rtcpPortNum = rtpPortNum + 1;
+    unsigned char ttl = 5;
+    decodeMulticastUrl(maddr, destinationAddress, rtpPortNum, rtcpPortNum);
+
+    // create RTSP server
+    RTSPServer *rtspServer = createRTSPServer(*env, rtspPort, rtspOverHTTPPort, timeout, hlsSegment, userPasswordList,
+                                              realm);
+    if (rtspServer == NULL) {
+        LOG_S(ERROR) << "Failed to create RTSP server: " << env->getResultMsg();
+    } else {
+        V4l2Output *out = NULL;
+        int nbSource = 0;
+        std::string baseUrl;
+
+        MPEG2TransportStreamFromESSource *muxer = NULL;
+        if (muxTS) {
+            muxer = MPEG2TransportStreamFromESSource::createNew(*env);
+        }
+        StreamReplicator *videoReplicator = NULL;
+        std::string rtpFormat;
+
+
+        int outfd = -1;
+        //int videoFormat = V4L2_PIX_FMT_MJPEG;
+        int videoFormat = format;
+
+
+        impParams params;
+        params.width = width;
+        params.height = height;
+        params.rcmode = rcmode;
+        
+        if (videoFormat == V4L2_PIX_FMT_MJPEG) {
+            params.mode = IMP_MODE_JPEG;
+            OutPacketBuffer::maxSize = 250000;
+
+
+        } else if (videoFormat == V4L2_PIX_FMT_H264) {
+            params.mode = IMP_MODE_H264_SNAP;
+            MPEG2TransportStreamFromESSource::maxInputESFrameSize += 4820;
+            OutPacketBuffer::maxSize = 600000;
+
+        } else {
+            LOG_S(FATAL) << "Unrecognized Format ";
+            exit(0);
+        }
+        if(width == 1920 && height == 1080){
+            OutPacketBuffer::maxSize = 600000;
+        } else  if(width == 1600 && height == 900){
+            OutPacketBuffer::maxSize = 450000;
+        }
+
+        params.framerate = fps;
+
+        // this is the default values, the real values are read from sharedmemory when
+        // initializing the video ...
+        //params.bitrate = (double)2000.0 * (width * height) / (1280 * 720);;
+        params.bitrate = bitrate;
+
+
+        ImpCapture *impCapture = new ImpCapture(params);
+
+        if (!outputFile.empty()) {
+            if(strcmp(outputFile.c_str(),"memory")==0){
+                outfd = -2;
+            }else{
+                outfd = (int)fopen(outputFile.c_str(),"w");
+            }
+        }
+
+
+
+        rtpFormat.assign(getRtpFormat(videoFormat, muxTS));
+        FramedSource *videoSource = createFramedSource(env, videoFormat,
+                                                       new DeviceCaptureAccess<ImpCapture>(impCapture),
+                                                       outfd, queueSize, useThread, repeatConfig, muxer);
+        if (videoSource == NULL) {
+            LOG_S(FATAL) << "Unable to create source for device ";
+        } else {
+            // extend buffer size if needed
+            /*
+            if (videoCapture->getBufferSize() > OutPacketBuffer::maxSize) {
+                OutPacketBuffer::maxSize = videoCapture->getBufferSize();
+            }
+             */
+            videoReplicator = StreamReplicator::createNew(*env, videoSource, false);
+        }
+
+
+
+        // Init Audio Capture
+        StreamReplicator *audioReplicator = NULL;
+        std::string rtpAudioFormat;
+        std::string audioDev="/dev/dsp";
+        //audioDev = "";
+        if (disableAudio == false)
+        {
+            // find the ALSA device associated with the V4L2 device
+            //audioDev = "";
+            ALSACapture* audioCapture = NULL;
+            // Init audio capture
+            if (alsaAudio == true) {
+                LOG_S(INFO)<< "Create ALSA audio Source..." << audioDev;
+                ALSACaptureParameters param(audioDev.c_str(), inAudioFreq, outAudioFreq, verbose, encode, SOURCE_DSP);
+                audioCapture = ALSACapture::createNew(param);
+
+            } else {
+                LOG_S(INFO)<< "Create SDK audio Source...";
+                ALSACaptureParameters param(audioDev.c_str(), inAudioFreq, outAudioFreq, verbose, encode, SOURCE_IMP);
+                audioCapture = ALSACapture::createNew(param);
+            }
+            if (audioCapture)
+            {
+                FramedSource* audioSource = V4L2DeviceSource::createNew(*env, new DeviceCaptureAccess<ALSACapture>(audioCapture), -1, queueSize, useThread);
+                if (audioSource == NULL)
+                {
+                    LOG_S(FATAL) << "Unable to create source for device " << audioDev;
+                    delete audioCapture;
+                }
+                else
+                {
+                    std::ostringstream os;
+                    switch (encode)
+                    {
+                        case ENCODE_MP3:
+                            os << "audio/MPEG";
+                            break;
+                        case ENCODE_OPUS:
+                            outAudioFreq = 48000;
+                            os << "audio/OPUS/" << outAudioFreq << "/1";
+                            break;
+                        case ENCODE_PCM:
+                            outAudioFreq = inAudioFreq;
+                            os << "audio/L16/" << outAudioFreq << "/1";
+                            break;
+                        case ENCODE_ULAW:
+                            outAudioFreq = inAudioFreq;
+                            os << "audio/PCMU/"  << outAudioFreq << "/1";;
+                            break;
+                    }
+                    //os << "audio/L16/" << audioCapture->getSampleRate() << "/" << audioCapture->getChannels();
+                    //os << "audio/L16/8000/1";
+                    //os << "audio/MPEG";
+                    rtpAudioFormat.assign(os.str());
+
+                    // extend buffer size if needed
+                    if (audioCapture->getBufferSize() > OutPacketBuffer::maxSize)
+                    {
+                        OutPacketBuffer::maxSize = audioCapture->getBufferSize();
+                    }
+                    audioReplicator = StreamReplicator::createNew(*env, audioSource, false);
+                }
+            }
+        }
+
+
+        // Create Multicast Session
+        if (multicast) {
+            LOG_S(INFO) << "RTP  address " << inet_ntoa(destinationAddress) << ":" << rtpPortNum;
+            LOG_S(INFO) << "RTCP address " << inet_ntoa(destinationAddress) << ":" << rtcpPortNum;
+
+            std::list < ServerMediaSubsession * > subSession;
+            if (videoReplicator) {
+                subSession.push_back(
+                        MulticastServerMediaSubsession::createNew(*env, destinationAddress, Port(rtpPortNum),
+                                                                  Port(rtcpPortNum), ttl, videoReplicator, rtpFormat));
+                // increment ports for next sessions
+                rtpPortNum += 2;
+                rtcpPortNum += 2;
+            }
+
+            if (audioReplicator) {
+                subSession.push_back(
+                        MulticastServerMediaSubsession::createNew(*env, destinationAddress, Port(rtpPortNum),
+                                                                  Port(rtcpPortNum), ttl, audioReplicator,
+                                                                  rtpAudioFormat));
+
+                // increment ports for next sessions
+                rtpPortNum += 2;
+                rtcpPortNum += 2;
+            }
+            nbSource += addSession(rtspServer, baseUrl + url, subSession);
+        }
+        // Create Unicast Session
+        if (hlsSegment > 0) {
+            std::list < ServerMediaSubsession * > subSession;
+            if (videoReplicator) {
+                subSession.push_back(HLSServerMediaSubsession::createNew(*env, videoReplicator, rtpFormat, hlsSegment));
+            }
+            nbSource += addSession(rtspServer, baseUrl + url, subSession);
+
+            struct in_addr ip;
+            ip.s_addr = ourIPAddress(*env);
+            LOG_S(INFO) << "HLS       http://" << inet_ntoa(ip) << ":" << rtspPort << "/" << baseUrl + url << ".m3u8";
+            LOG_S(INFO) << "MPEG-DASH http://" << inet_ntoa(ip) << ":" << rtspPort << "/" << baseUrl + url << ".mpd";
+        } else {
+            std::list < ServerMediaSubsession * > subSession;
+            if (videoReplicator) {
+                subSession.push_back(UnicastServerMediaSubsession::createNew(*env, videoReplicator, rtpFormat));
+            }
+            if (audioReplicator) {
+                subSession.push_back(UnicastServerMediaSubsession::createNew(*env, audioReplicator, rtpAudioFormat));
+            }
+            nbSource += addSession(rtspServer, baseUrl + url, subSession);
+        }
+
+
+        if (nbSource > 0) {
+            // main loop
+            signal(SIGINT, sighandler);
+            signal(SIGUSR1, sighandlerUsr1);
+
+            env->taskScheduler().doEventLoop(&quit);
+            LOG_S(INFO) << "Exiting....";
+        }
+
+        Medium::close(rtspServer);
+
+        if (out) {
+            delete out;
+        }
+    }
+
+    env->reclaim();
+    delete scheduler;
+
+    return 0;
 }
 
 
diff -Nura v4l2rtspserver_imp_tools/src/MemoryBufferSink.cpp v4l2rtspserver-master/src/MemoryBufferSink.cpp
--- v4l2rtspserver_imp_tools/src/MemoryBufferSink.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/MemoryBufferSink.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-/* ---------------------------------------------------------------------------
-** This software is in the public domain, furnished "as is", without technical
-** support, and with no warranty, express or implied, as to its usefulness for
-** any purpose.
-**
-** MemoryBufferSink.cpp
-** 
-** -------------------------------------------------------------------------*/
-
-#include "MemoryBufferSink.h"
-
-// -----------------------------------------
-//    MemoryBufferSink
-// -----------------------------------------
-MemoryBufferSink::MemoryBufferSink(UsageEnvironment& env, unsigned bufferSize, unsigned int sliceDuration) : MediaSink(env), m_bufferSize(bufferSize), m_refTime(0), m_sliceDuration(sliceDuration)
-{
-	m_buffer = new unsigned char[m_bufferSize];
-}
-
-MemoryBufferSink::~MemoryBufferSink() 
-{
-	delete[] m_buffer;
-}
-
-
-Boolean MemoryBufferSink::continuePlaying() 
-{
-	Boolean ret = False;
-	if (fSource != NULL) 
-	{
-		fSource->getNextFrame(m_buffer, m_bufferSize,
-				afterGettingFrame, this,
-				onSourceClosure, this);
-		ret = True;
-	}
-	return ret;
-}
-
-
-void MemoryBufferSink::afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime) 
-{
-	if (numTruncatedBytes > 0) 
-	{
-		envir() << "FileSink::afterGettingFrame(): The input frame data was too large for our buffer size \n";
-		// realloc a bigger buffer
-		m_bufferSize += numTruncatedBytes;
-		delete[] m_buffer;
-		m_buffer = new unsigned char[m_bufferSize];
-	}
-	else
-	{			
-		// append buffer to slice buffer
-		if (m_refTime == 0)
-		{
-			m_refTime = presentationTime.tv_sec;
-		}
-		unsigned int slice = (presentationTime.tv_sec-m_refTime)/m_sliceDuration;
-		std::string& outputBuffer = m_outputBuffers[slice];
-		outputBuffer.append((const char*)m_buffer, frameSize);
-		
-		// remove old buffers
-		while (m_outputBuffers.size()>3)
-		{
-			m_outputBuffers.erase(m_outputBuffers.begin());
-		}
-	}
-
-	continuePlaying();
-}
-
-unsigned int MemoryBufferSink::getBufferSize(unsigned int slice)
-{
-	unsigned int size = 0;
-	std::map<unsigned int,std::string>::iterator it = m_outputBuffers.find(slice);
-	if (it != m_outputBuffers.end())
-	{
-		size = it->second.size();
-	}
-	return size;
-}
-
-std::string MemoryBufferSink::getBuffer(unsigned int slice)
-{
-	std::string content;
-	std::map<unsigned int,std::string>::iterator it = m_outputBuffers.find(slice);
-	if (it != m_outputBuffers.end())
-	{
-		content = it->second;
-
-	}
-	return content;
-}
-
-unsigned int MemoryBufferSink::firstTime()
-{
-	unsigned int firstTime = 0;
-	if (m_outputBuffers.size() != 0)				
-	{
-		firstTime = m_outputBuffers.begin()->first;
-	}
-	return firstTime*m_sliceDuration;
-}
-
-unsigned int MemoryBufferSink::duration()
-{
-	unsigned int duration = 0;
-	if (m_outputBuffers.size() != 0)				
-	{
-		duration = m_outputBuffers.rbegin()->first - m_outputBuffers.begin()->first;
-	}
-	return (duration)*m_sliceDuration;
-}
diff -Nura v4l2rtspserver_imp_tools/src/MJPEGVideoSource.cpp v4l2rtspserver-master/src/MJPEGVideoSource.cpp
--- v4l2rtspserver_imp_tools/src/MJPEGVideoSource.cpp	2019-02-01 20:08:29.566626000 +0100
+++ v4l2rtspserver-master/src/MJPEGVideoSource.cpp	2019-02-03 20:24:23.650172000 +0100
@@ -12,7 +12,8 @@
 ** -------------------------------------------------------------------------*/
 
 #include "MJPEGVideoSource.h"
-
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
       
 void MJPEGVideoSource::afterGettingFrame(unsigned frameSize,unsigned numTruncatedBytes,struct timeval presentationTime,unsigned durationInMicroseconds)
 {
@@ -24,7 +25,7 @@
 	    // SOF
 	    if ( ((i+11) < frameSize)  && (fTo[i] == 0xFF) && (fTo[i+1] == 0xC0) ) {
 		int length = (fTo[i+2]<<8)|(fTo[i+3]);		    
-		LOG(DEBUG) << "SOF length:" << length;
+		LOG_S(INFO)  << "SOF length:" << length;
 
 		m_height = (fTo[i+5]<<5)|(fTo[i+6]>>3);
 		m_width  = (fTo[i+7]<<5)|(fTo[i+8]>>3);
@@ -35,28 +36,26 @@
 		} else if (hv_subsampling == 0x22 ) {
 		    m_type = 1; // JPEG 4:2:0
 		} else {
-		    LOG(NOTICE) << "not managed sampling:0x" << std::hex << hv_subsampling;
+		   LOG_S(INFO)  << "not managed sampling:0x" << std::hex << hv_subsampling;
 		    m_type = 255;
 		}
-		    
-		int precision = fTo[i+4];		        
-		LOG(INFO) << "width:" << (int)(m_width<<3) << " height:" << (int)(m_height<<3) << " type:"<< (int)m_type << " precision:" << precision;
+		LOG_S(INFO)  << "width:" << (int)(m_width<<3) << " height:" << (int)(m_height<<3) << " type:"<< (int)m_type;
 
 		i+=length+2;
 	    }
 	    // DQT
 	    else if ( ( (i+5+64) < frameSize)  && (fTo[i] == 0xFF) && (fTo[i+1] == 0xDB)) {
 		int length = (fTo[i+2]<<8)|(fTo[i+3]);		    
-		LOG(DEBUG) << "DQT length:" << length;
+		LOG_S(INFO) << "DQT length:" << length;
 
-		unsigned int precision = (fTo[i+4]&0xf0)<<4;
+		unsigned int precision = fTo[i+4]<<4;
 		unsigned int quantIdx  = fTo[i+4]&0x0f;
-		unsigned int quantSize = length-4;
+		unsigned int quantSize = length-3;
 		if (quantSize*quantIdx+quantSize <= sizeof(m_qTable)) {
 		    memcpy(m_qTable + quantSize*quantIdx, fTo + i + 5, quantSize);
-		    LOG(DEBUG) << "Quantization table idx:" << quantIdx << " precision:" << precision << " size:" << quantSize << " total size:" << m_qTableSize;
 		    if (quantSize*quantIdx+quantSize > m_qTableSize) {
 			m_qTableSize = quantSize*quantIdx+quantSize;
+			LOG_S(INFO)  << "Quantization table idx:" << quantIdx << " precision:" << precision << " size:" << quantSize << " total size:" << m_qTableSize;
 		    }
 		}
 
@@ -65,7 +64,7 @@
 	    // SOS
 	    else if ( ((i+1) < frameSize) && (fTo[i] == 0xFF) && (fTo[i+1] == 0xDA) ) {            
 		int length = (fTo[i+2]<<8)|(fTo[i+3]);		    
-		LOG(DEBUG) << "SOS length:" << length;                
+		LOG_S(INFO)  << "SOS length:" << length;
 		
 		headerSize = i+length+2;                
 	    } else {
@@ -74,11 +73,11 @@
 	}
 
 	if (headerSize != 0) {
-	    LOG(DEBUG) << "headerSize:" << headerSize;
+	    LOG_S(INFO) << "headerSize:" << headerSize;
 	    fFrameSize = frameSize - headerSize;
 	    memmove( fTo, fTo + headerSize, fFrameSize );
 	} else {
-	    LOG(NOTICE) << "Bad header => dropping frame";
+	    LOG_S(INFO)  << "Bad header => dropping frame";
 	}
 
 	fNumTruncatedBytes = numTruncatedBytes;
diff -Nura v4l2rtspserver_imp_tools/src/MulticastServerMediaSubsession.cpp v4l2rtspserver-master/src/MulticastServerMediaSubsession.cpp
--- v4l2rtspserver_imp_tools/src/MulticastServerMediaSubsession.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/MulticastServerMediaSubsession.cpp	2019-02-03 20:24:23.650172000 +0100
@@ -29,7 +29,7 @@
 	Groupsock* rtcpGroupsock = new Groupsock(env, destinationAddress, rtcpPortNum, ttl);
 
 	// Create a RTP sink
-	RTPSink* videoSink = createSink(env, rtpGroupsock, 96, format, dynamic_cast<V4L2DeviceSource*>(replicator->inputSource()));
+	RTPSink* videoSink = createSink(env, rtpGroupsock, 96, format);
 
 	// Create 'RTCP instance'
 	const unsigned maxCNAMElen = 100;
diff -Nura v4l2rtspserver_imp_tools/src/OSD.cpp v4l2rtspserver-master/src/OSD.cpp
--- v4l2rtspserver_imp_tools/src/OSD.cpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/src/OSD.cpp	2019-02-03 20:24:23.650172000 +0100
@@ -0,0 +1,310 @@
+#include "../inc/OSD.hpp"
+
+#include <stdexcept>
+#include <tuple>
+
+#include <ctime>
+
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
+
+#include "sharedmem.h"
+#include "../tools/sharedmem.h"
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+#include FT_MODULE_H
+#include FT_CFF_DRIVER_H
+
+
+static std::tuple<uint8_t, uint8_t, uint8_t, uint8_t> split_rgba(uint32_t rgba_color) {
+    return std::make_tuple(
+        (rgba_color & 0xFF000000) >> 24,
+        (rgba_color & 0x00FF0000) >> 16,
+        (rgba_color & 0x0000FF00) >> 8,
+        (rgba_color & 0x000000FF) >> 0
+    );
+}
+
+
+OSD::OSD(int x, int y, int width, int height, int layer): _x(x), _y(y), _width(width), _height(height) {
+    LOG_S(INFO) <<  "[OSD]: Created OSD(" << x << ", " << y << ", " << width << ", " << height << ", " << layer << ")";
+
+    region = IMP_OSD_CreateRgn(NULL);
+
+    if (region == INVHANDLE) {
+        throw std::runtime_error("Could not create region");
+    }
+
+    if (IMP_OSD_RegisterRgn(region, 0, NULL) != 0) {
+        throw std::runtime_error("Could not register region");
+    }
+
+    image = nullptr;
+    setBounds(x, y, width, height);
+
+    IMPOSDGrpRgnAttr group_attributes;
+
+    // XXX: unnecessary since we don't read them?
+    if (IMP_OSD_GetGrpRgnAttr(region, 0, &group_attributes) != 0) {
+        throw std::runtime_error("Could not get group region attributes");
+    }
+
+    _layer = layer;
+
+    memset(&group_attributes, 0, sizeof(IMPOSDGrpRgnAttr));
+    group_attributes.show = 0;
+    group_attributes.gAlphaEn = 0;
+    group_attributes.fgAlhpa = 0;
+    group_attributes.bgAlhpa = 0;
+    group_attributes.layer = _layer + 1;
+
+    if (IMP_OSD_SetGrpRgnAttr(region, 0, &group_attributes) != 0) {
+        throw std::runtime_error("Could not set group region attributes");
+    }
+
+    return;
+}
+
+OSD::~OSD() {
+    free(image);
+}
+
+int OSD::getX() {
+    return _x;
+}
+
+int OSD::getY() {
+    return _y;
+}
+
+int OSD::getWidth() {
+    return _width;
+}
+
+int OSD::getHeight() {
+    return _height;
+}
+
+void OSD::setBounds(int x, int y, int width, int height) {
+    _x = x;
+    _y = y;
+    _width = width;
+    _height = height;
+
+    IMPOSDRgnAttr attributes;
+
+    memset(&attributes, 0, sizeof(IMPOSDRgnAttr));
+    attributes.type = OSD_REG_PIC;
+    attributes.rect.p0.x = _x;
+    attributes.rect.p0.y = _y;
+    attributes.rect.p1.x = _x + _width - 1;
+    attributes.rect.p1.y = _y + _height - 1;
+    attributes.fmt = PIX_FMT_ABGR;  // Actually RGBA?
+
+    if (IMP_OSD_SetRgnAttr(region, &attributes) != 0) {
+        throw std::runtime_error("Could not set boundary attributes");
+    }
+
+    clear();
+}
+
+void OSD::clear() {
+    if (image != nullptr) {
+        image = (uint32_t*)realloc(image, sizeof(uint32_t) * _width * _height);
+    } else {
+        image = (uint32_t*)malloc(sizeof(uint32_t) * _width * _height);
+    }
+
+    memset(image, RGBAColor::TRANSPARENT, sizeof(uint32_t) * _width * _height);
+}
+
+void OSD::update() {
+    IMPOSDRgnAttrData attributes_data;
+    memset(&attributes_data, 0, sizeof(attributes_data));
+    attributes_data.picData.pData = (void*)image;
+
+    if (IMP_OSD_UpdateRgnAttrData(region, &attributes_data) != 0) {
+        throw std::runtime_error("Could not update region attributes");
+    }
+}
+
+void OSD::show(bool flag) {
+    if (IMP_OSD_ShowRgn(region, 0, flag) != 0) {
+        throw std::runtime_error("Could not show region");
+    }
+}
+
+void OSD::drawBitmap(int x, int y, int width, int height, uint32_t *pixels) {
+    for (int b_y = 0; b_y < height; b_y++) {
+        for (int b_x = 0; b_x < width; b_x++) {
+            int i_x = x + b_x;
+            int i_y = y + b_y;
+
+            if (i_x < 0 || i_y < 0 || i_x > _width || i_y > _height) {
+                continue;
+            }
+
+            setPixel(i_x, i_y, pixels[b_y * width + b_x]);
+        }
+    }
+}
+
+void OSD::setPixel(int x, int y, uint32_t value) {
+    if ((x < 0) || (y < 0) || (x > _width) || (y > _height)) {
+        throw std::invalid_argument("Invalid target coordinates");
+    }
+
+    image[y * _width + x] = value;
+}
+
+uint32_t OSD::getPixel(int x, int y) {
+    if ((x < 0) || (y < 0) || (x > _width) || (y > _height)) {
+        throw std::invalid_argument("Invalid target coordinates");
+    }
+
+    return image[y * _width + x];
+}
+
+
+std::pair<int, int> get_vertical_font_dimensions(FT_Face &face) {
+    int min_below = INT_MAX;
+    int max_above = INT_MIN;
+
+    FT_GlyphSlot slot = face->glyph;
+    int last_glyph_index = 0;
+
+    // XXX: surely there's a better way to do this
+    for (char c = ' '; c < '~'; c++) {
+        int glyph_index = FT_Get_Char_Index(face, c);
+
+        if (FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT) != 0) {
+            throw std::runtime_error("Could not load glyph for character");
+        }
+
+        if (FT_Render_Glyph(slot, FT_RENDER_MODE_NORMAL) != 0) {
+            throw std::runtime_error("Could not render glyph for character");
+        }
+
+        FT_Vector kerning_delta = {0, 0};
+
+        if (last_glyph_index && glyph_index) {
+            FT_Get_Kerning(face, last_glyph_index, glyph_index, FT_KERNING_DEFAULT, &kerning_delta);
+        }
+
+        last_glyph_index = glyph_index;
+
+        if (min_below > (int)kerning_delta.y + (int)slot->bitmap_top - (int)slot->bitmap.rows) {
+            min_below = (int)kerning_delta.y + (int)slot->bitmap_top - (int)slot->bitmap.rows;
+        }
+
+        if (max_above < (int)kerning_delta.y + (int)slot->bitmap.rows) {
+            max_above = (int)kerning_delta.y + (int)slot->bitmap.rows;
+        }
+
+    }
+
+    return std::make_pair(max_above - min_below, min_below);
+}
+
+
+
+uint32_t mix_rgba_with_grayscale(uint32_t rgba_color, uint8_t value) {
+    // This fades the color out to black as value decreases, giving the text a slightly darker border
+
+    int r, g, b, a;
+    std::tie(r, g, b, a) = split_rgba(rgba_color);
+
+    return make_rgba((r * value) / 255, (g * value) / 255, (b * value) / 255, (a * value) / 255);
+}
+
+void osd_draw_timestamp(OSD &timestamp_osd, FT_Face &face, int baseline_offset, shared_conf &currentConfig) {
+    char text[STRING_MAX_SIZE];
+    time_t current_time = time(nullptr);
+    strftime(text, STRING_MAX_SIZE, currentConfig.osdTimeDisplay, localtime(&current_time));
+
+    FT_Vector pen;
+    pen.x = 0;
+    pen.y = timestamp_osd.getHeight() + baseline_offset;
+
+    timestamp_osd.clear();
+
+    FT_GlyphSlot glyph = face->glyph;
+    int last_glyph_index = 0;
+
+    for (int i = 0; text[i] != '\x00'; i++) {
+        char c = text[i];
+
+        int glyph_index = FT_Get_Char_Index(face, c);
+
+        if (FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT) != 0) {
+            LOG_S(INFO) << "Could not load glyph for character: " << c;
+            break;
+        }
+
+        if (FT_Render_Glyph(glyph, FT_RENDER_MODE_NORMAL) != 0) {
+            LOG_S(INFO) << "Could not render glyph for character: " << c;
+            break;
+        }
+
+        FT_Vector kerning_delta;
+        kerning_delta.x = 0;
+        kerning_delta.y = 0;
+
+        if (last_glyph_index && glyph_index) {
+            FT_Get_Kerning(face, last_glyph_index, glyph_index, FT_KERNING_DEFAULT, &kerning_delta);
+        }
+
+        last_glyph_index = glyph_index;
+
+        // Draw the bitmap
+        FT_Bitmap &bitmap = glyph->bitmap;
+
+        int start_x = pen.x + glyph->bitmap_left + kerning_delta.x;
+        int start_y = pen.y - glyph->bitmap_top + kerning_delta.y;
+
+        for (int x = 0; x < (int)bitmap.width; x++) {
+            for (int y = 0; y < (int)bitmap.rows; y++) {
+                int shifted_x = start_x + x;
+                int shifted_y = start_y + y;
+
+                // Don't draw out of bounds
+                if (shifted_x < 0 || shifted_y < 0 || shifted_x >= timestamp_osd.getWidth() || shifted_y >= timestamp_osd.getHeight()) {
+                    continue;
+                }
+
+                int value = bitmap.buffer[y * bitmap.width + x];
+
+
+                if (value != 0) {
+                    timestamp_osd.setPixel(shifted_x, shifted_y, mix_rgba_with_grayscale(currentConfig.osdColor, value));
+                } else {
+                    timestamp_osd.setPixel(shifted_x, shifted_y, RGBAColor::TRANSPARENT);
+                }
+            }
+        }
+
+        // Move the pen
+        pen.x += (glyph->advance.x / 64) + currentConfig.osdSpace;
+        pen.y -= glyph->advance.y / 64;
+    }
+
+    timestamp_osd.update();
+}
+
+void osd_draw_detection_circle(OSD &motion_osd, bool isDetecting, shared_conf &currentConfig) {
+    motion_osd.clear();
+
+    if (isDetecting) {
+        for (int x = 0; x < (int)DETECTION_CIRCLE_SIZE; x++) {
+            for (int y = 0; y < (int)DETECTION_CIRCLE_SIZE; y++) {
+                motion_osd.setPixel(x, y, mix_rgba_with_grayscale(currentConfig.motionOSD, DETECTION_CIRCLE_ALPHA[x + y * DETECTION_CIRCLE_SIZE]));
+            }
+        }
+    }
+
+    motion_osd.update();
+}
+
diff -Nura v4l2rtspserver_imp_tools/src/SegmentServerMediaSubsession.cpp v4l2rtspserver-master/src/SegmentServerMediaSubsession.cpp
--- v4l2rtspserver_imp_tools/src/SegmentServerMediaSubsession.cpp	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/src/SegmentServerMediaSubsession.cpp	2019-02-03 20:24:23.651172000 +0100
@@ -0,0 +1,159 @@
+/* ---------------------------------------------------------------------------
+** This software is in the public domain, furnished "as is", without technical
+** support, and with no warranty, express or implied, as to its usefulness for
+** any purpose.
+**
+** SegmentServerMediaSubsession.cpp
+** 
+** -------------------------------------------------------------------------*/
+
+#include <map>
+
+#include "SegmentServerMediaSubsession.h"
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
+// -----------------------------------------
+//    ServerMediaSubsession for HLS
+// -----------------------------------------
+HLSServerMediaSubsession::HLSSink::HLSSink(UsageEnvironment& env, unsigned bufferSize, unsigned int sliceDuration) : MediaSink(env), m_bufferSize(bufferSize), m_refTime(0), m_sliceDuration(sliceDuration)
+{
+	m_buffer = new unsigned char[m_bufferSize];
+}
+
+HLSServerMediaSubsession::HLSSink::~HLSSink() 
+{
+	delete[] m_buffer;
+}
+
+
+Boolean HLSServerMediaSubsession::HLSSink::continuePlaying() 
+{
+	Boolean ret = False;
+	if (fSource != NULL) 
+	{
+		fSource->getNextFrame(m_buffer, m_bufferSize,
+				afterGettingFrame, this,
+				onSourceClosure, this);
+		ret = True;
+	}
+	return ret;
+}
+
+
+void HLSServerMediaSubsession::HLSSink::afterGettingFrame(unsigned frameSize, unsigned numTruncatedBytes, struct timeval presentationTime) 
+{
+	if (numTruncatedBytes > 0) 
+	{
+		envir() << "FileSink::afterGettingFrame(): The input frame data was too large for our buffer size \n";
+		// realloc a bigger buffer
+		m_bufferSize += numTruncatedBytes;
+		delete[] m_buffer;
+		m_buffer = new unsigned char[m_bufferSize];
+	}
+	else
+	{			
+		// append buffer to slice buffer
+		if (m_refTime == 0)
+		{
+			m_refTime = presentationTime.tv_sec;
+		}
+		unsigned int slice = (presentationTime.tv_sec-m_refTime)/m_sliceDuration;
+		std::string& outputBuffer = m_outputBuffers[slice];
+		outputBuffer.append((const char*)m_buffer, frameSize);
+		
+		// remove old buffers
+		while (m_outputBuffers.size()>5)
+		{
+			m_outputBuffers.erase(m_outputBuffers.begin());
+		}
+	}
+
+	continuePlaying();
+}
+
+unsigned int HLSServerMediaSubsession::HLSSink::getHLSBufferSize(unsigned int slice)
+{
+	unsigned int size = 0;
+	std::map<unsigned int,std::string>::iterator it = m_outputBuffers.find(slice);
+	if (it != m_outputBuffers.end())
+	{
+		size = it->second.size();
+	}
+	return size;
+}
+
+const char* HLSServerMediaSubsession::HLSSink::getHLSBuffer(unsigned int slice)
+{
+	const char* content = NULL;
+	std::map<unsigned int,std::string>::iterator it = m_outputBuffers.find(slice);
+	if (it != m_outputBuffers.end())
+	{
+		content = it->second.c_str();
+	}
+	return content;
+}
+
+unsigned int HLSServerMediaSubsession::HLSSink::firstTime()
+{
+	unsigned int firstTime = 0;
+	if (m_outputBuffers.size() != 0)				
+	{
+		firstTime = m_outputBuffers.begin()->first;
+	}
+	return firstTime*m_sliceDuration;
+}
+
+unsigned int HLSServerMediaSubsession::HLSSink::duration()
+{
+	unsigned int duration = 0;
+	if (m_outputBuffers.size() != 0)				
+	{
+		duration = m_outputBuffers.rbegin()->first - m_outputBuffers.begin()->first;
+	}
+	return (duration)*m_sliceDuration;
+}
+
+
+HLSServerMediaSubsession::HLSServerMediaSubsession(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration) 
+		: UnicastServerMediaSubsession(env, replicator, format), m_slice(0)
+{
+	// Create a source
+	FramedSource* source = replicator->createStreamReplica();			
+	FramedSource* videoSource = createSource(env, source, format);
+	
+	// Start Playing the HLS Sink
+	m_hlsSink = HLSSink::createNew(env, OutPacketBuffer::maxSize, sliceDuration);
+	m_hlsSink->startPlaying(*videoSource, NULL, NULL);			
+}
+
+HLSServerMediaSubsession::~HLSServerMediaSubsession()
+{
+	Medium::close(m_hlsSink);
+}
+	
+float HLSServerMediaSubsession::getCurrentNPT(void* streamToken)
+{
+	return (m_hlsSink->firstTime());
+}
+
+float HLSServerMediaSubsession::duration() const 
+{ 
+	return (m_hlsSink->duration()); 
+}
+
+void HLSServerMediaSubsession::seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes) 
+{
+	m_slice = seekNPT / m_hlsSink->getSliceDuration();
+	seekNPT = m_slice * m_hlsSink->getSliceDuration();
+	numBytes = m_hlsSink->getHLSBufferSize(m_slice);
+	LOG_S(INFO) << "seek seekNPT:" << seekNPT << " slice:" << m_slice << " numBytes:" << numBytes;
+	
+}	
+
+FramedSource* HLSServerMediaSubsession::getStreamSource(void* streamToken) 
+{
+	unsigned int size = m_hlsSink->getHLSBufferSize(m_slice);
+	u_int8_t* content = new u_int8_t[size];
+	memcpy(content, m_hlsSink->getHLSBuffer(m_slice), size);
+	return ByteStreamMemoryBufferSource::createNew(envir(), content, size);			
+}					
diff -Nura v4l2rtspserver_imp_tools/src/ServerMediaSubsession.cpp v4l2rtspserver-master/src/ServerMediaSubsession.cpp
--- v4l2rtspserver_imp_tools/src/ServerMediaSubsession.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/ServerMediaSubsession.cpp	2019-02-03 20:24:23.651172000 +0100
@@ -8,118 +8,123 @@
 ** -------------------------------------------------------------------------*/
 
 #include <sstream>
-#include <linux/videodev2.h>
+
 
 // project
 #include "ServerMediaSubsession.h"
 #include "MJPEGVideoSource.h"
 #include "DeviceSource.h"
-
+#define LOGURU_WITH_STREAMS 1
+#include <loguru.hpp>
 // ---------------------------------
 //   BaseServerMediaSubsession
 // ---------------------------------
-FramedSource* BaseServerMediaSubsession::createSource(UsageEnvironment& env, FramedSource* videoES, const std::string& format)
-{
-	FramedSource* source = NULL;
-	if (format == "video/MP2T")
-	{
-		source = MPEG2TransportStreamFramer::createNew(env, videoES); 
-	}
-	else if (format == "video/H264")
-	{
-		source = H264VideoStreamDiscreteFramer::createNew(env, videoES);
-	}
+FramedSource *
+BaseServerMediaSubsession::createSource(UsageEnvironment &env, FramedSource *videoES, const std::string &format) {
+    FramedSource *source = NULL;
+    LOG_S(INFO) << "Creating Source...";
+    if (format == "video/MP2T") {
+        source = MPEG2TransportStreamFramer::createNew(env, videoES);
+    } else if (format == "video/H264") {
+        LOG_S(INFO) << "Creating H264 Source...";
+        source = H264VideoStreamDiscreteFramer::createNew(env, videoES);
+    }
 #if LIVEMEDIA_LIBRARY_VERSION_INT > 1414454400
-	else if (format == "video/H265")
-	{
-		source = H265VideoStreamDiscreteFramer::createNew(env, videoES);
-	}
+        else if (format == "video/H265")
+        {
+            source = H265VideoStreamDiscreteFramer::createNew(env, videoES);
+        }
 #endif
-	else if (format == "video/JPEG")
-	{
-		source = MJPEGVideoSource::createNew(env, videoES);
-	}
-	else 
-	{
-		source = videoES;
-	}
-	return source;
+    else if (format == "video/JPEG") {
+        LOG_S(INFO) << "Creating JPG Source...";
+        source = MJPEGVideoSource::createNew(env, videoES);
+    } else {
+        LOG_S(INFO) << "Creating normal Source...";
+        source = videoES;
+    }
+    return source;
 }
 
-RTPSink*  BaseServerMediaSubsession::createSink(UsageEnvironment& env, Groupsock* rtpGroupsock, unsigned char rtpPayloadTypeIfDynamic, const std::string& format, V4L2DeviceSource* source)
-{
-	RTPSink* videoSink = NULL;
-	if (format == "video/MP2T")
-	{
-		videoSink = SimpleRTPSink::createNew(env, rtpGroupsock,rtpPayloadTypeIfDynamic, 90000, "video", "MP2T", 1, True, False); 
-	}
-	else if (format == "video/H264")
-        {
-		videoSink = H264VideoRTPSink::createNew(env, rtpGroupsock,rtpPayloadTypeIfDynamic);
-	}
-	else if (format == "video/VP8")
-	{
-		videoSink = VP8VideoRTPSink::createNew (env, rtpGroupsock,rtpPayloadTypeIfDynamic); 
-	}
+RTPSink *BaseServerMediaSubsession::createSink(UsageEnvironment &env, Groupsock *rtpGroupsock,
+                                               unsigned char rtpPayloadTypeIfDynamic, const std::string &format) {
+    RTPSink *videoSink = NULL;
+    LOG_S(INFO) << "Creating Sink for format : " << format;
+    if (format == "video/MP2T") {
+        videoSink = SimpleRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic, 90000, "video", "MP2T", 1,
+                                             True, False);
+    } else if (format == "video/H264") {
+        videoSink = H264VideoRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic);
+    } else if (format == "video/VP8") {
+        videoSink = VP8VideoRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic);
+    }
 #if LIVEMEDIA_LIBRARY_VERSION_INT > 1414454400
-	else if (format == "video/VP9")
-	{
-		videoSink = VP9VideoRTPSink::createNew (env, rtpGroupsock,rtpPayloadTypeIfDynamic); 
-	}
-	else if (format == "video/H265")
+        else if (format == "video/VP9")
         {
-		videoSink = H265VideoRTPSink::createNew(env, rtpGroupsock,rtpPayloadTypeIfDynamic);
-	}
-#endif	
-	else if (format == "video/JPEG")
-	{
-		videoSink = JPEGVideoRTPSink::createNew (env, rtpGroupsock); 
-    } 
-#if LIVEMEDIA_LIBRARY_VERSION_INT >= 1536192000	
-	else if (format =="video/RAW") 
-	{ 
-		std::string sampling;
-		switch (source->getCaptureFormat()) {
-			case V4L2_PIX_FMT_YUV444: sampling = "YCbCr-4:4:4"; break;
-			case V4L2_PIX_FMT_YUYV: sampling = "YCbCr-4:2:2"; break;
-		}
-		videoSink = RawVideoRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic, source->getHeight(), source->getWidth(), 8, sampling.c_str());
-		if (videoSink) {
-			source->setAuxLine(videoSink->auxSDPLine());
-		}
-    } 
-#endif	
-	else if (format.find("audio/L16") == 0)
-	{
-		std::istringstream is(format);
-		std::string dummy;
-		getline(is, dummy, '/');	
-		getline(is, dummy, '/');	
-		std::string sampleRate("44100");
-		getline(is, sampleRate, '/');	
-		std::string channels("2");
-		getline(is, channels);	
-		videoSink = SimpleRTPSink::createNew(env, rtpGroupsock,rtpPayloadTypeIfDynamic, atoi(sampleRate.c_str()), "audio", "L16", atoi(channels.c_str()), True, False); 
-	}
-	return videoSink;
+            videoSink = VP9VideoRTPSink::createNew (env, rtpGroupsock,rtpPayloadTypeIfDynamic);
+        }
+        else if (format == "video/H265")
+            {
+            videoSink = H265VideoRTPSink::createNew(env, rtpGroupsock,rtpPayloadTypeIfDynamic);
+        }
+#endif
+    else if (format == "video/JPEG") {
+        videoSink = JPEGVideoRTPSink::createNew(env, rtpGroupsock);
+    } else if (format.find("audio/L16") == 0) {
+        std::istringstream is(format);
+        std::string dummy;
+        getline(is, dummy, '/');
+        getline(is, dummy, '/');
+        std::string sampleRate("44100");
+        getline(is, sampleRate, '/');
+        std::string channels("2");
+        getline(is, channels);
+        videoSink = SimpleRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic, std::stoi(sampleRate), "audio",
+                                             "L16", std::stoi(channels), True, False);
+    } else if (format == "audio/MPEG") {
+
+        /*
+        unsigned char rtpPayloadFormat = 96; // A dynamic payload format code
+        videoSink = MP3ADURTPSink::createNew(env, rtpGroupsock,
+                                             rtpPayloadFormat);
+
+         */
+        videoSink = MPEG1or2AudioRTPSink::createNew (env, rtpGroupsock);
+    }else if (format.find("audio/OPUS") ==0) {
+            std::istringstream is(format);
+            std::string dummy;
+            getline(is, dummy, '/');
+            getline(is, dummy, '/');
+            std::string sampleRate("48000");
+            getline(is, sampleRate, '/');
+            std::string channels("1");
+            getline(is, channels);
+            videoSink= SimpleRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic, std::stoi(sampleRate), "audio", "OPUS", std::stoi(channels), False);
+     } else if (format.find("audio/PCMU") ==0) {
+       std::istringstream is(format);
+       std::string dummy;
+       getline(is, dummy, '/');
+       getline(is, dummy, '/');
+       std::string sampleRate("8000");
+       getline(is, sampleRate, '/');
+       videoSink= SimpleRTPSink::createNew(env, rtpGroupsock, rtpPayloadTypeIfDynamic, std::stoi(sampleRate), "audio", "PCMU", 1, False);
+     }
+    return videoSink;
 }
 
-char const* BaseServerMediaSubsession::getAuxLine(V4L2DeviceSource* source,unsigned char rtpPayloadType)
-{
-	const char* auxLine = NULL;
-	if (source)
-	{
-		std::ostringstream os; 
-		os << "a=fmtp:" << int(rtpPayloadType) << " ";				
-		os << source->getAuxLine();				
-		os << "\r\n";		
-		int width = source->getWidth();
-		int height = source->getHeight();
-		if ( (width > 0) && (height>0) ) {
-			os << "a=x-dimensions:" << width << "," <<  height  << "\r\n";				
-		}
-		auxLine = strdup(os.str().c_str());
-	} 
-	return auxLine;
+char const *BaseServerMediaSubsession::getAuxLine(V4L2DeviceSource *source, unsigned char rtpPayloadType) {
+    const char *auxLine = NULL;
+    if (source) {
+        std::ostringstream os;
+        os << "a=fmtp:" << int(rtpPayloadType) << " ";
+        os << source->getAuxLine();
+        os << "\r\n";
+        int width = source->getWidth();
+        int height = source->getHeight();
+        if ((width > 0) && (height > 0)) {
+            os << "a=x-dimensions:" << width << "," << height << "\r\n";
+        }
+        auxLine = strdup(os.str().c_str());
+    }
+    return auxLine;
 }
 
diff -Nura v4l2rtspserver_imp_tools/src/TSServerMediaSubsession.cpp v4l2rtspserver-master/src/TSServerMediaSubsession.cpp
--- v4l2rtspserver_imp_tools/src/TSServerMediaSubsession.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/TSServerMediaSubsession.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/* ---------------------------------------------------------------------------
-** This software is in the public domain, furnished "as is", without technical
-** support, and with no warranty, express or implied, as to its usefulness for
-** any purpose.
-**
-** TSServerMediaSubsession.cpp
-** 
-** -------------------------------------------------------------------------*/
-
-#include "TSServerMediaSubsession.h"
-#include "AddH26xMarkerFilter.h"
-
-TSServerMediaSubsession::TSServerMediaSubsession(UsageEnvironment& env, StreamReplicator* replicator, const std::string& format, unsigned int sliceDuration) 
-		: UnicastServerMediaSubsession(env, replicator, "video/MP2T"), m_slice(0)
-{
-	// Create a source
-	FramedSource* source = replicator->createStreamReplica();
-	
-	
-	if (format == "video/H264") {
-		// add marker
-		FramedSource* filter = new AddH26xMarkerFilter(env, source);
-		// mux to TS		
-		MPEG2TransportStreamFromESSource* muxer = MPEG2TransportStreamFromESSource::createNew(env);
-		muxer->addNewVideoSource(filter, 5);
-		source = muxer;
-	} else if (format == "video/H265") {
-		// add marker
-		FramedSource* filter = new AddH26xMarkerFilter(env, source);
-		// mux to TS		
-		MPEG2TransportStreamFromESSource* muxer = MPEG2TransportStreamFromESSource::createNew(env);
-		muxer->addNewVideoSource(filter, 6);
-		source = muxer;
-	}
-	
-	FramedSource* videoSource = createSource(env, source, m_format);
-	
-	// Start Playing the HLS Sink
-	m_hlsSink = MemoryBufferSink::createNew(env, OutPacketBuffer::maxSize, sliceDuration);
-	m_hlsSink->startPlaying(*videoSource, NULL, NULL);			
-}
-
-TSServerMediaSubsession::~TSServerMediaSubsession()
-{
-	Medium::close(m_hlsSink);
-}
-	
-float TSServerMediaSubsession::getCurrentNPT(void* streamToken)
-{
-	return (m_hlsSink->firstTime());
-}
-
-float TSServerMediaSubsession::duration() const 
-{ 
-	return (m_hlsSink->duration()); 
-}
-
-void TSServerMediaSubsession::seekStream(unsigned clientSessionId, void* streamToken, double& seekNPT, double streamDuration, u_int64_t& numBytes) 
-{
-	m_slice = seekNPT / m_hlsSink->getSliceDuration();
-	seekNPT = m_slice * m_hlsSink->getSliceDuration();
-	numBytes = m_hlsSink->getBufferSize(m_slice);
-	std::cout << "seek seekNPT:" << seekNPT << " slice:" << m_slice << " numBytes:" << numBytes << std::endl;	
-}	
-
-FramedSource* TSServerMediaSubsession::getStreamSource(void* streamToken) 
-{
-	FramedSource* source = NULL;
-	
-	std::string buffer = m_hlsSink->getBuffer(m_slice);
-	unsigned int size = buffer.size();
-	if ( size != 0 ) {
-		u_int8_t* content = new u_int8_t[size];
-		memcpy(content, buffer.c_str(), size);
-		source = ByteStreamMemoryBufferSource::createNew(envir(), content, size);			
-	}
-	return source;			
-}					
diff -Nura v4l2rtspserver_imp_tools/src/UnicastServerMediaSubsession.cpp v4l2rtspserver-master/src/UnicastServerMediaSubsession.cpp
--- v4l2rtspserver_imp_tools/src/UnicastServerMediaSubsession.cpp	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/src/UnicastServerMediaSubsession.cpp	2019-02-03 20:24:23.651172000 +0100
@@ -27,7 +27,7 @@
 		
 RTPSink* UnicastServerMediaSubsession::createNewRTPSink(Groupsock* rtpGroupsock,  unsigned char rtpPayloadTypeIfDynamic, FramedSource* inputSource)
 {
-	return createSink(envir(), rtpGroupsock, rtpPayloadTypeIfDynamic, m_format, dynamic_cast<V4L2DeviceSource*>(m_replicator->inputSource()));
+	return createSink(envir(), rtpGroupsock, rtpPayloadTypeIfDynamic, m_format);
 }
 		
 char const* UnicastServerMediaSubsession::getAuxSDPLine(RTPSink* rtpSink,FramedSource* inputSource)
diff -Nura v4l2rtspserver_imp_tools/.travis.yml v4l2rtspserver-master/.travis.yml
--- v4l2rtspserver_imp_tools/.travis.yml	2019-02-01 20:08:29.539626000 +0100
+++ v4l2rtspserver-master/.travis.yml	2019-02-03 20:24:23.639172000 +0100
@@ -1,54 +1,53 @@
-dist: xenial
+dist: trusty
+sudo: required
+before_install:
+- sudo apt-get install -y cmake liblog4cpp5-dev liblivemedia-dev libasound2-dev
+- sudo apt-get install -y qemu-user-static debootstrap 
+# for coverage
+- pip install --user cpp-coveralls pyYaml
+# install chroot for cross-compilation
+- sudo debootstrap --arch armhf --foreign --include=g++,git,make,cmake,liblog4cpp5-dev,liblivemedia-dev,libasound2-dev jessie rootfs http://sfo-korg-mirror.kernel.org/debian
+- sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin/
+- sudo chroot rootfs /debootstrap/debootstrap --second-stage
+language: cpp
+compiler:
+- gcc
+script:
+#build on native system
+- cmake . && make && cpack .
+#cleanup
+- rm -rf CMakeCache.txt *.a CMakeFiles
+#build on chroot system
+- sudo mkdir rootfs/home/v4l2rtspserver
+- sudo mount --bind . rootfs/home/v4l2rtspserver
+- sudo chroot rootfs bash -c "cd /home/v4l2rtspserver && cmake . && make && cpack ."
+#run coverage test
+- sudo rm -rf CMakeCache.txt *.a CMakeFiles
+- cmake -DCOVERAGE=ON . && make && make test
+after_success:
+- coveralls --gcov-options '\-lp'
 env:
   global:
-    - secure: jKV3Hj/lvoNjU2JUSUlLsLAHX+BI0R27+qTEPSihHpNGB+NOvbwlfpisrqxA/9nanVhtq9I3PJi2Jd5Pkg+3TkYvRq62ZT1Ty/DuxbQmMWlhEZT6wxbVS7919OZ3K0WAOizt3/HzSxL5XZheGRAKf89SoUF6mOP4V3DCh5rzze4=
-  matrix:
-    - TOOLCHAIN=
-    - TOOLCHAIN=raspberry.toolchain
-    - TOOLCHAIN=mips.toolchain
+  - secure: jKV3Hj/lvoNjU2JUSUlLsLAHX+BI0R27+qTEPSihHpNGB+NOvbwlfpisrqxA/9nanVhtq9I3PJi2Jd5Pkg+3TkYvRq62ZT1Ty/DuxbQmMWlhEZT6wxbVS7919OZ3K0WAOizt3/HzSxL5XZheGRAKf89SoUF6mOP4V3DCh5rzze4=
 addons:
   coverity_scan:
     project:
       name: mpromonet/v4l2rtspserver
     build_command_prepend: cmake .
     build_command: make
-    branch_pattern: coverage
+    branch_pattern: master
     notification_email: scan_notifications@example.com
-  apt:
-    sources:
-      - deadsnakes
-      - ubuntu-toolchain-r-test
-    packages:
-      - git
-      - cmake 
-      - liblog4cpp5-dev
-      - libasound2-dev
-      - g++-mips-linux-gnu
-before_install:
-  - sudo apt-get update
-  - sudo apt-get install g++-mips-linux-gnu
-  - pip install --user cpp-coveralls pyYaml
-language: cpp
-compiler: gcc
-script:
-  - echo "TOOLCHAIN=$TOOLCHAIN"
-  - if [ "$TOOLCHAIN" == "raspberry.toolchain" ]; then git clone --depth 1 https://github.com/raspberrypi/tools.git rpi_tools && export PATH=$PATH:$(pwd)/rpi_tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ; fi
-  - if [ "${TOOLCHAIN}" != "" ]; then cmake -DCMAKE_TOOLCHAIN_FILE=$(pwd)/${TOOLCHAIN} . ; else cmake . ; fi
-  #build 
-  - make 
-  - cpack .
-  #run coverage test
-  - if [ "$COVERAGE" != "" ]; then cmake -DCOVERAGE=ON . && make && make test; fi
-after_success:
-  - if [ "$COVERAGE" != "" ]; then coveralls --gcov-options '\-lp'; fi
 before_deploy:
-  - export RELEASE_DEB_FILE=$(ls *.deb)
+  - export RELEASE_PKG_FILE_X86=$(ls *-x86_64.deb)
+  - export RELEASE_PKG_FILE_ARM=$(ls *-arm*.deb)
+  - echo "deploying ${RELEASE_PKG_FILE_X86} ${RELEASE_PKG_FILE_ARM} to GitHub releases"    
 deploy:
   provider: releases
   api_key:
     secure: gcQy7QO09vfGtcRMi8D+6VykDfK1tuz1jEZRmJER6eZ0p2gRi4F6mtsMRJWt3QsKkZQWkJpPTvCfv9GyNmWTrZV746y5QVnd+mjPx+6K/LgroK4LWgOgzJ6zQ6qfDKU80GbxJOnNv9/HmIcxSCiactxS50tbvntqpBGCmiIL+4U=
   file: 
-    - "${RELEASE_DEB_FILE}"
+    - "${RELEASE_PKG_FILE_X86}"
+    - "${RELEASE_PKG_FILE_ARM}"
   skip_cleanup: true
   on:
     repo: mpromonet/v4l2rtspserver
diff -Nura v4l2rtspserver_imp_tools/v4l2rtspserver-master.ini v4l2rtspserver-master/v4l2rtspserver-master.ini
--- v4l2rtspserver_imp_tools/v4l2rtspserver-master.ini	1970-01-01 01:00:00.000000000 +0100
+++ v4l2rtspserver-master/v4l2rtspserver-master.ini	2019-02-03 20:24:23.663172000 +0100
@@ -0,0 +1,27 @@
+[Hardware]
+# Sensor Name:
+SensorName=jxf22
+SensorAddr=64
+
+[Video]
+Width=1280
+Height=720
+Fps=25
+
+[Audio]
+Enabled=off
+
+[Configuration]
+
+
+#To save some memory you can deactivate the folowing features
+OSD=off
+JPEG=off
+MOTION=off
+
+
+FontFixedWidth=/usr/share/fonts/NotoMono-Regular.ttf
+FontRegular=/usr/share/fonts/NotoSans-Regular.ttf
+DetectionScriptOn=/usr/userscripts/detectionOn.sh
+DetectionScriptOff=/usr/userscripts/detectionOff.sh
+DetectionTracking=/usr/userscripts/detectionTracking.sh
diff -Nura v4l2rtspserver_imp_tools/v4l2rtspserver.service.in v4l2rtspserver-master/v4l2rtspserver.service.in
--- v4l2rtspserver_imp_tools/v4l2rtspserver.service.in	2019-02-01 20:08:29.570626000 +0100
+++ v4l2rtspserver-master/v4l2rtspserver.service.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-[Unit]
-Description=V4L2 RTSP server
-After=network.target
-
-[Service]
-Type=simple
-Restart=always
-RestartSec=5
-ExecStart=@CMAKE_INSTALL_PREFIX@/bin/@PROJECT_NAME@ -S1
-WorkingDirectory=@CMAKE_INSTALL_PREFIX@/share/@PROJECT_NAME@
-
-[Install]
-WantedBy=multi-user.target
